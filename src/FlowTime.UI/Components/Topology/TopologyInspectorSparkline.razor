@using System.Collections.Generic
@using System.Globalization
@using System.Text

@if (!hasData)
{
    <div class="node-inspector-sparkline empty" />
}
else
{
    <div class="node-inspector-sparkline" role="img" aria-label="@resolvedAriaLabel">
        <svg class="node-inspector-sparkline-chart" viewBox="0 0 @SvgWidth @SvgHeight" preserveAspectRatio="none">
            <line class="node-inspector-sparkline-axis"
                  x1="@FormatCoord(LeftPadding)"
                  y1="@FormatCoord(baseLineY)"
                  x2="@FormatCoord(SvgWidth - RightPadding)"
                  y2="@FormatCoord(baseLineY)" />

            @foreach (var tick in tickPositions)
            {
                <line class="node-inspector-sparkline-tick"
                      x1="@FormatCoord(tick)"
                      y1="@FormatCoord(baseLineY)"
                      x2="@FormatCoord(tick)"
                      y2="@FormatCoord(baseLineY - TickHeight)" />
            }

            @foreach (var segment in pathSegments)
            {
                <path d="@segment.Path"
                      stroke="@segment.Color"
                      fill="none"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round" />
            }

            @if (hasHighlight)
            {
                <circle cx="@FormatCoord(highlightX)"
                        cy="@FormatCoord(highlightY)"
                        r="3.5"
                        fill="@highlightColor"
                        stroke="white"
                        stroke-width="1" />
            }

            <text x="@FormatCoord(LeftPadding)"
                  y="@FormatCoord(TopPadding - 4)"
                  class="node-inspector-sparkline-label">@maxLabel</text>

            <text x="@FormatCoord(LeftPadding)"
                  y="@FormatCoord(baseLineY + 18)"
                  class="node-inspector-sparkline-label">@minLabel</text>
        </svg>
    </div>
}

@code {
    [Parameter, EditorRequired]
    public NodeSparklineData Data { get; set; } = default!;

    [Parameter]
    public int SelectedBin { get; set; }

    [Parameter]
    public string Stroke { get; set; } = "#CBD5E1";

    [Parameter]
    public string? AriaLabel { get; set; }

    [Parameter]
    public InspectorValueFormat ValueFormat { get; set; } = InspectorValueFormat.Number;

    [Parameter]
    public TopologyOverlaySettings? OverlaySettings { get; set; }

    [Parameter]
    public string? SeriesKey { get; set; }

    private const double SvgWidth = 360;
    private const double SvgHeight = 140;
    private const double LeftPadding = 28;
    private const double RightPadding = 28;
    private const double TopPadding = 18;
    private const double BottomPadding = 28;
    private const double TickHeight = 10;

    private readonly CultureInfo invariant = CultureInfo.InvariantCulture;
    private IReadOnlyList<PathSegment> pathSegments = Array.Empty<PathSegment>();
    private string minLabel = string.Empty;
    private string maxLabel = string.Empty;
    private string resolvedAriaLabel = "Node sparkline preview";
    private bool hasData;
    private bool hasHighlight;
    private double highlightX;
    private double highlightY;
    private string highlightColor = "#CBD5E1";
    private double baseLineY;
    private IReadOnlyList<double> tickPositions = Array.Empty<double>();

    protected override void OnParametersSet()
    {
        if (Data is null || Data.Values.Count == 0)
        {
            hasData = false;
            pathSegments = Array.Empty<PathSegment>();
            tickPositions = Array.Empty<double>();
            hasHighlight = false;
            resolvedAriaLabel = string.IsNullOrWhiteSpace(AriaLabel) ? "Node sparkline preview unavailable" : AriaLabel!;
            return;
        }

        var samples = new List<(int Index, double Value)>(Data.Values.Count);
        for (var i = 0; i < Data.Values.Count; i++)
        {
            var sample = Data.Values[i];
            if (sample.HasValue && double.IsFinite(sample.Value))
            {
                samples.Add((i, sample.Value));
            }
        }

        if (samples.Count == 0)
        {
            hasData = false;
            pathSegments = Array.Empty<PathSegment>();
            tickPositions = Array.Empty<double>();
            hasHighlight = false;
            resolvedAriaLabel = string.IsNullOrWhiteSpace(AriaLabel) ? "Node sparkline preview unavailable" : AriaLabel!;
            return;
        }

        hasData = true;
        highlightColor = Stroke;
        resolvedAriaLabel = string.IsNullOrWhiteSpace(AriaLabel) ? "Node sparkline preview" : AriaLabel!;

        var actualMin = samples.Min(s => s.Value);
        var actualMax = samples.Max(s => s.Value);
        minLabel = FormatSample(actualMin);
        maxLabel = FormatSample(actualMax);

        var scaleMin = Data.Min;
        var scaleMax = Data.Max;
        if (!double.IsFinite(scaleMin)) scaleMin = actualMin;
        if (!double.IsFinite(scaleMax)) scaleMax = actualMax;
        scaleMin = Math.Min(scaleMin, 0d);
        scaleMax = Math.Max(scaleMax, 0d);
        if (Math.Abs(scaleMax - scaleMin) < 1e-9)
        {
            scaleMax = scaleMin + 0.001d;
        }

        var plotWidth = SvgWidth - LeftPadding - RightPadding;
        var plotHeight = SvgHeight - TopPadding - BottomPadding;
        var zeroFraction = (0d - scaleMin) / (scaleMax - scaleMin);
        zeroFraction = double.IsFinite(zeroFraction) ? Math.Clamp(zeroFraction, 0d, 1d) : 0d;
        baseLineY = TopPadding + (1 - zeroFraction) * plotHeight;

        var segments = new List<PathSegmentBuilder>();
        PathSegmentBuilder? currentSegment = null;
        var movePending = true;
        var count = Data.Values.Count;
        double previousX = 0;
        double previousY = 0;
        string previousColor = Stroke;
        var thresholds = OverlaySettings is not null
            ? ColorScale.ColorThresholds.FromOverlay(OverlaySettings)
            : ColorScale.ColorThresholds.Default;
        var basis = ResolveBasisFromSeries();

        for (var i = 0; i < count; i++)
        {
            var sample = Data.Values[i];
            if (!sample.HasValue || !double.IsFinite(sample.Value))
            {
                movePending = true;
                continue;
            }

            var xFraction = count <= 1 ? 0d : (double)i / (count - 1);
            var yFraction = (sample.Value - scaleMin) / (scaleMax - scaleMin);

            var x = LeftPadding + xFraction * plotWidth;
            var y = TopPadding + (1 - yFraction) * plotHeight;
            var segmentColor = ResolveSampleColor(sample.Value, basis, thresholds);

            if (movePending)
            {
                currentSegment = new PathSegmentBuilder(segmentColor, Stroke);
                segments.Add(currentSegment);
                currentSegment.Builder.Append('M');
                currentSegment.Builder.Append(FormatCoord(x));
                currentSegment.Builder.Append(' ');
                currentSegment.Builder.Append(FormatCoord(y));
                movePending = false;
            }
            else
            {
                if (currentSegment is null || !segmentColor.Equals(previousColor, StringComparison.OrdinalIgnoreCase))
                {
                    currentSegment = new PathSegmentBuilder(segmentColor, Stroke);
                    segments.Add(currentSegment);
                    currentSegment.Builder.Append('M');
                    currentSegment.Builder.Append(FormatCoord(previousX));
                    currentSegment.Builder.Append(' ');
                    currentSegment.Builder.Append(FormatCoord(previousY));
                }

                currentSegment.Builder.Append('L');
                currentSegment.Builder.Append(FormatCoord(x));
                currentSegment.Builder.Append(' ');
                currentSegment.Builder.Append(FormatCoord(y));
            }

            previousX = x;
            previousY = y;
            previousColor = currentSegment?.Color ?? Stroke;
        }

        pathSegments = segments.Count > 0
            ? segments.ConvertAll(segment => new PathSegment(segment.Builder.ToString(), segment.Color))
            : Array.Empty<PathSegment>();

        var highlightIndex = SelectedBin - Data.StartIndex;
        if (highlightIndex >= 0 && highlightIndex < count)
        {
            var highlightValue = Data.Values[highlightIndex];
            if (highlightValue.HasValue && double.IsFinite(highlightValue.Value))
            {
                var xFraction = count <= 1 ? 0d : (double)highlightIndex / (count - 1);
                var yFraction = (highlightValue.Value - scaleMin) / (scaleMax - scaleMin);
                highlightX = LeftPadding + xFraction * plotWidth;
                highlightY = TopPadding + (1 - yFraction) * plotHeight;
                highlightColor = ResolveSampleColor(highlightValue.Value, basis, thresholds);
                hasHighlight = true;
            }
            else
            {
                hasHighlight = false;
            }
        }
        else
        {
            hasHighlight = false;
        }

        var ticks = new List<double>(5);
        const int desiredTicks = 4;
        for (var i = 0; i <= desiredTicks; i++)
        {
            var fraction = desiredTicks == 0 ? 0d : i / (double)desiredTicks;
            var x = LeftPadding + fraction * plotWidth;
            ticks.Add(x);
        }

        tickPositions = ticks;
    }

    private string FormatSample(double value)
    {
        if (ValueFormat == InspectorValueFormat.Percent)
        {
            var percent = value * 100d;
            var absPercent = Math.Abs(percent);
            var format = absPercent < 1 ? "0.0#" : "0";
            return percent.ToString(format, invariant) + "%";
        }

        var abs = Math.Abs(value);
        if (abs >= 1000 || (abs > 0 && abs < 0.01))
        {
            return value.ToString("0.###E+0", invariant);
        }

        return value.ToString(abs >= 100 ? "0" : "0.###", invariant);
    }

    private string FormatCoord(double value) => value.ToString("0.###", invariant);

    private TopologyColorBasis? ResolveBasisFromSeries()
    {
        if (string.IsNullOrWhiteSpace(SeriesKey))
        {
            return null;
        }

        return SeriesKey.Trim().ToLowerInvariant() switch
        {
            "successrate" => TopologyColorBasis.Sla,
            "utilization" => TopologyColorBasis.Utilization,
            "errorrate" or "errors" => TopologyColorBasis.Errors,
            "queue" or "queuedepth" => TopologyColorBasis.Queue,
            _ => null
        };
    }

    private string ResolveSampleColor(double value, TopologyColorBasis? basis, ColorScale.ColorThresholds thresholds)
    {
        if (!basis.HasValue)
        {
            return Stroke;
        }

        var metrics = basis.Value switch
        {
            TopologyColorBasis.Utilization => new NodeBinMetrics(null, value, null, null, null, null),
            TopologyColorBasis.Errors => new NodeBinMetrics(null, null, value, null, null, null),
            TopologyColorBasis.Queue => new NodeBinMetrics(null, null, null, value, null, null),
            _ => new NodeBinMetrics(value, null, null, null, null, null)
        };

        var color = ColorScale.GetFill(metrics, basis.Value, thresholds);
        if (string.IsNullOrWhiteSpace(color) || string.Equals(color, ColorScale.NeutralColor, StringComparison.OrdinalIgnoreCase))
        {
            return Stroke;
        }

        return color;
    }

    private sealed record PathSegment(string Path, string Color);

    private sealed class PathSegmentBuilder
    {
        public PathSegmentBuilder(string color, string defaultColor)
        {
            Color = string.IsNullOrWhiteSpace(color) ? defaultColor : color;
            Builder = new StringBuilder();
        }

        public StringBuilder Builder { get; }

        public string Color { get; }
    }
}

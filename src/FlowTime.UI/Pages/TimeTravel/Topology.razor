@page "/time-travel/topology"
@using MudBlazor
@using Microsoft.JSInterop
@using Microsoft.Extensions.Logging
@using FlowTime.UI.Components.Topology
@using FlowTime.UI.Services
@using System.Collections.Generic
@using System.Globalization
@using System.Linq
@using System.Text.Json
@using System.Threading
@inject ITimeTravelDataService DataService
@inject NavigationManager Navigation
@inject IJSRuntime JS
@inject ILogger<Topology> Logger
@implements IDisposable

<PageTitle>Time-Travel Topology</PageTitle>

<MudStack Row="true" Class="topology-layout" AlignItems="@AlignItems.Stretch" Spacing="2">
    @if (featureBarOpen)
    {
        <MudPaper Class="topology-feature-panel" Elevation="1">
            <TopologyFeatureBar Settings="overlaySettings"
                                 SettingsChanged="OnOverlaySettingsChanged"
                                 CloseRequested="CloseFeatureBar"
                                 ExpandedSections="sectionExpansionState"
                                 SectionExpansionChanged="OnFeatureSectionExpansionChanged" />
        </MudPaper>
    }

        <MudPaper Class="topology-page" Elevation="1">
        <MudStack Spacing="3" Class="topology-content">
            @if (string.IsNullOrWhiteSpace(RunId))
            {
                <MudAlert Severity="Severity.Info">
                    Select a run from the Artifacts list to inspect its topology.
                </MudAlert>
            }
            else if (!string.IsNullOrWhiteSpace(errorMessage))
            {
                <MudAlert Severity="Severity.Error" Variant="Variant.Outlined">
                    <MudText Typo="Typo.body1">@errorMessage</MudText>
                </MudAlert>
            }
            else if (isLoading)
            {
                <MudPaper Class="pa-6 d-flex flex-column align-center justify-center" Elevation="0">
                    <MudProgressCircular Color="Color.Primary" Indeterminate="true" Style="width: 64px; height: 64px;" />
                    <MudText Typo="Typo.caption" Class="mt-2">Loading topologyâ€¦</MudText>
                </MudPaper>
            }
            else if (topologyGraph is null)
            {
                <MudAlert Severity="Severity.Warning">
                    Topology data was not available for run <strong>@RunId</strong>.
                </MudAlert>
            }
            else
            {
                <MudStack Spacing="2" Class="topology-main-stack">
                    <MudPaper Class="pa-3 timeline-paper" Elevation="0">
                        <MudStack Spacing="1" Class="topology-header">
                            @{ var runInfo = GetRunInfo(); }
                            <MudStack Row="true" AlignItems="@AlignItems.Center" Justify="@Justify.SpaceBetween">
                                <MudText Typo="Typo.caption">@selectedTimestampLabel</MudText>
                                <MudStack Row="true" AlignItems="@AlignItems.Center" Justify="@Justify.FlexEnd" Spacing="1">
                                    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="topology-run-id">Run @RunId</MudText>
                                    @if (!string.IsNullOrWhiteSpace(runInfo))
                                    {
                                        <MudText Typo="Typo.caption" Class="topology-run-info" Color="Color.Info">@runInfo</MudText>
                                    }
                                </MudStack>
                            </MudStack>
                            <div class="timeline-dial">
                                <div class="timeline-track @(visibleStartBin == visibleEndBin ? "is-disabled" : string.Empty)">
                                    <svg class="timeline-svg" viewBox="0 0 100 12" preserveAspectRatio="none">
                                        <rect class="timeline-track-bg" x="0" y="4" width="100" height="4" />
                                        @foreach (var minor in timelineMinorTicks)
                                        {
                                            <line class="timeline-tick-line timeline-tick-line--minor"
                                                  x1="@minor.ToString("0.###", CultureInfo.InvariantCulture)"
                                                  x2="@minor.ToString("0.###", CultureInfo.InvariantCulture)"
                                                  y1="3"
                                                  y2="9" />
                                        }
                                        @foreach (var tick in timelineTicks)
                                        {
                                            <line class="timeline-tick-line"
                                                  x1="@tick.Percent.ToString("0.###", CultureInfo.InvariantCulture)"
                                                  x2="@tick.Percent.ToString("0.###", CultureInfo.InvariantCulture)"
                                                  y1="1"
                                                  y2="11" />
                                        }
                                    </svg>
                                    @{
                                        var totalSpan = Math.Max(1, visibleEndBin - visibleStartBin);
                                        var winStart = Math.Max(visibleStartBin, selectedBin - SparklinePointLimit + 1);
                                        var winEnd = Math.Max(winStart, Math.Min(selectedBin, visibleEndBin));
                                        var xPct = Math.Clamp((winStart - visibleStartBin) * 100.0 / totalSpan, 0.0, 100.0);
                                        var rawWidth = (winEnd - winStart + 1) * 100.0 / totalSpan;
                                        var maxWidth = Math.Max(0.0, 100.0 - xPct);
                                        var wPct = Math.Clamp(rawWidth, 0.0, maxWidth);
                                    }
                                    <div class="timeline-window" style="left: @xPct.ToString("0.###", CultureInfo.InvariantCulture)%; width: @wPct.ToString("0.###", CultureInfo.InvariantCulture)%;"></div>
                                    <div class="timeline-pointer @(isDialPointerDragging ? "is-dragging" : string.Empty)"
                                         style="left: @DialPercent.ToString("0.###", CultureInfo.InvariantCulture)%; --timeline-transition-duration: @PointerTransitionDuration;"></div>
                                    <input class="timeline-range"
                                           type="range"
                                           min="@visibleStartBin"
                                           max="@visibleEndBin"
                                           step="1"
                                           value="@selectedBin"
                                           disabled="@(visibleStartBin == visibleEndBin)"
                                           @oninput="OnDialInput"
                                           @onpointerdown="StartDialDrag"
                                           @onpointerup="EndDialDrag"
                                           @onpointercancel="EndDialDrag"
                                           @onpointerleave="EndDialDrag" />
                                </div>
                                <div class="timeline-labels">
                                    @foreach (var tick in timelineTicks)
                                    {
                                        <span class="timeline-label" style="left:@tick.Percent.ToString("0.###", CultureInfo.InvariantCulture)%">@tick.Label</span>
                                    }
                                </div>
                                <div class="timeline-controls">
                                    <MudIconButton Icon="@(isPlaying ? Icons.Material.Filled.Pause : Icons.Material.Filled.PlayArrow)"
                                                   Color="Color.Primary"
                                                   Size="Size.Small"
                                                   Disabled="@(visibleStartBin == visibleEndBin)"
                                                   OnClick="TogglePlaybackAsync" />
                                    <MudIconButton Icon="@Icons.Material.Filled.SkipPrevious"
                                                   Size="Size.Small"
                                                   Disabled="@(selectedBin <= visibleStartBin)"
                                                   OnClick="GoToPreviousBin" />
                                    <MudIconButton Icon="@Icons.Material.Filled.SkipNext"
                                                   Size="Size.Small"
                                                   Disabled="@(selectedBin >= visibleEndBin)"
                                                   OnClick="GoToNextBin" />
                                    <MudIconButton Icon="@Icons.Material.Filled.Loop"
                                                   Size="Size.Small"
                                                   Color="@(loopPlayback ? Color.Primary : Color.Default)"
                                                   OnClick="ToggleLoop" />
                                    <MudChipSet T="double"
                                                SelectedValue="@playbackSpeedFactor"
                                                SelectedValueChanged="OnPlaybackSpeedChipChanged"
                                                Class="timeline-speed-set"
                                                Ripple="false">
                                        @foreach (var option in PlaybackSpeedOptions)
                                        {
                                            <MudChip T="double"
                                                     Value="@option.Factor"
                                                     Variant="Variant.Outlined"
                                                     Color="Color.Default"
                                                     Size="Size.Small"
                                                     Class="timeline-speed-chip">
                                                @option.Label
                                            </MudChip>
                                        }
                                    </MudChipSet>
                                    <MudStack Row="true" AlignItems="@AlignItems.Center" Class="timeline-focus-group">
                                        @if (HasWindowWarnings)
                                        {
                                            <MudTooltip RootClass="timeline-warning-tooltip-root">
                                                <ChildContent>
                                                    <MudChip T="string"
                                                             Variant="Variant.Filled"
                                                             Class="timeline-warning-chip"
                                                             Color="Color.Warning"
                                                             Ripple="false">
                                                        Warning
                                                    </MudChip>
                                                </ChildContent>
                                                <TooltipContent>
                                                    <div class="timeline-warning-tooltip">
                                                        @foreach (var warning in windowWarnings)
                                                        {
                                                            <div class="timeline-warning-tooltip__item">
                                                                <div class="timeline-warning-tooltip__heading">
                                                                    <strong>@(warning.NodeId ?? "Run")</strong>
                                                                    <span class="timeline-warning-tooltip__code">@warning.Code</span>
                                                                </div>
                                                                @if (!string.IsNullOrWhiteSpace(warning.Message))
                                                                {
                                                                    <span>@warning.Message</span>
                                                                }
                                                            </div>
                                                        }
                                                    </div>
                                                </TooltipContent>
                                            </MudTooltip>
                                        }
                                        <MudStack Row="true" AlignItems="@AlignItems.Center" Spacing="1" Class="timeline-focus-controls">
                                            <MudText Typo="Typo.caption" Class="timeline-focus-label">Focus</MudText>
                                            <MudChipSet T="TopologyColorBasis"
                                                        SelectedValue="@overlaySettings.ColorBasis"
                                                        SelectedValueChanged="OnFocusMetricChanged"
                                                        Class="timeline-focus-set"
                                                        Ripple="false">
                                                <MudChip T="TopologyColorBasis"
                                                         Value="TopologyColorBasis.Sla"
                                                         Variant="Variant.Outlined"
                                                         Size="Size.Small"
                                                         Class="timeline-focus-chip">
                                                    SLA
                                                </MudChip>
                                                <MudChip T="TopologyColorBasis"
                                                         Value="TopologyColorBasis.Utilization"
                                                         Variant="Variant.Outlined"
                                                         Size="Size.Small"
                                                         Class="timeline-focus-chip">
                                                    Utilization
                                                </MudChip>
                                                <MudChip T="TopologyColorBasis"
                                                         Value="TopologyColorBasis.Errors"
                                                         Variant="Variant.Outlined"
                                                         Size="Size.Small"
                                                         Class="timeline-focus-chip">
                                                    Error rate
                                                </MudChip>
                                                <MudChip T="TopologyColorBasis"
                                                         Value="TopologyColorBasis.ServiceTime"
                                                         Variant="Variant.Outlined"
                                                         Size="Size.Small"
                                                         Class="timeline-focus-chip">
                                                    Service time
                                                </MudChip>
                                            </MudChipSet>
                                        </MudStack>
                                        <MudStack Row="true" AlignItems="@AlignItems.Center" Spacing="1" Class="timeline-operational-toggle">
                                            <MudText Typo="Typo.caption" Class="timeline-focus-label">Operational</MudText>
                                            <MudSwitch T="bool"
                                                       Size="Size.Small"
                                                       Ripple="false"
                                                       Value="@operationalViewOnly"
                                                       ValueChanged="OnOperationalViewChanged"
                                                       Disabled="@operationalTogglePending"
                                                       Color="Color.Primary" />
                                        </MudStack>
                                        <MudChipSet T="string"
                                                    Class="timeline-zoom-set"
                                                    Ripple="false">
                                            <MudTooltip Text="Reset zoom">
                                                <MudChip T="string"
                                                         Value="@("Reset")"
                                                         Variant="Variant.Outlined"
                                                         Color="Color.Default"
                                                         Size="Size.Small"
                                                         Class="timeline-zoom-chip"
                                                         OnClick="ResetZoom">
                                                    100%
                                                </MudChip>
                                            </MudTooltip>
                                            <MudTooltip Text="Fit graph to canvas">
                                                <MudChip T="string"
                                                         Value="@("Fit")"
                                                         Variant="Variant.Outlined"
                                                         Color="Color.Default"
                                                         Size="Size.Small"
                                                         Class="timeline-zoom-chip"
                                                         OnClick="FitViewport">
                                                    Fit
                                                </MudChip>
                                            </MudTooltip>
                                        </MudChipSet>
                                    </MudStack>
                                </div>
                            </div>
                        </MudStack>
                    </MudPaper>

                    <MudStack Row="true" AlignItems="AlignItems.Stretch" Spacing="2" Class="topology-stage">
                        <div class="topology-canvas-region">
                            <TopologyCanvas @ref="canvasComponent"
                                            Graph="topologyGraph"
                                            NodeMetrics="activeMetrics"
                                            NodeSparklines="nodeSparklines"
                                            NodeWarnings="nodeWarningsForCanvas"
                                            OverlaySettings="overlaySettings"
                                            ActiveBin="selectedBin"
                                            Title="@GetTemplateTitle()"
                                            SettingsRequested="OpenFeatureBar"
                                            ZoomPercentChanged="HandleCanvasZoomChanged"
                                            ViewportChanged="OnCanvasViewportChanged"
                                            InspectorVisible="inspectorOpen"
                                            NodeFocused="OnNodeFocused"
                                            EdgeHovered="OnCanvasEdgeHovered"
                                            RequestedViewport="pendingViewportSnapshot"
                                            ViewportRequestConsumed="OnRequestedViewportConsumed" />
                        </div>

                        @if (inspectorOpen && inspectorNodeId is not null)
                        {
                            var nodeId = inspectorNodeId;
        activeMetrics.TryGetValue(nodeId, out var nodeMetricsSnapshot);
        var binMetrics = BuildInspectorBinMetrics(nodeId, nodeMetricsSnapshot);
        var metricBlocks = BuildInspectorMetricBlocks(nodeId);
                            var metricsHaveSeries = metricBlocks.Any(block => !block.IsPlaceholder);
                            var hasSparklineSeries = metricBlocks.Any(block => !block.IsPlaceholder && block.Sparkline is not null);
                            var topoNodeInfo = FindTopologyNode(nodeId);
                            var nodeKind = topoNodeInfo?.Kind;
                            var expressionText = topoNodeInfo?.Semantics?.Expression;
                            var hasExpressionText = !string.IsNullOrWhiteSpace(expressionText);
                            var showExpressionSection = IsExpressionKind(nodeKind);
                            var isComputedNode = IsComputedKind(nodeKind);
                            var dependencyRows = BuildInspectorDependencies(nodeId);

                            <MudPaper Class="topology-inspector topology-inspector-panel" Elevation="1" Style="width: 360px; flex: 0 0 360px;">
                                <MudStack Class="pa-4" Spacing="2">
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                        <MudText Typo="Typo.h6" Class="topology-inspector-title">@nodeId</MudText>
                                        <MudIconButton Icon="@Icons.Material.Filled.Close"
                                                       Color="Color.Secondary"
                                                       Size="Size.Small"
                                                       OnClick="CloseInspector" />
                                    </MudStack>
                                    <MudText Typo="Typo.caption" Class="topology-muted-text">Kind: @FormatNodeKindLabel(nodeKind)</MudText>

                                    @{
                                        var metrics = nodeMetricsSnapshot;
                                        var summaryRendered = false;
                                    }
                                    @if (metrics is not null)
                                    {
                                        <MudStack Spacing="1">
                                            @{
                                                var profileName = GetMetadataValue(metrics.Metadata, "profile.name");
                                                if (!string.IsNullOrWhiteSpace(profileName) &&
                                                    string.Equals(metrics.NodeKind, "pmf", StringComparison.OrdinalIgnoreCase))
                                                {
                                                    summaryRendered = true;
                                                    <MudText Typo="Typo.body2">Profile: @profileName</MudText>
                                                }
                                            }
                                            @if (!isComputedNode && metrics.SuccessRate.HasValue)
                                            {
                                                summaryRendered = true;
                                                <MudText Typo="Typo.body2">Success: @FormatPercent(metrics.SuccessRate)</MudText>
                                            }
                                            @if (!isComputedNode && metrics.Utilization.HasValue)
                                            {
                                                summaryRendered = true;
                                                <MudText Typo="Typo.body2">Utilization: @FormatPercent(metrics.Utilization)</MudText>
                                            }
                                            @if (!isComputedNode && metrics.ErrorRate.HasValue)
                                            {
                                                summaryRendered = true;
                                                <MudText Typo="Typo.body2">Errors: @FormatPercent(metrics.ErrorRate)</MudText>
                                            }
                                            @if (!isComputedNode && metrics.QueueDepth.HasValue)
                                            {
                                                summaryRendered = true;
                                                <MudText Typo="Typo.body2">Queue: @FormatNumber(metrics.QueueDepth)</MudText>
                                            }
                                            @if (!isComputedNode && metrics.LatencyMinutes.HasValue)
                                            {
                                                summaryRendered = true;
                                                <MudText Typo="Typo.body2">Latency (min): @FormatNumber(metrics.LatencyMinutes)</MudText>
                                            }
                                            @if (metrics.CustomValue.HasValue)
                                            {
                                                var label = string.IsNullOrWhiteSpace(metrics.CustomLabel) ? "Value" : metrics.CustomLabel!;
                                                summaryRendered = true;
                                                <MudText Typo="Typo.body2">@label: @FormatNumber(metrics.CustomValue)</MudText>
                                            }
                                            else if (!string.IsNullOrWhiteSpace(metrics.CustomLabel) &&
                                                     string.Equals(metrics.CustomLabel, MissingSeriesMessage, System.StringComparison.Ordinal))
                                            {
                                                summaryRendered = true;
                                                <MudText Typo="Typo.body2" Class="topology-muted-text">@metrics.CustomLabel</MudText>
                                            }
                                        </MudStack>
                                        @if (!summaryRendered && !metricsHaveSeries && !isComputedNode)
                                        {
                                            <MudText Typo="Typo.body2">Metrics unavailable.</MudText>
                                        }
                                    }
                                    else if (!isComputedNode && !metricsHaveSeries)
                                    {
                                        <MudText Typo="Typo.body2">Metrics unavailable.</MudText>
                                    }

                                    @if (binMetrics.Count > 0)
                                    {
                                        <MudTable T="InspectorBinMetric" Dense="true" Elevation="0" Class="node-inspector-bin-table">
                                            <HeaderContent>
                                                <MudTh>Metric</MudTh>
                                                <MudTh Style="text-align:right;">Value</MudTh>
                                            </HeaderContent>
                                            <RowTemplate Context="row">
                                                <MudTd>@row.Label</MudTd>
                                                <MudTd Style="text-align:right;">@row.Value</MudTd>
                                            </RowTemplate>
                                        </MudTable>
                                    }

                                    @if (showExpressionSection)
                                    {
                                        <MudStack Spacing="1">
                                            <MudText Typo="Typo.subtitle2">Expression</MudText>
                                            @if (hasExpressionText)
                                            {
                                                <pre class="node-inspector-expression">@expressionText</pre>
                                            }
                                            else
                                            {
                                                <MudText Typo="Typo.caption" Class="topology-muted-text">Expression unavailable.</MudText>
                                            }
                                        </MudStack>
                                    }

                                    @if (hasSparklineSeries)
                                    {
                                        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                            <MudText Typo="Typo.subtitle2">Metric charts</MudText>
                                            <MudChip T="bool"
                                                     Variant="Variant.Outlined"
                                                     Size="Size.Small"
                                                     Color="Color.Primary"
                                                     Selected="@inspectorMetricsExpanded"
                                                     OnClick="ToggleInspectorMetricsExpanded">
                                                @(inspectorMetricsExpanded ? "Collapse" : "Expand")
                                            </MudChip>
                                        </MudStack>
                                    }

                                    @foreach (var block in metricBlocks)
                                    {
                                        <MudStack Spacing="1">
                                            @if (inspectorMetricsExpanded)
                                            {
                                                <MudText Typo="Typo.subtitle2">@block.Title</MudText>
                                            }
                                            @if (block.Sparkline is not null)
                                            {
                                                if (inspectorMetricsExpanded)
                                                {
                                                    <TopologyInspectorSparkline Data="@block.Sparkline"
                                                                                 SelectedBin="@selectedBin"
                                                                                 Stroke="@block.Stroke"
                                                                                 AriaLabel="@block.AriaLabel"
                                                                                 ValueFormat="@block.ValueFormat"
                                                                                 OverlaySettings="overlaySettings"
                                                                                 SeriesKey="@block.SeriesKey" />
                                                }

                                                var (hData, hMin, hMax, hStart, hEnd) = ResolveHorizonSeries(inspectorNodeId!, block.SeriesKey, block.Sparkline);
                                                var horizonMin = overlaySettings.NormalizeInspectorHorizonCounts ? 0d : hMin;
                                                var horizonMax = overlaySettings.NormalizeInspectorHorizonCounts
                                                    ? (overlaySettings.InspectorHorizonGlobalCap ?? hMax)
                                                    : hMax;

                                                @if (hData is not null && hData.Length > 0)
                                                {
                                                    <MudStack Spacing="0" Class="topology-horizon-wrapper">
                                                        @if (!inspectorMetricsExpanded)
                                                        {
                                                            <MudText Typo="Typo.caption"
                                                                     Class="topology-muted-text topology-horizon-label">@block.Title</MudText>
                                                        }
                                                        <TopologyHorizonChart Data="@hData"
                                                                              Min="@horizonMin"
                                                                              Max="@horizonMax"
                                                                              Bands="@overlaySettings.HorizonBands"
                                                                              Height="24"
                                                                              NormalizeAcrossNodes="@overlaySettings.NormalizeInspectorHorizonCounts"
                                                                              GlobalCap="@overlaySettings.InspectorHorizonGlobalCap"
                                                                              OverlaySettings="overlaySettings"
                                                                              SeriesKey="@block.SeriesKey"
                                                                              HighlightStartIndex="@hStart"
                                                                              HighlightEndIndex="@hEnd"
                                                                              AriaLabel="@(block.AriaLabel is null ? null : $"{block.AriaLabel} horizon overview")" />
                                                    </MudStack>
                                                }
                                                else
                                                {
                                                    <MudStack Spacing="0" Class="topology-horizon-wrapper">
                                                        @if (!inspectorMetricsExpanded)
                                                        {
                                                            <MudText Typo="Typo.caption"
                                                                     Class="topology-muted-text topology-horizon-label">@block.Title</MudText>
                                                        }
                                                        <div class="topology-horizon-empty"
                                                             role="img"
                                                             aria-label="@BuildHorizonEmptyLabel(block.AriaLabel, block.Placeholder)">
                                                            <span>No data</span>
                                                        </div>
                                                    </MudStack>
                                                }
                                            }
                                            else
                                            {
                                                <MudStack Spacing="0" Class="topology-horizon-wrapper">
                                                    @if (!inspectorMetricsExpanded)
                                                    {
                                                        <MudText Typo="Typo.caption"
                                                                 Class="topology-muted-text topology-horizon-label">@block.Title</MudText>
                                                    }
                                                    <div class="topology-horizon-empty"
                                                         role="img"
                                                         aria-label="@BuildHorizonEmptyLabel(block.AriaLabel, block.Placeholder)">
                                                        <span>No data</span>
                                                    </div>
                                                </MudStack>
                                            }
                                        </MudStack>
                                    }
                                </MudStack>
                                <MudDivider Class="my-2" />
                                <MudStack Spacing="1">
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                                        <MudText Typo="Typo.subtitle2">Dependencies</MudText>
                                        @if (dependencyRows.Count > 0)
                                        {
                                            <MudText Typo="Typo.caption" Class="topology-muted-text">@($"{dependencyRows.Count}")</MudText>
                                        }
                                    </MudStack>
                                    @if (dependencyRows.Count == 0)
                                    {
                                        <MudText Typo="Typo.caption" Class="topology-muted-text">No dependencies</MudText>
                                    }
                                    else
                                    {
                                        <div class="topology-inspector-dependencies">
                                            @foreach (var dependency in dependencyRows)
                                            {
                                                var highlighted = IsDependencyHighlighted(dependency.EdgeId);
                                                <button type="button"
                                                        class="inspector-dependency-row"
                                                        data-highlighted="@(highlighted ? "true" : "false")"
                                                        @onmouseenter="() => OnInspectorDependencyHover(dependency.EdgeId)"
                                                        @onmouseleave="() => OnInspectorDependencyHover(null)"
                                                        @onclick="() => OnInspectorDependencyClick(dependency.EdgeId)">
                                                    <div class="inspector-dependency-row__meta">
                                                        <MudText Typo="Typo.body2">@dependency.Label</MudText>
                                                        <MudText Typo="Typo.caption" Class="topology-muted-text">@dependency.Source</MudText>
                                                    </div>
                                                </button>
                                            }
                                        </div>
                                    }
                                </MudStack>
                            </MudPaper>
                        }
                    </MudStack>

                </MudStack>
            }
        </MudStack>
    </MudPaper>
</MudStack>

@code {
    [Parameter, SupplyParameterFromQuery(Name = "runId")]
    public string? RunId { get; set; }

    private string? currentRunId;
    private string? runDisplayName;
    private string? errorMessage;
    private bool isLoading;
    private bool hasLoaded;
    private CancellationTokenSource? loadCts;
    private CancellationTokenSource? windowReloadCts;
    private TopologyCanvas? canvasComponent;

    private bool featureBarOpen = false;
    private TopologyOverlaySettings overlaySettings = TopologyOverlaySettings.Default.Clone();
    private Dictionary<TopologyFeatureSection, bool> sectionExpansionState = CreateDefaultSectionState();
    private ViewportSnapshot? currentViewportSnapshot;
    private ViewportSnapshot? pendingViewportSnapshot;
    private bool isRestoringViewport;
    private bool attemptedRestore;
    private DotNetObjectReference<Topology>? selfReference;
    private int? hotkeyRegistrationId;
private string? inspectorNodeId;
private bool inspectorOpen;
private bool inspectorPinned;
private bool inspectorMetricsExpanded;
private string? inspectorHoveredEdgeId;
private string? inspectorPinnedEdgeId;
private string? canvasHoveredEdgeId;
    private CancellationTokenSource? saveRunStateDebounceCts;

    private TopologyGraph? topologyGraph;
    private IReadOnlyDictionary<string, NodeBinMetrics> activeMetrics = new Dictionary<string, NodeBinMetrics>(StringComparer.OrdinalIgnoreCase);
    private IReadOnlyDictionary<string, NodeSparklineData> nodeSparklines = new Dictionary<string, NodeSparklineData>(StringComparer.OrdinalIgnoreCase);
    private HashSet<string> nodesMissingSparkline = new(StringComparer.OrdinalIgnoreCase);
    private readonly HashSet<string> loggedMissingExpressionSeries = new(StringComparer.OrdinalIgnoreCase);
    private readonly HashSet<string> loggedMissingMetricKinds = new(StringComparer.OrdinalIgnoreCase);
    private TimeTravelStateWindowDto? windowData;
    private SeriesIndex? seriesIndex;
    private IReadOnlyList<DateTimeOffset> timestamps = Array.Empty<DateTimeOffset>();

    private int selectedBin;
    private int visibleStartBin;
    private int visibleEndBin;
    private int? restoredSelectedBin;
    private string selectedBinLabel = string.Empty;
    private string selectedTimestampLabel = string.Empty;
    private IReadOnlyList<TimelineTick> timelineTicks = Array.Empty<TimelineTick>();
    private IReadOnlyList<double> timelineMinorTicks = Array.Empty<double>();
    private IReadOnlyList<TimeTravelStateWarningDto> windowWarnings = Array.Empty<TimeTravelStateWarningDto>();
    private IReadOnlyDictionary<string, IReadOnlyList<NodeWarningPayload>> nodeWarningsForCanvas = EmptyNodeWarnings;
    private static readonly IReadOnlyDictionary<string, IReadOnlyList<NodeWarningPayload>> EmptyNodeWarnings = new Dictionary<string, IReadOnlyList<NodeWarningPayload>>(StringComparer.OrdinalIgnoreCase);
    private bool HasWindowWarnings => windowWarnings.Count > 0;
    private bool isPlaying;
    private bool loopPlayback;
    private double playbackSecondsPerFrame = 1d;
    private double playbackSpeedFactor = 1d;
    private CancellationTokenSource? playbackCts;
    private Task playbackTask = Task.CompletedTask;
    private bool isDialPointerDragging;
    private bool pointerNeedsJump;
    private bool operationalViewOnly;
    private bool operationalTogglePending;
    private bool? savedIncludeExpressionNodes;
    private bool? savedIncludeConstNodes;
    private bool? savedEnableFullDag;

    private const double MinPlaybackDelay = 0.02d;
    private const double MaxPlaybackDelay = 120d;
    private const double BasePlaybackTotalSeconds = 30d;
    private static readonly double[] PlaybackSpeedFactors = new[] { 1d, 2d, 4d, 8d };
    private sealed record PlaybackSpeedOption(double Factor, double Seconds, string Label);
    private List<PlaybackSpeedOption> playbackSpeedOptions = new();
    private IReadOnlyList<PlaybackSpeedOption> PlaybackSpeedOptions => playbackSpeedOptions;

    private sealed record TimelineTick(int Bin, double Percent, string Label);
    internal sealed record InspectorDependencyViewModel(string EdgeId, string Label, string Source, int Order);

    private double DialPercent
    {
        get
        {
            if (visibleEndBin <= visibleStartBin)
            {
                return 0d;
            }

            var fraction = (selectedBin - visibleStartBin) / (double)(visibleEndBin - visibleStartBin);
            return Math.Clamp(fraction * 100d, 0d, 100d);
        }
    }

    private string PointerTransitionDuration =>
        (!isDialPointerDragging && isPlaying && !pointerNeedsJump)
            ? $"{Math.Max(playbackSecondsPerFrame, 0.01):0.###}s"
            : "0s";

    private static readonly JsonSerializerOptions overlaySerializerOptions = new(JsonSerializerDefaults.Web);
    private const string RunStateStoragePrefix = "ft.topology.state.v2";
    private const string LegacyOverlayStorageKey = "ft.topology.overlaySettings.v1";
    private const int SparklinePointLimit = 48;
    private const string MissingSeriesMessage = "No series for selected range.";
    internal const string InspectorMissingSeriesMessage = "Model does not include series data";
    private const string BinValueLabel = "bin(t)";
private const string PmfExpectationLabel = "Value";

    private static string BuildHorizonEmptyLabel(string? ariaLabel, string? placeholder = null)
    {
        var baseLabel = ariaLabel is null
            ? "Metric horizon chart has no data"
            : $"{ariaLabel} horizon chart has no data";

        if (string.IsNullOrWhiteSpace(placeholder))
        {
            return baseLabel;
        }

        return $"{baseLabel}. {placeholder}";
    }

    protected override async Task OnParametersSetAsync()
    {
        if (string.IsNullOrWhiteSpace(RunId))
        {
            if (!attemptedRestore)
            {
                attemptedRestore = true;
                var lastRunId = await JS.InvokeAsync<string?>("localStorage.getItem", LastRunStorageKey);
                if (!string.IsNullOrWhiteSpace(lastRunId))
                {
                    Navigation.NavigateTo($"/time-travel/topology?runId={Uri.EscapeDataString(lastRunId)}");
                    return;
                }
            }

            ResetState();
            return;
        }

        if (!string.Equals(RunId, currentRunId, StringComparison.OrdinalIgnoreCase))
        {
            ResetState();
            currentRunId = RunId;
            await EnsureHotkeysRegisteredAsync();
            await LoadRunStateAsync(currentRunId);
            await LoadAsync(currentRunId);
            return;
        }

        if (!hasLoaded && !isLoading && currentRunId is not null)
        {
            await LoadAsync(currentRunId);
        }
    }

    private async Task EnsureHotkeysRegisteredAsync()
    {
        if (selfReference is null)
        {
            selfReference = DotNetObjectReference.Create(this);
        }

        if (!hotkeyRegistrationId.HasValue)
        {
            try
            {
                hotkeyRegistrationId = await JS.InvokeAsync<int>("FlowTime.TopologyHotkeys.register", selfReference);
            }
            catch
            {
                hotkeyRegistrationId = null;
            }
        }
    }

    private async Task LoadRunStateAsync(string runId)
    {
        overlaySettings = TopologyOverlaySettings.Default.Clone();
        SyncOperationalViewFlagFromOverlay(resetSavedValues: true);
        sectionExpansionState = CreateDefaultSectionState();
        featureBarOpen = false;
        currentViewportSnapshot = null;
        pendingViewportSnapshot = null;

        try
        {
            var key = BuildRunStateKey(runId);
            var json = await JS.InvokeAsync<string?>("localStorage.getItem", key);
            if (string.IsNullOrWhiteSpace(json))
            {
                await LoadLegacyOverlayFallbackAsync();
                return;
            }

            var stored = JsonSerializer.Deserialize<StoredTopologyRunState>(json, overlaySerializerOptions);
            if (stored?.Overlay is not null)
            {
                overlaySettings = stored.Overlay.Clone();
                NormalizeOverlayFocusBasis();
                SyncOperationalViewFlagFromOverlay(resetSavedValues: true);
            }
            else
            {
                await LoadLegacyOverlayFallbackAsync();
            }

            if (stored?.Sections is { Count: > 0 })
            {
                var defaults = CreateDefaultSectionState();
                foreach (var pair in stored.Sections)
                {
                    if (Enum.TryParse<TopologyFeatureSection>(pair.Key, true, out var section))
                    {
                        defaults[section] = pair.Value;
                    }
                }
                sectionExpansionState = defaults;
            }
            else
            {
                sectionExpansionState = CreateDefaultSectionState();
            }

            featureBarOpen = stored?.FeatureBarOpen ?? false;
            restoredSelectedBin = stored?.SelectedBin;

            if (stored?.Viewport is not null)
            {
                currentViewportSnapshot = stored.Viewport.ToSnapshot();
                pendingViewportSnapshot = currentViewportSnapshot;
                isRestoringViewport = true;
                pointerNeedsJump = true;
            }
        }
        catch
        {
            await LoadLegacyOverlayFallbackAsync();
        }

        await SaveRunStateAsync();
    }

    private async Task LoadLegacyOverlayFallbackAsync()
    {
        try
        {
            var json = await JS.InvokeAsync<string?>("localStorage.getItem", LegacyOverlayStorageKey);
            if (string.IsNullOrWhiteSpace(json))
            {
                return;
            }

            var stored = JsonSerializer.Deserialize<TopologyOverlaySettings>(json, overlaySerializerOptions);
            if (stored is not null)
            {
                overlaySettings = stored.Clone();
                ApplyLegacyOverlayFields(json, overlaySettings);
                NormalizeOverlayFocusBasis();
                SyncOperationalViewFlagFromOverlay(resetSavedValues: true);
            }
        }
        catch
        {
            // Ignore storage failures
        }
    }

    private async Task SaveRunStateAsync()
    {
        if (string.IsNullOrWhiteSpace(currentRunId))
        {
            return;
        }

        saveRunStateDebounceCts?.Cancel();
        saveRunStateDebounceCts?.Dispose();
        saveRunStateDebounceCts = null;

        try
        {
            var state = new StoredTopologyRunState
            {
                Overlay = overlaySettings.Clone(),
                FeatureBarOpen = featureBarOpen,
                Sections = sectionExpansionState.ToDictionary(
                    pair => pair.Key.ToString(),
                    pair => pair.Value,
                    StringComparer.Ordinal)
            };

            if (hasLoaded)
            {
                state.SelectedBin = selectedBin;
                state.VisibleStartBin = visibleStartBin;
                state.VisibleEndBin = visibleEndBin;
            }

            if (currentViewportSnapshot is not null)
            {
                state.Viewport = StoredViewportState.FromSnapshot(currentViewportSnapshot);
            }

            var json = JsonSerializer.Serialize(state, overlaySerializerOptions);
            await JS.InvokeVoidAsync("localStorage.setItem", BuildRunStateKey(currentRunId), json);
        }
        catch
        {
            // Ignore persistence errors
        }
    }

    private void NormalizeOverlayFocusBasis()
    {
        if (overlaySettings.ColorBasis == TopologyColorBasis.Queue)
        {
            overlaySettings.ColorBasis = TopologyColorBasis.Sla;
        }
    }

    private void SyncOperationalViewFlagFromOverlay(bool resetSavedValues = false)
    {
        var derivedOperational = !overlaySettings.EnableFullDag
            && !overlaySettings.IncludeExpressionNodes
            && !overlaySettings.IncludeConstNodes;

        operationalViewOnly = derivedOperational;

        if (resetSavedValues)
        {
            savedIncludeExpressionNodes = null;
            savedIncludeConstNodes = null;
            savedEnableFullDag = null;
            operationalTogglePending = false;
        }
    }

    private static Dictionary<TopologyFeatureSection, bool> CreateDefaultSectionState()
    {
        var result = new Dictionary<TopologyFeatureSection, bool>();
        foreach (var section in Enum.GetValues<TopologyFeatureSection>())
        {
            result[section] = true;
        }
        return result;
    }

    private static string BuildRunStateKey(string runId) => $"{RunStateStoragePrefix}:{runId}";

    private void ScheduleRunStateSave()
    {
        saveRunStateDebounceCts?.Cancel();
        saveRunStateDebounceCts?.Dispose();

        var cts = new CancellationTokenSource();
        saveRunStateDebounceCts = cts;
        var token = cts.Token;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(TimeSpan.FromMilliseconds(300), token);
                if (token.IsCancellationRequested)
                {
                    return;
                }

                await InvokeAsync(async () => await SaveRunStateAsync());
            }
            catch (TaskCanceledException)
            {
                // ignored
            }
            catch
            {
                // storage errors ignored
            }
        }, token);
    }

    private async Task LoadAsync(string runId)
    {
        loadCts?.Cancel();
        loadCts?.Dispose();
        loadCts = new CancellationTokenSource();

        isLoading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            var ct = loadCts.Token;

            Logger?.LogInformation("Topology load start for run {RunId}", runId);

            var graphTask = DataService.GetGraphAsync(runId, BuildGraphQueryOptions(), ct);
            var indexTask = DataService.GetSeriesIndexAsync(runId, ct);

            await Task.WhenAll(graphTask, indexTask);

            var graphResult = await graphTask;
            if (!graphResult.Success || graphResult.Value is null)
            {
                Logger?.LogWarning("Graph load failed for run {RunId}: {Error}", runId, graphResult.Error ?? "unknown error");
                errorMessage = graphResult.Error ?? "Topology graph is unavailable.";
                return;
            }

            var indexResult = await indexTask;
            if (!indexResult.Success || indexResult.Value is null)
            {
                Logger?.LogWarning("Series index load failed for run {RunId}: {Error}", runId, indexResult.Error ?? "unknown error");
                errorMessage = indexResult.Error ?? "Run index metadata could not be retrieved.";
                return;
            }

            Logger?.LogInformation("Topology graph + index loaded for run {RunId}: nodes={NodeCount}, edges={EdgeCount}, bins={Bins}",
                runId,
                graphResult.Value.Nodes?.Count ?? 0,
                graphResult.Value.Edges?.Count ?? 0,
                indexResult.Value.Grid.Bins);

            topologyGraph = GraphMapper.Map(graphResult.Value, overlaySettings.RespectUiPositions, overlaySettings.Layout);
            seriesIndex = indexResult.Value;

            var totalBins = Math.Max(1, seriesIndex.Grid.Bins);
            var span = Math.Min(totalBins, 500);
            var sliceEnd = totalBins - 1;
            var sliceStart = Math.Max(0, sliceEnd - (span - 1));

            if (restoredSelectedBin.HasValue)
            {
                var desired = Math.Clamp(restoredSelectedBin.Value, 0, totalBins - 1);
                if (desired < sliceStart)
                {
                    sliceStart = Math.Max(0, Math.Min(desired, totalBins - span));
                    sliceEnd = Math.Min(totalBins - 1, sliceStart + span - 1);
                }
                else if (desired > sliceEnd)
                {
                    sliceEnd = desired;
                    sliceStart = Math.Max(0, sliceEnd - (span - 1));
                }
            }

            visibleStartBin = sliceStart;
            visibleEndBin = sliceEnd;

            var stateMode = (overlaySettings.EnableFullDag || overlaySettings.IncludeExpressionNodes || overlaySettings.IncludeConstNodes) ? "full" : null;
            Logger?.LogInformation("Requesting state window for run {RunId} bins {Start}-{End} (mode={Mode})", runId, sliceStart, sliceEnd, stateMode ?? "operational");
            windowWarnings = Array.Empty<TimeTravelStateWarningDto>();
            UpdateNodeWarningMap();
            var windowResult = await DataService.GetStateWindowAsync(runId, sliceStart, sliceEnd, stateMode, ct);
            if (!windowResult.Success || windowResult.Value is null)
            {
                Logger?.LogWarning("State window load failed for run {RunId}: {Error}", runId, windowResult.Error ?? "unknown error");
                errorMessage = windowResult.Error ?? "Failed to load run state window.";
                return;
            }

            windowData = windowResult.Value;
            windowWarnings = windowData.Warnings ?? Array.Empty<TimeTravelStateWarningDto>();
            UpdateNodeWarningMap();
            Logger?.LogInformation("State window loaded for run {RunId}: nodeSeries={NodeSeriesCount}, timestamps={TimestampCount}",
                runId,
                windowData.Nodes.Count,
                windowData.TimestampsUtc.Count);
            BuildNodeSparklines();
            Logger?.LogInformation("Sparkline map built for run {RunId}: sparklines={SparklineCount}, missing={MissingCount}",
                runId,
                nodeSparklines?.Count ?? 0,
                nodesMissingSparkline?.Count ?? 0);
            timestamps = windowData.TimestampsUtc.ToList();
            runDisplayName = windowData.Metadata.TemplateTitle ?? windowData.Metadata.TemplateId ?? runId;

            await JS.InvokeVoidAsync("localStorage.setItem", LastRunStorageKey, runId);

            var initialSelected = visibleEndBin;
            if (restoredSelectedBin.HasValue)
            {
                initialSelected = Math.Clamp(restoredSelectedBin.Value, visibleStartBin, visibleEndBin);
            }

            selectedBin = initialSelected;
            restoredSelectedBin = null;
            RefreshTimelineTicks();
            UpdateActiveMetrics(selectedBin);
            // Ensure node sparkline slices are built for the initial selection so chips show values, not labels.
            BuildNodeSparklines();

            hasLoaded = true;
            ScheduleRunStateSave();
        }
        catch (OperationCanceledException)
        {
            // ignored; a new load started
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Failed to load topology for run {RunId}", runId);
            errorMessage = $"Failed to load topology: {ex.Message}";
        }
        finally
        {
            Logger?.LogInformation("Topology load finished for run {RunId}", runId);
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task OpenFeatureBar()
    {
        if (featureBarOpen)
        {
            return;
        }

        featureBarOpen = false;
        StateHasChanged();
        await SaveRunStateAsync();
    }

    private async Task CloseFeatureBar()
    {
        if (!featureBarOpen)
        {
            return;
        }

        featureBarOpen = false;
        StateHasChanged();
        await SaveRunStateAsync();
    }

    private sealed class StoredTopologyRunState
    {
        public TopologyOverlaySettings? Overlay { get; set; }
        public StoredViewportState? Viewport { get; set; }
        public Dictionary<string, bool>? Sections { get; set; }
        public bool? FeatureBarOpen { get; set; }
        public int? SelectedBin { get; set; }
        public int? VisibleStartBin { get; set; }
        public int? VisibleEndBin { get; set; }
    }

    private sealed class StoredViewportState
    {
        public double Scale { get; set; }
        public double OffsetX { get; set; }
        public double OffsetY { get; set; }
        public double WorldCenterX { get; set; }
        public double WorldCenterY { get; set; }
        public double OverlayScale { get; set; }
        public double BaseScale { get; set; }

        public ViewportSnapshot ToSnapshot() => new()
        {
            Scale = Scale,
            OffsetX = OffsetX,
            OffsetY = OffsetY,
            WorldCenterX = WorldCenterX,
            WorldCenterY = WorldCenterY,
            OverlayScale = OverlayScale,
            BaseScale = BaseScale
        };

        public static StoredViewportState FromSnapshot(ViewportSnapshot snapshot) => new()
        {
            Scale = snapshot.Scale,
            OffsetX = snapshot.OffsetX,
            OffsetY = snapshot.OffsetY,
            WorldCenterX = snapshot.WorldCenterX,
            WorldCenterY = snapshot.WorldCenterY,
            OverlayScale = snapshot.OverlayScale,
            BaseScale = snapshot.BaseScale
        };
    }

    private async Task OnOverlaySettingsChanged(TopologyOverlaySettings updated)
    {
        var previous = overlaySettings.Clone();

        overlaySettings = updated.Clone();
        await SaveRunStateAsync();

        var derivedOperational = !overlaySettings.EnableFullDag
            && !overlaySettings.IncludeExpressionNodes
            && !overlaySettings.IncludeConstNodes;

        if (!derivedOperational && operationalViewOnly)
        {
            operationalViewOnly = false;
            savedIncludeExpressionNodes = null;
            savedIncludeConstNodes = null;
            savedEnableFullDag = null;
        }
        else if (derivedOperational && !operationalViewOnly)
        {
            operationalViewOnly = true;
        }

        var requiresGraphReload = previous.EnableFullDag != overlaySettings.EnableFullDag
            || previous.RespectUiPositions != overlaySettings.RespectUiPositions
            || previous.Layout != overlaySettings.Layout
            || previous.IncludeExpressionNodes != overlaySettings.IncludeExpressionNodes
            || previous.IncludeConstNodes != overlaySettings.IncludeConstNodes
            || previous.IncludeServiceNodes != overlaySettings.IncludeServiceNodes;

        if (requiresGraphReload)
        {
            pendingViewportSnapshot = null;
            currentViewportSnapshot = null;
            isRestoringViewport = false;
            pointerNeedsJump = true;
            if (canvasComponent is not null)
            {
                await canvasComponent.ResetViewportAsync();
            }
        }

        if (requiresGraphReload && hasLoaded)
        {
            await RefreshGraphAsync();
            await ReloadWindowAsync();
            StateHasChanged();
        }
        else
        {
            StateHasChanged();
        }
    }

    private async Task HandleCanvasZoomChanged(double zoomPercent)
    {
        var clamped = Math.Clamp(zoomPercent, 25d, 200d);
        if (Math.Abs(overlaySettings.ZoomPercent - clamped) < 0.1d)
        {
            return;
        }

        var updated = overlaySettings.Clone();
        updated.ZoomPercent = clamped;
        await OnOverlaySettingsChanged(updated);
    }

    private async Task ResetZoom()
    {
        var updated = overlaySettings.Clone();
        updated.ZoomPercent = 100d;
        await OnOverlaySettingsChanged(updated);
        pointerNeedsJump = true;
        pendingViewportSnapshot = currentViewportSnapshot?.CloneWithScale(1d);
    }

    private async Task FitViewport()
    {
        if (canvasComponent is null)
        {
            return;
        }

        StopPlayback();
        var zoomPercent = await canvasComponent.FitToViewportAsync();
        if (double.IsFinite(zoomPercent))
        {
            var clamped = Math.Clamp(zoomPercent, 25d, 200d);
            if (Math.Abs(overlaySettings.ZoomPercent - clamped) > 0.1d)
            {
                var updated = overlaySettings.Clone();
                updated.ZoomPercent = clamped;
                await OnOverlaySettingsChanged(updated);
            }
        }

        pointerNeedsJump = true;
    }

    private async Task OnFocusMetricChanged(TopologyColorBasis basis)
    {
        if (overlaySettings.ColorBasis == basis)
        {
            return;
        }

        var updated = overlaySettings.Clone();
        updated.ColorBasis = basis;
        await OnOverlaySettingsChanged(updated);
    }

    private async Task OnOperationalViewChanged(bool value)
    {
        if (value == operationalViewOnly || operationalTogglePending)
        {
            return;
        }

        operationalTogglePending = true;

        var updated = overlaySettings.Clone();

        if (value)
        {
            savedIncludeExpressionNodes = overlaySettings.IncludeExpressionNodes;
            savedIncludeConstNodes = overlaySettings.IncludeConstNodes;
            savedEnableFullDag = overlaySettings.EnableFullDag;

            updated.IncludeExpressionNodes = false;
            updated.IncludeConstNodes = false;
            updated.EnableFullDag = false;
        }
        else
        {
            updated.IncludeExpressionNodes = savedIncludeExpressionNodes ?? true;
            updated.IncludeConstNodes = savedIncludeConstNodes ?? true;
            updated.EnableFullDag = savedEnableFullDag ?? true;

            savedIncludeExpressionNodes = null;
            savedIncludeConstNodes = null;
            savedEnableFullDag = null;
        }

        operationalViewOnly = value;
        try
        {
            await OnOverlaySettingsChanged(updated);
        }
        finally
        {
            operationalTogglePending = false;
        }
    }

    private async Task OnFeatureSectionExpansionChanged(SectionExpansionChangedArgs args)
    {
        sectionExpansionState[args.Section] = args.IsExpanded;
        await SaveRunStateAsync();
    }

    private async Task OnCanvasViewportChanged(ViewportSnapshot snapshot)
    {
        if (snapshot is null)
        {
            return;
        }

        currentViewportSnapshot = snapshot;
        if (isRestoringViewport)
        {
            return;
        }

        if (hasLoaded && !string.IsNullOrWhiteSpace(currentRunId))
        {
            ScheduleRunStateSave();
        }
    }

    private Task OnRequestedViewportConsumed()
    {
        pendingViewportSnapshot = null;
        if (isRestoringViewport)
        {
            isRestoringViewport = false;
            if (hasLoaded && !string.IsNullOrWhiteSpace(currentRunId))
            {
                ScheduleRunStateSave();
            }
        }
        return Task.CompletedTask;
    }

    private GraphQueryOptions BuildGraphQueryOptions()
    {
        var options = new GraphQueryOptions
        {
            Mode = overlaySettings.EnableFullDag ? "full" : "operational"
        };

        if (overlaySettings.EnableFullDag)
        {
            var dependencyFields = new List<string>(6);

            if (overlaySettings.ShowArrivalsDependencies)
            {
                dependencyFields.Add("arrivals");
            }

            if (overlaySettings.ShowServedDependencies)
            {
                dependencyFields.Add("served");
            }

            if (overlaySettings.ShowErrorsDependencies)
            {
                dependencyFields.Add("errors");
            }

            if (overlaySettings.ShowQueueDependencies)
            {
                dependencyFields.Add("queue");
            }

            if (overlaySettings.ShowCapacityDependencies)
            {
                dependencyFields.Add("capacity");
            }

            if (overlaySettings.ShowExpressionDependencies)
            {
                dependencyFields.Add("expr");
            }

            if (dependencyFields.Count > 0 && dependencyFields.Count < 6)
            {
                options.DependencyFields = dependencyFields;
            }
        }

        return options;
    }

    private async Task RefreshGraphAsync()
    {
        if (string.IsNullOrWhiteSpace(currentRunId))
        {
            return;
        }

        try
        {
            var graphResult = await DataService.GetGraphAsync(currentRunId, BuildGraphQueryOptions());
            if (!graphResult.Success || graphResult.Value is null)
            {
                errorMessage = graphResult.Error ?? "Topology graph is unavailable.";
                StateHasChanged();
                return;
            }

            topologyGraph = GraphMapper.Map(graphResult.Value, overlaySettings.RespectUiPositions, overlaySettings.Layout);
            errorMessage = null;
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to refresh topology: {ex.Message}";
        }

        StateHasChanged();
    }

    private async Task ReloadWindowAsync()
    {
        if (!hasLoaded || string.IsNullOrWhiteSpace(currentRunId))
        {
            return;
        }

        var sliceStart = Math.Max(0, visibleStartBin);
        var sliceEnd = Math.Max(sliceStart, visibleEndBin);

        var cts = new CancellationTokenSource();
        windowReloadCts?.Cancel();
        windowReloadCts?.Dispose();
        windowReloadCts = cts;

        try
        {
            var mode = overlaySettings.EnableFullDag ? "full" : null;
            var fullMode = (overlaySettings.EnableFullDag || overlaySettings.IncludeExpressionNodes || overlaySettings.IncludeConstNodes) ? "full" : mode;
            windowWarnings = Array.Empty<TimeTravelStateWarningDto>();
            UpdateNodeWarningMap();
            var windowResult = await DataService.GetStateWindowAsync(currentRunId!, sliceStart, sliceEnd, fullMode, cts.Token);
            if (!windowResult.Success || windowResult.Value is null)
            {
                return;
            }

            windowData = windowResult.Value;
            windowWarnings = windowData.Warnings ?? Array.Empty<TimeTravelStateWarningDto>();
            UpdateNodeWarningMap();
            timestamps = windowData.TimestampsUtc.ToList();
            BuildNodeSparklines();

            var clampedSelection = Math.Clamp(selectedBin, sliceStart, sliceEnd);
            UpdateActiveMetrics(clampedSelection);
        }
        catch (OperationCanceledException)
        {
            // Ignored
        }
        catch
        {
            // Non-fatal; retain previous window data
        }
        finally
        {
            if (ReferenceEquals(windowReloadCts, cts))
            {
                windowReloadCts = null;
            }

            cts.Dispose();
        }
    }

    private Task OnDialInput(ChangeEventArgs args)
    {
        StopPlayback();
        if (int.TryParse(args.Value?.ToString(), NumberStyles.Integer, CultureInfo.InvariantCulture, out var value))
        {
            return OnBinChanged(value);
        }

        return Task.CompletedTask;
    }

    private Task GoToNextBin()
    {
        StopPlayback();
        var next = Math.Min(selectedBin + 1, visibleEndBin);
        return OnBinChanged(next);
    }

    private Task GoToPreviousBin()
    {
        StopPlayback();
        var previous = Math.Max(selectedBin - 1, visibleStartBin);
        return OnBinChanged(previous);
    }

    private Task TogglePlaybackAsync()
    {
        if (isPlaying)
        {
            StopPlayback();
        }
        else
        {
            StartPlayback();
        }

        return Task.CompletedTask;
    }

    private void ToggleLoop()
    {
        loopPlayback = !loopPlayback;
    }

    private Task OnPlaybackSpeedChipChanged(double factor)
    {
        playbackSpeedFactor = AlignPlaybackFactor(factor);
        playbackSecondsPerFrame = GetSecondsForFactor(playbackSpeedFactor);
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void StartDialDrag(PointerEventArgs _)
    {
        if (!isDialPointerDragging)
        {
            isDialPointerDragging = true;
            StateHasChanged();
        }
    }

    private void EndDialDrag(PointerEventArgs _)
    {
        if (isDialPointerDragging)
        {
            isDialPointerDragging = false;
            StateHasChanged();
        }
    }

    private const string LastRunStorageKey = "ft.topology.lastRunId";

    private void UpdateActiveMetrics(int bin)
    {
        if (windowData is null)
        {
            activeMetrics = new Dictionary<string, NodeBinMetrics>(StringComparer.OrdinalIgnoreCase);
            selectedBinLabel = bin.ToString(CultureInfo.InvariantCulture);
            selectedTimestampLabel = string.Empty;
            EnsureInspectorVisibility();
            return;
        }

        var spanStart = windowData.Window.StartBin;
        var localIndex = bin - spanStart;
        if (localIndex < 0 || localIndex >= windowData.Window.BinCount)
        {
            activeMetrics = new Dictionary<string, NodeBinMetrics>(StringComparer.OrdinalIgnoreCase);
            selectedBinLabel = bin.ToString(CultureInfo.InvariantCulture);
            selectedTimestampLabel = string.Empty;
            EnsureInspectorVisibility();
            return;
        }

        var metrics = new Dictionary<string, NodeBinMetrics>(StringComparer.OrdinalIgnoreCase);
        var selectionTimestamp = localIndex >= 0 && localIndex < timestamps.Count
            ? timestamps[localIndex]
            : (DateTimeOffset?)null;

        foreach (var node in windowData.Nodes)
        {
            double? Get(string key)
            {
                if (node.Series.TryGetValue(key, out var values) && localIndex < values.Length)
                {
                    return values[localIndex];
                }
                return null;
            }

            var topoNode = FindTopologyNode(node.Id);
            var displayKind = string.IsNullOrWhiteSpace(topoNode?.Kind) ? node.Kind : topoNode!.Kind;
            var isPmf = IsPmfKind(displayKind);
            var isComputed = IsComputedKind(displayKind);
            var distribution = topoNode?.Semantics?.Distribution;
            var (modeProbability, modeValue) = ComputePmfMode(distribution);
            var arrivals = Get("arrivals");
            var served = Get("served");
            var errors = Get("errors");
            var attempts = Get("attempts");
            var failures = Get("failures");
            var retryEcho = Get("retryEcho");
            var capacity = Get("capacity");
            var throughput = Get("throughputRatio");
            var utilization = Get("utilization");
            var queue = Get("queue");
            var latency = Get("latencyMinutes");
            var serviceTime = Get("serviceTimeMs");
            var retryTax = Get("retryTax");

            double? successRate = throughput;
            if (successRate is null && arrivals.HasValue && arrivals.Value > 0 && served.HasValue)
            {
                successRate = served.Value / arrivals.Value;
            }

            double? errorRate = null;
            var denominator = arrivals ?? served;
            if (errors.HasValue && denominator.HasValue && denominator.Value > 0)
            {
                errorRate = errors.Value / denominator.Value;
            }

            double? customValue = null;
            string? customLabel = null;
            double? pmfProbability = null;
            double? pmfSupportValue = null;

            var rawMetrics = new Dictionary<string, double?>(StringComparer.OrdinalIgnoreCase);
            void SetRaw(string key, double? value)
            {
                if (value.HasValue)
                {
                    rawMetrics[key] = value.Value;
                }
            }

            SetRaw("arrivals", arrivals);
            SetRaw("served", served);
            SetRaw("errors", errors);
            SetRaw("attempts", attempts);
            SetRaw("failures", failures);
            SetRaw("retryEcho", retryEcho);
            SetRaw("queue", queue);
            SetRaw("retryTax", retryTax);
            SetRaw("capacity", capacity);

            if (isComputed && !isPmf)
            {
                if (nodeSparklines is not null && nodeSparklines.TryGetValue(node.Id, out var sparkline))
                {
                    var sampled = SampleSparklineAt(sparkline, bin);
                    if (sampled.HasValue)
                    {
                        customValue = sampled;
                        customLabel = BinValueLabel;
                    }
                }

                if (!customValue.HasValue && IsExpressionKind(displayKind) && nodesMissingSparkline.Contains(node.Id))
                {
                    customLabel = MissingSeriesMessage;
                }
            }

            if (isPmf)
            {
                var expectation = ComputePmfExpectation(distribution);
                if (expectation.HasValue)
                {
                    customValue = expectation;
                    customLabel = PmfExpectationLabel;
                }

                pmfProbability = modeProbability;
                pmfSupportValue = modeValue ?? expectation;

                if (string.IsNullOrWhiteSpace(customLabel) && nodesMissingSparkline.Contains(node.Id))
                {
                    customLabel = MissingSeriesMessage;
                }
            }

            if (!customValue.HasValue)
            {
                double? direct = Get("values");
                if (!direct.HasValue)
                {
                    direct = Get($"series:{node.Id}") ?? Get(node.Id);
                }

                if (direct.HasValue && double.IsFinite(direct.Value))
                {
                    customValue = direct;
                    customLabel = isPmf ? PmfExpectationLabel : BinValueLabel;
                }
            }

            metrics[node.Id] = new NodeBinMetrics(
                successRate,
                utilization,
                errorRate,
                queue,
                latency,
                selectionTimestamp,
                CustomValue: customValue,
                CustomLabel: customLabel,
                PmfProbability: pmfProbability,
                PmfValue: pmfSupportValue,
                NodeKind: displayKind,
                ServiceTimeMs: serviceTime,
                RetryTax: retryTax,
                RawMetrics: rawMetrics.Count == 0 ? null : rawMetrics,
                Metadata: topoNode?.Semantics?.Metadata);
        }

        if (topologyGraph is not null)
        {
            foreach (var topoNode in topologyGraph.Nodes)
            {
                if (topoNode is null)
                {
                    continue;
                }

                var topoNodeId = topoNode.Id;
                if (string.IsNullOrWhiteSpace(topoNodeId))
                {
                    continue;
                }
                metrics.TryGetValue(topoNodeId, out var existingMetrics);
                nodeSparklines.TryGetValue(topoNodeId, out var sparkline);

                double? inlineValue = null;
                var inline = topoNode.Semantics?.InlineValues;
                if (inline != null && inline.Count > 0)
                {
                    if (bin >= 0 && bin < inline.Count)
                    {
                        inlineValue = inline[bin];
                    }
                    else if (localIndex >= 0 && localIndex < inline.Count)
                    {
                        inlineValue = inline[localIndex];
                    }

                    if (inlineValue.HasValue && (!double.IsFinite(inlineValue.Value)))
                    {
                        inlineValue = null;
                    }
                }

                var topoKind = topoNode.Kind;
                if (string.IsNullOrWhiteSpace(topoKind) && windowData?.Nodes is { } windowNodes)
                {
                    var seriesNode = windowNodes.FirstOrDefault(n => string.Equals(n.Id, topoNodeId, StringComparison.OrdinalIgnoreCase));
                    topoKind = seriesNode?.Kind;
                }

                var isPmfNode = IsPmfKind(topoKind);
                double? pmfProbability = null;
                double? pmfSupportValue = null;
                double? customValue = null;
                string? customLabel = null;

                if (isPmfNode)
                {
                    var distribution = topoNode.Semantics?.Distribution;
                    var expectation = ComputePmfExpectation(distribution);
                    var (modeProbability, modeValue) = ComputePmfMode(distribution);

                    pmfProbability = modeProbability;
                    pmfSupportValue = modeValue ?? expectation ?? inlineValue;

                    if (expectation.HasValue)
                    {
                        customValue = expectation;
                        customLabel = PmfExpectationLabel;
                    }
                    else if (pmfSupportValue.HasValue)
                    {
                        customValue = pmfSupportValue;
                        customLabel = PmfExpectationLabel;
                    }
                    else if (inlineValue.HasValue)
                    {
                        customValue = inlineValue;
                        customLabel = PmfExpectationLabel;
                    }
                    else if (nodesMissingSparkline.Contains(topoNode.Id))
                    {
                        customLabel = MissingSeriesMessage;
                    }
                }
                else
                {
                    var sampleValue = SampleSparklineAt(sparkline, bin);
                    customValue = sampleValue ?? inlineValue;
                    if (customValue.HasValue)
                    {
                        customLabel = BinValueLabel;
                    }
                    else if (IsExpressionKind(topoNode.Kind) && nodesMissingSparkline.Contains(topoNode.Id))
                    {
                        customLabel = MissingSeriesMessage;
                    }
                }

                if (!customValue.HasValue && string.IsNullOrWhiteSpace(customLabel))
                {
                    continue;
                }

                if (existingMetrics is not null)
                {
                    var newCustomValue = customValue ?? existingMetrics.CustomValue;
                    var newCustomLabel = customLabel ?? existingMetrics.CustomLabel;
                    if (customValue.HasValue && string.IsNullOrWhiteSpace(customLabel))
                    {
                        newCustomLabel = isPmfNode ? PmfExpectationLabel : BinValueLabel;
                    }

                    if (!Equals(newCustomValue, existingMetrics.CustomValue) ||
                        !string.Equals(newCustomLabel, existingMetrics.CustomLabel, StringComparison.Ordinal) ||
                        !Equals(pmfProbability, existingMetrics.PmfProbability) ||
                        !Equals(pmfSupportValue, existingMetrics.PmfValue))
                    {
                        metrics[topoNodeId] = new NodeBinMetrics(
                            existingMetrics.SuccessRate,
                            existingMetrics.Utilization,
                            existingMetrics.ErrorRate,
                            existingMetrics.QueueDepth,
                            existingMetrics.LatencyMinutes,
                            existingMetrics.Timestamp,
                            CustomValue: newCustomValue,
                            CustomLabel: newCustomLabel,
                            PmfProbability: pmfProbability ?? existingMetrics.PmfProbability,
                            PmfValue: pmfSupportValue ?? existingMetrics.PmfValue,
                            NodeKind: existingMetrics.NodeKind ?? topoNode.Kind,
                            ServiceTimeMs: existingMetrics.ServiceTimeMs,
                            RetryTax: existingMetrics.RetryTax,
                            RawMetrics: existingMetrics.RawMetrics,
                            Metadata: existingMetrics.Metadata ?? topoNode.Semantics?.Metadata);
                    }

                    continue;
                }

                metrics[topoNodeId] = new NodeBinMetrics(
                    null,
                    null,
                    null,
                    null,
                    null,
                    selectionTimestamp,
                    CustomValue: customValue,
                    CustomLabel: customLabel,
                    PmfProbability: pmfProbability,
                    PmfValue: pmfSupportValue,
                    NodeKind: topoNode.Kind,
                    RetryTax: existingMetrics?.RetryTax,
                    RawMetrics: existingMetrics?.RawMetrics,
                    Metadata: topoNode.Semantics?.Metadata ?? existingMetrics?.Metadata);
            }
        }

        activeMetrics = metrics;
        selectedBin = bin;
        selectedBinLabel = bin.ToString(CultureInfo.InvariantCulture);
        selectedTimestampLabel = FormatTimestamp(localIndex);
        EnsureInspectorVisibility();

        if (hasLoaded && !isPlaying)
        {
            ScheduleRunStateSave();
        }
    }

    private void RefreshTimelineTicks()
    {
        if (visibleEndBin < visibleStartBin)
        {
            timelineTicks = Array.Empty<TimelineTick>();
            timelineMinorTicks = Array.Empty<double>();
            return;
        }

        RecomputePlaybackSpeedOptions(Math.Max(1, visibleEndBin - visibleStartBin + 1));

        if (visibleEndBin == visibleStartBin)
        {
            timelineTicks = new[]
            {
                new TimelineTick(visibleStartBin, 0d, BuildTickLabel(visibleStartBin))
            };
            timelineMinorTicks = Array.Empty<double>();
            return;
        }

        var span = visibleEndBin - visibleStartBin;
        var totalBins = span + 1;

        // Aim for ~12 labels; adjust step accordingly
        var targetLabels = 12;
        var step = Math.Max(1, (int)Math.Ceiling(totalBins / (double)targetLabels));

        // If we know bin minutes, try to align to nice hour multiples
        try
        {
            var binMinutes = seriesIndex?.Grid?.BinMinutes ?? 0;
            if (binMinutes > 0)
            {
                var niceMinutes = new[] { 60, 120, 180, 240, 360, 720 };
                foreach (var minutes in niceMinutes)
                {
                    var candidate = Math.Max(1, (int)Math.Round(minutes / (double)binMinutes));
                    var count = Math.Max(1, (int)Math.Ceiling(totalBins / (double)candidate));
                    if (count <= targetLabels)
                    {
                        step = candidate;
                        break;
                    }
                }
            }
        }
        catch
        {
            // ignore and use computed step
        }

        var ticks = new List<TimelineTick>(Math.Min(totalBins, targetLabels) + 2);
        for (var bin = visibleStartBin; bin <= visibleEndBin; bin += step)
        {
            var percent = ((bin - visibleStartBin) / (double)span) * 100d;
            percent = Math.Clamp(percent, 0d, 100d);
            ticks.Add(new TimelineTick(bin, percent, BuildTickLabel(bin)));
        }

        // Ensure last label is included
        if (ticks.Count == 0 || ticks[^1].Bin != visibleEndBin)
        {
            ticks.Add(new TimelineTick(visibleEndBin, 100d, BuildTickLabel(visibleEndBin)));
        }

        timelineTicks = ticks;

        var minorTicks = new List<double>();
        for (var i = 0; i < ticks.Count - 1; i++)
        {
            var current = ticks[i];
            var next = ticks[i + 1];
            if (next.Bin - current.Bin <= 1)
            {
                continue;
            }

            var midPercent = (current.Percent + next.Percent) / 2d;
            if (midPercent > current.Percent && midPercent < next.Percent)
            {
                minorTicks.Add(midPercent);
            }
        }

        timelineMinorTicks = minorTicks;
    }

    private void RecomputePlaybackSpeedOptions(int totalBins)
    {
        totalBins = Math.Max(1, totalBins);
        var baseSeconds = BasePlaybackTotalSeconds / totalBins;
        baseSeconds = Math.Clamp(baseSeconds, MinPlaybackDelay, MaxPlaybackDelay);

        var options = new List<PlaybackSpeedOption>(PlaybackSpeedFactors.Length);
        foreach (var factor in PlaybackSpeedFactors)
        {
            var seconds = Math.Clamp(baseSeconds / factor, MinPlaybackDelay, MaxPlaybackDelay);
            var label = $"{factor:0.#}x";
            options.Add(new PlaybackSpeedOption(factor, seconds, label));
        }

        if (options.Count == 0)
        {
            options.Add(new PlaybackSpeedOption(1d, baseSeconds, "1x"));
        }

        playbackSpeedOptions = options;
        playbackSpeedFactor = AlignPlaybackFactor(playbackSpeedFactor);
        playbackSecondsPerFrame = GetSecondsForFactor(playbackSpeedFactor);
    }

    private double AlignPlaybackFactor(double value)
    {
        if (playbackSpeedOptions.Count == 0)
        {
            playbackSpeedOptions.Add(new PlaybackSpeedOption(1d, Math.Clamp(playbackSecondsPerFrame, MinPlaybackDelay, MaxPlaybackDelay), "1x"));
        }

        var closest = playbackSpeedOptions[0].Factor;
        var smallestDelta = Math.Abs(playbackSpeedOptions[0].Factor - value);

        foreach (var option in playbackSpeedOptions)
        {
            var delta = Math.Abs(option.Factor - value);
            if (delta < smallestDelta)
            {
                smallestDelta = delta;
                closest = option.Factor;
            }
        }

        return closest;
    }

    private double GetSecondsForFactor(double factor)
    {
        var option = playbackSpeedOptions.FirstOrDefault(o => Math.Abs(o.Factor - factor) < 0.0001);
        if (option is not null)
        {
            return option.Seconds;
        }

        return playbackSpeedOptions.Count > 0
            ? playbackSpeedOptions[0].Seconds
            : Math.Clamp(BasePlaybackTotalSeconds, MinPlaybackDelay, MaxPlaybackDelay);
    }

    private string BuildTickLabel(int bin)
    {
        if (windowData is not null)
        {
            var spanStart = windowData.Window.StartBin;
            var localIndex = bin - spanStart;
            if (localIndex >= 0 && localIndex < timestamps.Count)
            {
                var ts = timestamps[localIndex];
                return ts.ToString("HH:mm", CultureInfo.InvariantCulture);
            }
        }

        return $"Bin {bin}";
    }

    private (double?[]? Data, double Min, double Max, int HighlightStart, int HighlightEnd) ResolveHorizonSeries(string nodeId, string? seriesKey, NodeSparklineData? fallback)
    {
        double?[]? data = null;
        double min = 0d, max = 0d;
        int hStart = 0, hEnd = 0;

        if (windowData is not null)
        {
            var node = windowData.Nodes.FirstOrDefault(n => string.Equals(n.Id, nodeId, StringComparison.OrdinalIgnoreCase));
            if (node is not null)
            {
                data = ResolveFullSeries(node, seriesKey);
            }

            var startBin = windowData.Window.StartBin;
            var endBin = windowData.Window.EndBin;
            var totalBins = Math.Max(1, endBin - startBin + 1);
            var winStart = Math.Max(startBin, selectedBin - SparklinePointLimit + 1);
            var winEnd = Math.Max(winStart, Math.Min(selectedBin, endBin));
            hStart = Math.Clamp(winStart - startBin, 0, totalBins - 1);
            hEnd = Math.Clamp(winEnd - startBin, 0, totalBins - 1);
        }

        if (data is null || data.Length == 0)
        {
            // Fallback to trimmed values to avoid empty charts
            if (fallback is not null)
            {
                data = fallback.Values as double?[] ?? fallback.Values.ToArray();
                hStart = 0;
                hEnd = data.Length - 1;
            }
            else
            {
                data = Array.Empty<double?>();
                hStart = 0;
                hEnd = 0;
            }
        }

        (min, max) = ComputeSeriesMinMax(data);
        return (data, min, max, hStart, hEnd);
    }

    private static (double Min, double Max) ComputeSeriesMinMax(double?[]? data)
    {
        if (data is null || data.Length == 0)
        {
            return (0d, 0d);
        }

        var min = double.PositiveInfinity;
        var max = double.NegativeInfinity;
        var any = false;
        foreach (var v in data)
        {
            if (v.HasValue && double.IsFinite(v.Value))
            {
                any = true;
                if (v.Value < min) min = v.Value;
                if (v.Value > max) max = v.Value;
            }
        }

        if (!any)
        {
            return (0d, 0d);
        }

        if (Math.Abs(max - min) < 1e-9)
        {
            var baseline = min;
            var epsilon = Math.Max(Math.Abs(baseline) * 0.001d, 0.001d);
            var adjustedMin = baseline - epsilon;
            if (baseline >= 0d && adjustedMin < 0d)
            {
                min = 0d;
                max = epsilon;
            }
            else
            {
                min = adjustedMin;
                max = baseline + epsilon;
            }
        }

        return (min, max);
    }

    private double?[]? ResolveFullSeries(TimeTravelNodeSeriesDto node, string? key)
    {
        var k = (key ?? string.Empty).Trim().ToLowerInvariant();
        switch (k)
        {
            case "successrate":
                return BuildSuccessRateSeries(node);
            case "errorrate":
                return BuildErrorRateSeries(node);
            case "latency":
            case "latencyminutes":
                return TryGetSeries(node, "latencyMinutes") ?? TryGetSeries(node, "latency");
            case "queue":
            case "queuedepth":
                return TryGetSeries(node, "queue") ?? TryGetSeries(node, "queueDepth");
            case "values":
            case "output":
                return TryGetSeries(node, "values") ?? TryGetSeries(node, "output") ?? TryGetSeries(node, node.Id) ?? TryGetSeries(node, $"series:{node.Id}");
            case "errors":
                return TryGetSeries(node, "errors");
            case "served":
                return TryGetSeries(node, "served");
            case "arrivals":
                return TryGetSeries(node, "arrivals");
            default:
                // Unknown series key; try direct lookup
                return string.IsNullOrWhiteSpace(key) ? null : TryGetSeries(node, key);
        }
    }

    private void StartPlayback()
    {
        if (isPlaying || visibleStartBin == visibleEndBin)
        {
            return;
        }

        playbackCts?.Cancel();
        playbackCts = new CancellationTokenSource();
        var token = playbackCts.Token;
        isPlaying = true;
        playbackTask = RunPlaybackLoopAsync(token);
        StateHasChanged();
    }

    private void StopPlayback()
    {
        playbackCts?.Cancel();
        pointerNeedsJump = false;
    }

    private async Task RunPlaybackLoopAsync(CancellationToken token)
    {
        try
        {
            while (!token.IsCancellationRequested)
            {
                await Task.Delay(TimeSpan.FromSeconds(playbackSecondsPerFrame), token);

                var shouldJumpAfterPause = false;
                await InvokeAsync(() =>
                {
                    if (visibleStartBin == visibleEndBin)
                    {
                        StopPlayback();
                        return;
                    }

                    var stepCount = Math.Max(1, (int)Math.Round(playbackSpeedFactor));
                    var next = selectedBin + stepCount;
                    if (next > visibleEndBin)
                    {
                        if (loopPlayback)
                        {
                            pointerNeedsJump = true;
                            shouldJumpAfterPause = true;
                            return;
                        }
                        else
                        {
                            StopPlayback();
                            return;
                        }
                    }

                    pointerNeedsJump = false;

                    UpdateActiveMetrics(next);
                    // Ensure sparkline slices are anchored at the new selection during playback
                    BuildNodeSparklines();
                    StateHasChanged();
                });

                if (shouldJumpAfterPause)
                {
                    await Task.Delay(TimeSpan.FromSeconds(1), token);

                    await InvokeAsync(() =>
                    {
                        if (token.IsCancellationRequested)
                        {
                            return;
                        }

                        pointerNeedsJump = true;
                        UpdateActiveMetrics(visibleStartBin);
                        BuildNodeSparklines();
                        StateHasChanged();
                    });
                }
            }
        }
        catch (TaskCanceledException)
        {
            // expected when playback is stopped
        }
        finally
        {
            await InvokeAsync(() =>
            {
                playbackCts?.Dispose();
                playbackCts = null;
                isPlaying = false;
                playbackTask = Task.CompletedTask;
                StateHasChanged();
            });
        }
    }

    private string FormatTimestamp(int localIndex)
    {
        if (localIndex < 0 || localIndex >= timestamps.Count)
        {
            return string.Empty;
        }

        var ts = timestamps[localIndex];
        return ts.ToString("dd MMM yyyy HH:mm 'UTC'", CultureInfo.InvariantCulture);
    }

    private Task OnNodeFocused(string? nodeId)
    {
        if (string.IsNullOrWhiteSpace(nodeId))
        {
            inspectorPinned = false;
            inspectorOpen = false;
            inspectorNodeId = null;
        }
        else
        {
            inspectorNodeId = nodeId;
            inspectorOpen = true;
            inspectorPinned = true;
        }

        inspectorMetricsExpanded = false;
        ClearInspectorEdgeHighlights();
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void EnsureInspectorVisibility()
    {
        if (inspectorPinned && !string.IsNullOrWhiteSpace(inspectorNodeId))
        {
            inspectorOpen = true;
        }
    }

    private static string FormatPercent(double? value)
    {
        return value.HasValue
            ? (value.Value * 100).ToString("0", CultureInfo.InvariantCulture) + "%"
            : "â€”";
    }

    private static string FormatNumber(double? value)
    {
        if (!value.HasValue)
        {
            return "â€”";
        }

        return value.Value.ToString("0.0", CultureInfo.InvariantCulture);
    }

    private static string FormatBinValue(double? value, InspectorValueFormat format = InspectorValueFormat.Number, string? unit = null)
    {
        var text = format switch
        {
            InspectorValueFormat.Percent => FormatPercent(value),
            _ => FormatNumber(value)
        };

        if (string.Equals(text, "â€”", StringComparison.Ordinal))
        {
            return text;
        }

        return string.IsNullOrWhiteSpace(unit) ? text : $"{text} {unit}";
    }

    private void BuildNodeSparklines()
    {
        var missing = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        loggedMissingMetricKinds.Clear();

        if (windowData is null)
        {
            nodeSparklines = new Dictionary<string, NodeSparklineData>(StringComparer.OrdinalIgnoreCase);
            nodesMissingSparkline = missing;
            return;
        }

        var result = new Dictionary<string, NodeSparklineData>(StringComparer.OrdinalIgnoreCase);
        var windowStart = windowData.Window.StartBin;
        var binCount = Math.Max(0, windowData.Window.BinCount);
        var windowEnd = binCount > 0 ? windowStart + binCount - 1 : windowStart;
        var clampedSelection = Math.Clamp(selectedBin, windowStart, windowEnd);
        var selectionLocalIndex = Math.Max(0, clampedSelection - windowStart);

        foreach (var node in windowData.Nodes)
        {
            var series = node.Series ?? new Dictionary<string, double?[]>(StringComparer.OrdinalIgnoreCase);
            var topoNode = FindTopologyNode(node.Id);
            var displayKind = string.IsNullOrWhiteSpace(topoNode?.Kind) ? node.Kind : topoNode!.Kind;
            var successSeries = BuildSuccessRateSeries(node);
            var primarySeries = successSeries ?? SelectPrimarySeries(series);
            var synthesizedValues = false;

            if (primarySeries is null && IsPmfKind(displayKind))
            {
                var expectation = ComputePmfExpectation(topoNode?.Semantics?.Distribution);
                if (expectation.HasValue)
                {
                    var syntheticLength = binCount > 0 ? binCount : SparklinePointLimit;
                    syntheticLength = Math.Max(1, syntheticLength);
                    var syntheticSeries = new double?[syntheticLength];
                    for (var i = 0; i < syntheticLength; i++)
                    {
                        syntheticSeries[i] = expectation.Value;
                    }

                    primarySeries = syntheticSeries;
                    synthesizedValues = true;
                }
            }

            if (primarySeries is null || primarySeries.Length == 0)
            {
                if (IsExpressionKind(displayKind))
                {
                    missing.Add(node.Id);
                }

                continue;
            }

            var anchor = Math.Clamp(selectionLocalIndex, 0, (primarySeries?.Length ?? 1) - 1);
            var trimmedPrimary = TrimSeriesAt(primarySeries, SparklinePointLimit, anchor);
            if (trimmedPrimary.Count == 0)
            {
                if (IsExpressionKind(displayKind))
                {
                    missing.Add(node.Id);
                }

                continue;
            }

            var primaryStartIndex = windowStart + (anchor + 1 - trimmedPrimary.Count);
            var trimmedUtilization = TrimSeriesAt(TryGetSeries(node, "utilization"), SparklinePointLimit, anchor, trimmedPrimary.Count);
            var trimmedErrorRate = TrimSeriesAt(BuildErrorRateSeries(node), SparklinePointLimit, anchor, trimmedPrimary.Count);
            var trimmedQueue = TrimSeriesAt(TryGetSeries(node, "queue"), SparklinePointLimit, anchor, trimmedPrimary.Count);

            var additional = new Dictionary<string, SparklineSeriesSlice>(StringComparer.OrdinalIgnoreCase);
            foreach (var pair in series)
            {
                var trimmed = TrimSeriesAt(pair.Value, SparklinePointLimit, anchor, trimmedPrimary.Count);
                var startIndex = pair.Value is null || pair.Value.Length == 0
                    ? primaryStartIndex
                    : windowStart + (anchor + 1 - trimmed.Count);
                additional[pair.Key] = new SparklineSeriesSlice(trimmed, startIndex);
            }

            if (successSeries is not null)
            {
                additional["successRate"] = new SparklineSeriesSlice(trimmedPrimary, primaryStartIndex);
            }

            if (trimmedUtilization.Count > 0)
            {
                additional["utilization"] = new SparklineSeriesSlice(trimmedUtilization, primaryStartIndex);
            }

            if (trimmedErrorRate.Count > 0)
            {
                additional["errorRate"] = new SparklineSeriesSlice(trimmedErrorRate, primaryStartIndex);
            }

            if (trimmedQueue.Count > 0)
            {
                additional["queue"] = new SparklineSeriesSlice(trimmedQueue, primaryStartIndex);
            }

            if (synthesizedValues)
            {
                additional["values"] = new SparklineSeriesSlice(trimmedPrimary, primaryStartIndex);
            }

            var sparkline = NodeSparklineData.Create(
                trimmedPrimary,
                trimmedUtilization,
                trimmedErrorRate,
                trimmedQueue,
                primaryStartIndex,
                successSeries is not null ? 0d : null,
                successSeries is not null ? 1d : null,
                additional);

            result[node.Id] = sparkline;
        }

        if (topologyGraph is not null)
        {
            foreach (var topoNode in topologyGraph.Nodes)
            {
                if (result.ContainsKey(topoNode.Id))
                {
                    continue;
                }

                var distributionSlices = CreateDistributionSlices(topoNode.Id, topoNode.Semantics?.Distribution, selectedBin);

                var inlineValues = topoNode.Semantics?.InlineValues;
                if (inlineValues is not null && inlineValues.Count > 0)
                {
                    var nullableSeries = inlineValues.Select(value => (double?)value).ToArray();
                    var anchor = Math.Clamp(selectedBin, 0, nullableSeries.Length - 1);
                    var trimmedInline = TrimSeriesAt(nullableSeries, SparklinePointLimit, anchor);
                    if (trimmedInline.Count == 0)
                    {
                        continue;
                    }

                    var startIndex = anchor + 1 - trimmedInline.Count;
                    var additional = new Dictionary<string, SparklineSeriesSlice>(StringComparer.OrdinalIgnoreCase);
                    if (distributionSlices is not null)
                    {
                        foreach (var pair in distributionSlices)
                        {
                            additional[pair.Key] = pair.Value;
                        }
                    }

                    var inlineSlice = new SparklineSeriesSlice(trimmedInline, startIndex);
                    additional["values"] = inlineSlice;
                    additional[topoNode.Id] = inlineSlice;
                    additional[$"series:{topoNode.Id}"] = inlineSlice;

                    var sparkline = NodeSparklineData.Create(
                        trimmedInline,
                        Array.Empty<double?>(),
                        Array.Empty<double?>(),
                        Array.Empty<double?>(),
                        startIndex,
                        explicitMin: null,
                        explicitMax: null,
                        additionalSeries: additional);

                    result[topoNode.Id] = sparkline;
                    continue;
                }

                if (distributionSlices is not null &&
                    distributionSlices.TryGetValue("probability", out var probabilitySlice) &&
                    probabilitySlice.Values.Count > 0)
                {
                    var probabilityArray = probabilitySlice.Values as double?[] ?? probabilitySlice.Values.ToArray();
                    var sparkline = NodeSparklineData.Create(
                        probabilityArray,
                        Array.Empty<double?>(),
                        Array.Empty<double?>(),
                        Array.Empty<double?>(),
                        probabilitySlice.StartIndex,
                        explicitMin: 0d,
                        explicitMax: 1d,
                        additionalSeries: distributionSlices);

                    result[topoNode.Id] = sparkline;
                    continue;
                }

                if (IsExpressionKind(topoNode.Kind))
                {
                    missing.Add(topoNode.Id);
                }
            }
        }

        nodesMissingSparkline = missing;

        if (Logger is not null)
        {
            foreach (var nodeId in missing)
            {
                if (IsExpressionKind(GetNodeKind(nodeId)) && loggedMissingExpressionSeries.Add(nodeId))
                {
                    Logger.LogWarning("Expression node {NodeId} has no series for selected range.", nodeId);
                }
            }
        }

        nodeSparklines = result;
        EnsureInspectorVisibility();
    }

    private Dictionary<string, SparklineSeriesSlice>? CreateDistributionSlices(string nodeId, TopologyNodeDistribution? distribution, int selectedBin)
    {
        if (distribution is null ||
            distribution.Values is not { Count: > 0 } ||
            distribution.Probabilities is not { Count: > 0 })
        {
            return null;
        }

        var length = Math.Min(distribution.Values.Count, distribution.Probabilities.Count);
        if (length == 0)
        {
            return null;
        }

        var probabilities = new double?[length];
        var supportValues = new double?[length];
        var hasProbability = false;
        for (var i = 0; i < length; i++)
        {
            var probability = distribution.Probabilities[i];
            var support = distribution.Values[i];

            if (!double.IsFinite(probability) || probability < 0)
            {
                probabilities[i] = 0d;
            }
            else
            {
                probabilities[i] = probability;
                if (probability > 0)
                {
                    hasProbability = true;
                }
            }

            supportValues[i] = double.IsFinite(support) ? support : null;
        }

        if (!hasProbability)
        {
            return null;
        }

        var anchor = Math.Clamp(selectedBin, 0, probabilities.Length - 1);
        var trimmedProbabilities = TrimSeriesAt(probabilities, SparklinePointLimit, anchor);
        if (trimmedProbabilities.Count == 0)
        {
            return null;
        }

        var trimmedValues = TrimSeriesAt(supportValues, SparklinePointLimit, anchor, trimmedProbabilities.Count);
        var probabilityArray = trimmedProbabilities as double?[] ?? trimmedProbabilities.ToArray();
        var valueArray = trimmedValues as double?[] ?? trimmedValues.ToArray();
        var probabilityStartIndex = anchor + 1 - probabilityArray.Length;

        var additional = new Dictionary<string, SparklineSeriesSlice>(StringComparer.OrdinalIgnoreCase)
        {
            ["distribution"] = new SparklineSeriesSlice(probabilityArray, probabilityStartIndex),
            ["probability"] = new SparklineSeriesSlice(probabilityArray, probabilityStartIndex),
            [nodeId] = new SparklineSeriesSlice(probabilityArray, probabilityStartIndex),
            [$"series:{nodeId}"] = new SparklineSeriesSlice(probabilityArray, probabilityStartIndex)
        };

        var expectation = ComputePmfExpectation(distribution);
        if (expectation.HasValue)
        {
            var expectationSeries = Enumerable.Repeat((double?)expectation.Value, probabilityArray.Length).ToArray();
            additional["values"] = new SparklineSeriesSlice(expectationSeries, probabilityStartIndex);
            additional["expectation"] = new SparklineSeriesSlice(expectationSeries, probabilityStartIndex);
        }

        return additional;
    }

internal sealed record InspectorMetricBlock(
    string Title,
    NodeSparklineData? Sparkline,
    string Stroke,
    bool IsPlaceholder,
    string? Placeholder,
    string? AriaLabel,
    InspectorValueFormat ValueFormat,
    string? SeriesKey)
    {
        public static InspectorMetricBlock FromSparkline(
            string title,
            NodeSparklineData data,
            string stroke,
            string? ariaLabel = null,
            InspectorValueFormat valueFormat = InspectorValueFormat.Number,
            string? seriesKey = null) =>
            new(title, data, stroke, false, null, ariaLabel, valueFormat, seriesKey);

        public static InspectorMetricBlock CreatePlaceholder(string title, string message, InspectorValueFormat valueFormat = InspectorValueFormat.Number, string? seriesKey = null) =>
            new(title, null, "#CBD5E1", true, message, null, valueFormat, seriesKey);
    }

    internal sealed record InspectorBinMetric(string Label, string Value);

    private IReadOnlyList<InspectorMetricBlock> BuildInspectorMetricBlocks(string? nodeId)
    {
        if (string.IsNullOrWhiteSpace(nodeId))
        {
            return Array.Empty<InspectorMetricBlock>();
        }

        nodeSparklines.TryGetValue(nodeId, out var baseSparkline);
        var topoNode = FindTopologyNode(nodeId);
        var nodeKind = topoNode?.Kind;
        var kindKey = string.IsNullOrWhiteSpace(nodeKind) ? "unknown" : nodeKind!;

        var blocks = new List<InspectorMetricBlock>();

        string Label(string fallback, params string[] keys) =>
            ResolveMetricLabel(topoNode, fallback, keys);

        InspectorMetricBlock CreatePlaceholder(string title, InspectorValueFormat valueFormat = InspectorValueFormat.Number, string? seriesKey = null)
        {
            if (Logger is not null && loggedMissingMetricKinds.Add(kindKey))
            {
                Logger.LogWarning("Model does not include required series data for {NodeKind} inspector metrics (missing {Metric}).", kindKey, title);
            }

            return InspectorMetricBlock.CreatePlaceholder(title, InspectorMissingSeriesMessage, valueFormat, seriesKey);
        }

        InspectorMetricBlock CreateSparkline(
            string title,
            NodeSparklineData data,
            string? ariaLabel = null,
            string? strokeOverride = null,
            InspectorValueFormat valueFormat = InspectorValueFormat.Number,
            string? seriesKey = null)
            => InspectorMetricBlock.FromSparkline(
                title,
                data,
                strokeOverride ?? ResolveInspectorSparklineStroke(data),
                ariaLabel ?? $"{title} sparkline",
                valueFormat,
                seriesKey);

        void AddRequired(
            string title,
            string key,
            double? min = null,
            double? max = null,
            string? ariaLabel = null,
            string? strokeOverride = null,
            InspectorValueFormat valueFormat = InspectorValueFormat.Number,
            string? seriesKeyOverride = null)
        {
            if (baseSparkline is null)
            {
                var seriesKey = seriesKeyOverride ?? key;
                blocks.Add(CreatePlaceholder(title, valueFormat, seriesKey));
                return;
            }

            var sparkline = BuildInspectorSparkline(baseSparkline, key, min, max);
            if (sparkline is null)
            {
                var seriesKey = seriesKeyOverride ?? key;
                blocks.Add(CreatePlaceholder(title, valueFormat, seriesKey));
                return;
            }

            var resolvedSeriesKey = seriesKeyOverride ?? key;
            blocks.Add(CreateSparkline(title, sparkline, ariaLabel, strokeOverride, valueFormat, resolvedSeriesKey));
        }

        void AddOptional(
            string title,
            string key,
            double? min = null,
            double? max = null,
            string? ariaLabel = null,
            string? strokeOverride = null,
            InspectorValueFormat valueFormat = InspectorValueFormat.Number,
            string? seriesKeyOverride = null)
        {
            if (baseSparkline is null)
            {
                return;
            }

            var sparkline = BuildInspectorSparkline(baseSparkline, key, min, max);
            if (sparkline is null)
            {
                return;
            }

            var seriesKey = seriesKeyOverride ?? key;
            blocks.Add(CreateSparkline(title, sparkline, ariaLabel, strokeOverride, valueFormat, seriesKey));
        }

        if (IsComputedKind(nodeKind))
        {
            if (IsPmfKind(nodeKind))
            {
                var probabilitySparkline = BuildPmfSparkline(topoNode, baseSparkline);
                if (probabilitySparkline is not null)
                {
                    blocks.Add(InspectorMetricBlock.FromSparkline("Probability", probabilitySparkline, "#94A3B8", seriesKey: "probability"));
                }
                else
                {
                    blocks.Add(CreatePlaceholder("Probability", seriesKey: "probability"));
                }

                var valueSparkline = baseSparkline is not null ? BuildInspectorSparkline(baseSparkline, "values") : null;
                blocks.Add(valueSparkline is not null ? CreateSparkline("Values", valueSparkline, strokeOverride: "#94A3B8", seriesKey: "values") : CreatePlaceholder("Values", seriesKey: "values"));

                return blocks;
            }

            if (baseSparkline is not null)
            {
                var outputSparkline = BuildInspectorSparkline(baseSparkline, "values");
                blocks.Add(outputSparkline is not null ? CreateSparkline("Output", outputSparkline, strokeOverride: "#94A3B8", seriesKey: "values") : CreatePlaceholder("Output", seriesKey: "values"));
            }
            else
            {
                blocks.Add(CreatePlaceholder("Output", seriesKey: "values"));
            }

            AddOptional("Error rate", "errorRate", 0d, 1d, valueFormat: InspectorValueFormat.Percent, seriesKeyOverride: "errorRate");

            return blocks;
        }

        if (IsQueueKind(nodeKind))
        {
            AddRequired(Label("Queue depth", "queue", "queueDepth"), "queue", 0d);
            AddRequired("Latency", "latencyMinutes", 0d);
            AddRequired(Label("Arrivals", "arrivals"), "arrivals", 0d);
            AddRequired(Label("Served", "served"), "served", 0d);
            return blocks;
        }

        var showRetryMetrics = overlaySettings.ShowRetryMetrics;
        var hasAttemptsSeries = baseSparkline?.Series.ContainsKey("attempts") == true;
        var hasFailuresSeries = baseSparkline?.Series.ContainsKey("failures") == true;
        var hasRetryEchoSeries = baseSparkline?.Series.ContainsKey("retryEcho") == true;
        var hasServedSeries = baseSparkline?.Series.ContainsKey("served") == true || AllowsFallback("served");

        if (showRetryMetrics && (hasAttemptsSeries || !string.IsNullOrWhiteSpace(topoNode?.Semantics?.Attempts)))
        {
            AddRequired(Label("Attempts", "attempts"), "attempts", 0d, seriesKeyOverride: "attempts");
        }

        if (hasServedSeries)
        {
            AddRequired(Label("Served", "served"), "served", 0d, seriesKeyOverride: "served");
        }

        if (showRetryMetrics && (hasFailuresSeries || !string.IsNullOrWhiteSpace(topoNode?.Semantics?.Failures)))
        {
            AddRequired(Label("Failed retries", "failures"), "failures", 0d, seriesKeyOverride: "failures");
        }

        if (showRetryMetrics && (hasRetryEchoSeries || !string.IsNullOrWhiteSpace(topoNode?.Semantics?.RetryEcho)))
        {
            AddRequired(Label("Retry echo", "retryEcho", "retry_echo", "retry"), "retryEcho", 0d, seriesKeyOverride: "retryEcho");
        }

        AddRequired("Retry tax", "retryTax", 0d, 1d, valueFormat: InspectorValueFormat.Percent, seriesKeyOverride: "retryTax");

        AddRequired("Success rate", "successRate", 0d, 1d, valueFormat: InspectorValueFormat.Percent);
        AddRequired("Utilization", "utilization", 0d, 1d, valueFormat: InspectorValueFormat.Percent);
        AddRequired("Service time", "serviceTimeMs", 0d, seriesKeyOverride: "serviceTimeMs");
        AddRequired("Latency", "latencyMinutes", 0d);
        AddRequired("Error rate", "errorRate", 0d, 1d, valueFormat: InspectorValueFormat.Percent);
        AddOptional(Label("Errors", "errors"), "errors", 0d, ariaLabel: "Errors sparkline");

        return blocks;
    }

    private IReadOnlyList<InspectorBinMetric> BuildInspectorBinMetrics(string? nodeId, NodeBinMetrics? metrics)
    {
        if (string.IsNullOrWhiteSpace(nodeId) || metrics is null)
        {
            return Array.Empty<InspectorBinMetric>();
        }

        var rows = new List<InspectorBinMetric>();
        var topoNode = FindTopologyNode(nodeId);
        var raw = metrics.RawMetrics;

        string Label(string fallback, params string[] keys) =>
            FormatSemanticLabelWithAlias(fallback, TryResolveAlias(topoNode, keys));

        void AddRaw(string fallback, string key, InspectorValueFormat format = InspectorValueFormat.Number, string? unit = null)
        {
            if (raw is null || !raw.TryGetValue(key, out var value) || !value.HasValue)
            {
                return;
            }

            rows.Add(new InspectorBinMetric(Label(fallback, key), FormatBinValue(value, format, unit)));
        }

        void AddDerived(string fallback, double? value, InspectorValueFormat format = InspectorValueFormat.Number, string? unit = null, params string[] aliasKeys)
        {
            if (!value.HasValue)
            {
                return;
            }

            rows.Add(new InspectorBinMetric(Label(fallback, aliasKeys), FormatBinValue(value, format, unit)));
        }

        AddRaw("Arrivals", "arrivals");
        AddRaw("Served", "served");
        AddRaw("Errors", "errors");
        AddRaw("Attempts", "attempts");
        AddRaw("Failed retries", "failures");
        AddRaw("Retry echo", "retryEcho");
        AddRaw("Queue depth", "queue");
        AddRaw("Capacity", "capacity");

        AddDerived("Success rate", metrics.SuccessRate, InspectorValueFormat.Percent);
        AddDerived("Utilization", metrics.Utilization, InspectorValueFormat.Percent);
        AddDerived("Error rate", metrics.ErrorRate, InspectorValueFormat.Percent);
        AddDerived("Latency", metrics.LatencyMinutes, InspectorValueFormat.Number, "min");
        AddDerived("Service time", metrics.ServiceTimeMs, InspectorValueFormat.Number, "ms");
        AddDerived("Retry tax", metrics.RetryTax, InspectorValueFormat.Percent);

        return rows;
    }

    private NodeSparklineData? BuildInspectorSparkline(NodeSparklineData sparkline, string primaryKey, double? explicitMin = null, double? explicitMax = null)
    {
        if (sparkline is null)
        {
            return null;
        }

        var slice = ResolveMetricSeriesSlice(sparkline, primaryKey);
        if (slice is null && AllowsFallback(primaryKey))
        {
            slice = ResolveFallbackSlice(sparkline, primaryKey);
        }
        if (slice is null || slice.Values.Count == 0 || !slice.Values.Any(v => v.HasValue && double.IsFinite(v.Value)))
        {
            return null;
        }

        var values = slice.Values as double?[] ?? slice.Values.ToArray();

        var additional = new Dictionary<string, SparklineSeriesSlice>(StringComparer.OrdinalIgnoreCase)
        {
            [primaryKey] = new SparklineSeriesSlice(values, slice.StartIndex)
        };

        return NodeSparklineData.Create(
            values,
            Array.Empty<double?>(),
            Array.Empty<double?>(),
            Array.Empty<double?>(),
            slice.StartIndex,
            explicitMin,
            explicitMax,
            additionalSeries: additional);
    }

    private static SparklineSeriesSlice? ResolveMetricSeriesSlice(NodeSparklineData sparkline, string primaryKey)
    {
        if (sparkline.Series.TryGetValue(primaryKey, out var slice))
        {
            return slice;
        }

        return primaryKey switch
        {
            "queue" when sparkline.Series.TryGetValue("queueDepth", out var queueSlice) => queueSlice,
            "queueDepth" when sparkline.Series.TryGetValue("queue", out var queueAlt) => queueAlt,
            "latency" when sparkline.Series.TryGetValue("latencyMinutes", out var latencySlice) => latencySlice,
            "latencyMinutes" when sparkline.Series.TryGetValue("latency", out var latencyAlt) => latencyAlt,
            "values" when sparkline.Series.TryGetValue("output", out var outputSlice) => outputSlice,
            "output" when sparkline.Series.TryGetValue("values", out var valuesSlice) => valuesSlice,
            _ => null
        };
    }

    private static SparklineSeriesSlice? ResolveFallbackSlice(NodeSparklineData sparkline, string primaryKey)
    {
        return primaryKey switch
        {
            "values" => CreateSlice(sparkline.Values, sparkline.StartIndex),
            "utilization" => CreateSlice(sparkline.Utilization, sparkline.StartIndex),
            "errorRate" => CreateSlice(sparkline.ErrorRate, sparkline.StartIndex),
            "queue" or "queueDepth" => CreateSlice(sparkline.QueueDepth, sparkline.StartIndex),
            _ => null
        };
    }

    private static bool AllowsFallback(string key)
    {
        return key switch
        {
            "values" => true,
            "utilization" => true,
            "errorRate" => true,
            "queue" => true,
            "queueDepth" => true,
            "latency" => true,
            "latencyMinutes" => true,
            "arrivals" => true,
            "served" => true,
            _ => false
        };
    }

    private static SparklineSeriesSlice? CreateSlice(IReadOnlyList<double?> values, int startIndex)
    {
        if (values is null || values.Count == 0)
        {
            return null;
        }

        return new SparklineSeriesSlice(values, startIndex);
    }

    private NodeSparklineData? BuildPmfSparkline(TopologyNode? node, NodeSparklineData? inspectorSparkline)
    {
        if (inspectorSparkline is not null && inspectorSparkline.Series.TryGetValue("probability", out var probabilitySlice))
        {
            if (probabilitySlice.Values.Count == 0)
            {
                return null;
            }

            var array = probabilitySlice.Values as double?[] ?? probabilitySlice.Values.ToArray();
            return NodeSparklineData.Create(
                array,
                Array.Empty<double?>(),
                Array.Empty<double?>(),
                Array.Empty<double?>(),
                probabilitySlice.StartIndex,
                explicitMin: 0d,
                explicitMax: 1d);
        }

        if (node is null)
        {
            return null;
        }

        var distribution = node.Semantics?.Distribution;
        if (distribution is null || distribution.Values.Count == 0 || distribution.Probabilities.Count == 0)
        {
            return null;
        }

        var length = Math.Min(distribution.Values.Count, distribution.Probabilities.Count);
        if (length == 0)
        {
            return null;
        }

        var series = new double?[length];
        var hasValue = false;
        for (var i = 0; i < length; i++)
        {
            var probability = distribution.Probabilities[i];
            if (!double.IsFinite(probability) || probability < 0)
            {
                series[i] = 0d;
            }
            else
            {
                series[i] = probability;
                if (probability > 0)
                {
                    hasValue = true;
                }
            }
        }

        if (!hasValue)
        {
            return null;
        }

        return NodeSparklineData.Create(
            series,
            Array.Empty<double?>(),
            Array.Empty<double?>(),
            Array.Empty<double?>(),
            inspectorSparkline?.StartIndex ?? 0,
            explicitMin: 0d,
            explicitMax: 1d,
            additionalSeries: new Dictionary<string, SparklineSeriesSlice>(StringComparer.OrdinalIgnoreCase)
            {
                ["distribution"] = new SparklineSeriesSlice(series, inspectorSparkline?.StartIndex ?? 0)
            });
    }

    private void CloseInspector()
    {
        inspectorOpen = false;
        inspectorNodeId = null;
        inspectorPinned = false;
        inspectorMetricsExpanded = false;
        ClearInspectorEdgeHighlights();
        canvasComponent?.ClearFocus();
        StateHasChanged();
    }

    private void ToggleInspectorMetricsExpanded()
    {
        inspectorMetricsExpanded = !inspectorMetricsExpanded;
    }

    private static double?[]? SelectPrimarySeries(IReadOnlyDictionary<string, double?[]> series)
    {
        if (series is null || series.Count == 0)
        {
            return null;
        }

        static double?[]? Resolve(IReadOnlyDictionary<string, double?[]> dict, string key)
            => dict.TryGetValue(key, out var value) && value is { Length: > 0 } ? value : null;

        var preferredKeys = new[]
        {
            "values",
            "demand",
            "arrivals",
            "served",
            "capacity",
            "output",
            "utilization"
        };

        foreach (var key in preferredKeys)
        {
            var candidate = Resolve(series, key);
            if (candidate is not null)
            {
                return candidate;
            }
        }

        return series.Values.FirstOrDefault(value => value is { Length: > 0 });
    }

    private static bool IsExpressionKind(string? kind) =>
        !string.IsNullOrWhiteSpace(kind) &&
        (string.Equals(kind, "expr", StringComparison.OrdinalIgnoreCase) ||
         string.Equals(kind, "expression", StringComparison.OrdinalIgnoreCase));

    private static bool IsConstKind(string? kind) =>
        !string.IsNullOrWhiteSpace(kind) &&
        string.Equals(kind, "const", StringComparison.OrdinalIgnoreCase);

    private static bool IsPmfKind(string? kind) =>
        !string.IsNullOrWhiteSpace(kind) &&
        string.Equals(kind, "pmf", StringComparison.OrdinalIgnoreCase);

    private static bool IsComputedKind(string? kind) =>
        IsExpressionKind(kind) || IsConstKind(kind) || IsPmfKind(kind);

    private static bool IsQueueKind(string? kind) =>
        !string.IsNullOrWhiteSpace(kind) &&
        string.Equals(kind, "queue", StringComparison.OrdinalIgnoreCase);

    private static string FormatNodeKindLabel(string? kind)
    {
        if (string.IsNullOrWhiteSpace(kind))
        {
            return "Unknown";
        }

        return kind.ToLowerInvariant() switch
        {
            "expr" or "expression" => "Expression",
            "const" or "constant" => "Const",
            "pmf" => "PMF",
            _ => CultureInfo.InvariantCulture.TextInfo.ToTitleCase(kind)
        };
    }

    private TopologyNode? FindTopologyNode(string nodeId)
    {
        if (topologyGraph is null || string.IsNullOrWhiteSpace(nodeId))
        {
            return null;
        }

        return topologyGraph.Nodes.FirstOrDefault(n => string.Equals(n.Id, nodeId, StringComparison.OrdinalIgnoreCase));
    }

    private string? GetNodeKind(string nodeId) => FindTopologyNode(nodeId)?.Kind;

    private static string ResolveMetricLabel(TopologyNode? node, string fallback, params string[] canonicalKeys)
    {
        var alias = TryResolveAlias(node, canonicalKeys);
        return FormatSemanticLabelWithAlias(fallback, alias);
    }

    private static string FormatSemanticLabelWithAlias(string canonicalLabel, string? alias)
    {
        if (string.IsNullOrWhiteSpace(alias))
        {
            return canonicalLabel;
        }

        if (string.Equals(alias, canonicalLabel, StringComparison.OrdinalIgnoreCase))
        {
            return canonicalLabel;
        }

        return $"{canonicalLabel}: {alias}";
    }

    private static string? TryResolveAlias(TopologyNode? node, params string[] canonicalKeys)
    {
        if (node?.Semantics?.Aliases is null || node.Semantics.Aliases.Count == 0 || canonicalKeys is null || canonicalKeys.Length == 0)
        {
            return null;
        }

        foreach (var key in canonicalKeys.SelectMany(BuildAliasKeyCandidates))
        {
            if (string.IsNullOrWhiteSpace(key))
            {
                continue;
            }

            if (node.Semantics.Aliases.TryGetValue(key, out var alias) && !string.IsNullOrWhiteSpace(alias))
            {
                return alias;
            }
        }

        return null;
    }

    private static string? GetMetadataValue(IReadOnlyDictionary<string, string>? metadata, string key)
    {
        if (metadata is null)
        {
            return null;
        }

        return metadata.TryGetValue(key, out var value) ? value : null;
    }

    private static string[] BuildAliasKeyCandidates(string? field)
    {
        if (string.IsNullOrWhiteSpace(field))
        {
            return Array.Empty<string>();
        }

        var trimmed = field.Trim();
        var keys = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { trimmed };
        var lower = trimmed.ToLowerInvariant();
        keys.Add(lower);

        var noUnderscore = trimmed.Replace("_", string.Empty, StringComparison.OrdinalIgnoreCase);
        if (!string.Equals(noUnderscore, trimmed, StringComparison.Ordinal))
        {
            keys.Add(noUnderscore);
        }

        if (string.Equals(noUnderscore, "retryecho", StringComparison.OrdinalIgnoreCase))
        {
            keys.Add("retryEcho");
            keys.Add("retry");
        }

        if (string.Equals(noUnderscore, "queue", StringComparison.OrdinalIgnoreCase))
        {
            keys.Add("queueDepth");
        }

        return keys.ToArray();
    }

    private static string? ExtractNodeReference(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return value;
        }

        var trimmed = value.Trim();
        var colonIndex = trimmed.IndexOf(':');
        return colonIndex < 0 ? trimmed : trimmed[..colonIndex].Trim();
    }

    private static double? SampleSparklineAt(NodeSparklineData? sparkline, int bin)
    {
        if (sparkline is null)
        {
            return null;
        }

        var index = bin - sparkline.StartIndex;
        if (index < 0 || index >= sparkline.Values.Count)
        {
            return null;
        }

        var value = sparkline.Values[index];
        if (!value.HasValue)
        {
            return null;
        }

        var sample = value.Value;
        return double.IsNaN(sample) || double.IsInfinity(sample) ? null : sample;
    }

    private static double? ComputePmfExpectation(TopologyNodeDistribution? distribution)
    {
        if (distribution is null || distribution.Values.Count == 0 || distribution.Probabilities.Count == 0)
        {
            return null;
        }

        var length = Math.Min(distribution.Values.Count, distribution.Probabilities.Count);
        double total = 0d;
        double totalProbability = 0d;

        for (var i = 0; i < length; i++)
        {
            var value = distribution.Values[i];
            var probability = distribution.Probabilities[i];

            if (!double.IsFinite(value) || !double.IsFinite(probability) || probability < 0d)
            {
                continue;
            }

            total += value * probability;
            totalProbability += probability;
        }

        if (totalProbability <= 0d)
        {
            return null;
        }

        return total / totalProbability;
    }

    private static (double? Probability, double? Value) ComputePmfMode(TopologyNodeDistribution? distribution)
    {
        if (distribution is null || distribution.Values.Count == 0 || distribution.Probabilities.Count == 0)
        {
            return (null, null);
        }

        var length = Math.Min(distribution.Values.Count, distribution.Probabilities.Count);
        var maxProbability = double.NegativeInfinity;
        double? modeValue = null;

        for (var i = 0; i < length; i++)
        {
            var probability = distribution.Probabilities[i];
            var value = distribution.Values[i];

            if (!double.IsFinite(probability) || probability < 0)
            {
                continue;
            }

            if (probability > maxProbability)
            {
                maxProbability = probability;
                modeValue = double.IsFinite(value) ? value : null;
            }
        }

        if (!double.IsFinite(maxProbability) || maxProbability < 0)
        {
            return (null, null);
        }

        return (maxProbability, modeValue);
    }

    private string ResolveInspectorSparklineStroke(NodeSparklineData? sparkline)
    {
        if (sparkline is null)
        {
            return "#CBD5E1";
        }

        var sample = SampleSparklineAt(sparkline, selectedBin);
        if (!sample.HasValue)
        {
            var fallbackSample = sparkline.Values.FirstOrDefault(static v => v.HasValue);
            if (fallbackSample.HasValue)
            {
                sample = fallbackSample;
            }
            else
            {
                return "#CBD5E1";
            }
        }

        var thresholds = ColorScale.ColorThresholds.FromOverlay(overlaySettings);
        var basis = overlaySettings.ColorBasis;
        var metrics = basis switch
        {
            TopologyColorBasis.Utilization => new NodeBinMetrics(null, sample, null, null, null, null),
            TopologyColorBasis.Errors => new NodeBinMetrics(null, null, sample, null, null, null),
            TopologyColorBasis.Queue => new NodeBinMetrics(null, null, null, sample, null, null),
            TopologyColorBasis.ServiceTime => new NodeBinMetrics(null, null, null, null, null, null, ServiceTimeMs: sample),
            _ => new NodeBinMetrics(sample, null, null, null, null, null)
        };

        var color = ColorScale.GetFill(metrics, basis, thresholds);
        return string.IsNullOrWhiteSpace(color) ? "#CBD5E1" : color;
    }

    private string GetRunInfo()
    {
        return string.Empty;
    }

    private string GetTemplateTitle()
    {
        if (!string.IsNullOrWhiteSpace(runDisplayName))
        {
            return runDisplayName!;
        }

        return "Time-Travel Topology";
    }

    private static double?[]? BuildSuccessRateSeries(TimeTravelNodeSeriesDto node)
    {
        if (node is null)
        {
            return null;
        }

        var throughput = TryGetSeries(node, "throughputRatio");
        var arrivals = TryGetSeries(node, "arrivals");
        var served = TryGetSeries(node, "served");

        var length = Math.Max(
            throughput?.Length ?? 0,
            Math.Max(arrivals?.Length ?? 0, served?.Length ?? 0));

        if (length <= 0)
        {
            return null;
        }

        var values = new double?[length];
        for (var i = 0; i < length; i++)
        {
            var throughputValue = GetValueAt(throughput, i);
            if (throughputValue.HasValue)
            {
                values[i] = throughputValue;
                continue;
            }

            var arrivalsValue = GetValueAt(arrivals, i);
            var servedValue = GetValueAt(served, i);

            if (arrivalsValue.HasValue && arrivalsValue.Value > 0 && servedValue.HasValue)
            {
                values[i] = servedValue.Value / arrivalsValue.Value;
            }
            else if ((!arrivalsValue.HasValue || arrivalsValue.Value <= 0) && servedValue.HasValue)
            {
                values[i] = servedValue.Value > 0 ? 1d : 0d;
            }
            else
            {
                values[i] = null;
            }
        }

        return values;
    }

    private static double?[]? BuildErrorRateSeries(TimeTravelNodeSeriesDto node)
    {
        if (node is null)
        {
            return null;
        }

        var errors = TryGetSeries(node, "errors");
        var arrivals = TryGetSeries(node, "arrivals");
        var served = TryGetSeries(node, "served");

        var length = Math.Max(errors?.Length ?? 0, Math.Max(arrivals?.Length ?? 0, served?.Length ?? 0));
        if (length <= 0)
        {
            return null;
        }

        var values = new double?[length];
        for (var i = 0; i < length; i++)
        {
            var errorsValue = GetValueAt(errors, i);
            if (!errorsValue.HasValue)
            {
                values[i] = null;
                continue;
            }

            var denominator = GetValueAt(arrivals, i) ?? GetValueAt(served, i);
            if (denominator.HasValue && denominator.Value > 0)
            {
                values[i] = errorsValue.Value / denominator.Value;
            }
            else
            {
                values[i] = errorsValue.Value > 0 ? 1d : 0d;
            }
        }

        return values;
    }

    private static double?[]? TryGetSeries(TimeTravelNodeSeriesDto node, string key)
    {
        if (node.Series is null || string.IsNullOrWhiteSpace(key))
        {
            return null;
        }

        if (node.Series.TryGetValue(key, out var series) && series is not null && series.Length > 0)
        {
            return series;
        }

        return null;
    }

    private IReadOnlyList<InspectorDependencyViewModel> BuildInspectorDependencies(string nodeId)
    {
        if (topologyGraph?.Edges is null || string.IsNullOrWhiteSpace(nodeId))
        {
            return Array.Empty<InspectorDependencyViewModel>();
        }

        var matches = new List<InspectorDependencyViewModel>();
        foreach (var edge in topologyGraph.Edges)
        {
            var targetNodeId = ExtractNodeReference(edge.To);
            if (!string.Equals(targetNodeId, nodeId, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            if (!string.Equals(edge.EdgeType, "dependency", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            if (!IsDependencyFieldEnabled(edge.Field))
            {
                continue;
            }

            var edgeId = edge.Id ?? $"{edge.From}->{edge.To}:{edge.Field}";
            var sourceNodeReference = ExtractNodeReference(edge.From);
            if (string.IsNullOrWhiteSpace(sourceNodeReference))
            {
                continue;
            }

            var sourceNode = FindTopologyNode(sourceNodeReference);
            var label = FormatDependencyFieldLabel(edge.Field, sourceNode);
            var source = edge.From ?? "Unknown";
            var order = ResolveDependencyFieldOrder(edge.Field);
            matches.Add(new InspectorDependencyViewModel(edgeId, label, source, order));
        }

        if (matches.Count == 0)
        {
            return Array.Empty<InspectorDependencyViewModel>();
        }

        return matches
            .OrderBy(match => match.Order)
            .ThenBy(match => match.Source, StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    private static int ResolveDependencyFieldOrder(string? field)
    {
        return field?.ToLowerInvariant() switch
        {
            "arrivals" => 0,
            "served" => 1,
            "attempts" => 2,
            "failures" => 3,
            "retryecho" or "retry_echo" => 4,
            "errors" => 5,
            "queue" => 6,
            "capacity" => 7,
            "expr" or "expression" => 8,
            _ => 9
        };
    }

    private static string FormatDependencyFieldLabel(string? field, TopologyNode? sourceNode)
    {
        var fallback = field?.ToLowerInvariant() switch
        {
            "arrivals" => "Arrivals",
            "served" => "Served",
            "errors" => "Errors",
            "attempts" => "Attempts",
            "failures" => "Failures",
            "retryecho" or "retry_echo" => "Retry echo",
            "queue" => "Queue depth",
            "capacity" => "Capacity",
            "expr" or "expression" => "Expression",
            _ => string.IsNullOrWhiteSpace(field)
                ? "Dependency"
                : CultureInfo.InvariantCulture.TextInfo.ToTitleCase(field.ToLowerInvariant())
        };

        var aliasKeys = BuildAliasKeyCandidates(field);
        var alias = TryResolveAlias(sourceNode, aliasKeys);
        return FormatSemanticLabelWithAlias(fallback, alias);
    }

    private bool IsDependencyFieldEnabled(string? field)
    {
        var key = field?.ToLowerInvariant();
        return key switch
        {
            "arrivals" => overlaySettings.ShowArrivalsDependencies,
            "served" => overlaySettings.ShowServedDependencies,
            "errors" => overlaySettings.ShowErrorsDependencies,
            "queue" => overlaySettings.ShowQueueDependencies,
            "capacity" => overlaySettings.ShowCapacityDependencies,
            "expr" or "expression" => overlaySettings.ShowExpressionDependencies,
            "attempts" or "failures" or "retryecho" or "retry_echo" => overlaySettings.ShowRetryMetrics,
            _ => true
        };
    }

    private bool IsDependencyHighlighted(string edgeId)
    {
        if (string.IsNullOrWhiteSpace(edgeId))
        {
            return false;
        }

        return string.Equals(inspectorHoveredEdgeId, edgeId, StringComparison.OrdinalIgnoreCase)
            || string.Equals(inspectorPinnedEdgeId, edgeId, StringComparison.OrdinalIgnoreCase)
            || string.Equals(canvasHoveredEdgeId, edgeId, StringComparison.OrdinalIgnoreCase);
    }

    private async Task OnInspectorDependencyHover(string? edgeId)
    {
        if (string.Equals(inspectorHoveredEdgeId, edgeId, StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        inspectorHoveredEdgeId = edgeId;
        if (canvasComponent is not null)
        {
            await canvasComponent.SetInspectorEdgeHoverAsync(edgeId);
        }
        StateHasChanged();
    }

    private async Task OnInspectorDependencyClick(string? edgeId)
    {
        inspectorPinnedEdgeId = edgeId;
        if (canvasComponent is not null)
        {
            await canvasComponent.FocusEdgeAsync(edgeId, centerOnEdge: true);
        }
    }

    private Task OnCanvasEdgeHovered(string? edgeId)
    {
        if (string.Equals(canvasHoveredEdgeId, edgeId, StringComparison.OrdinalIgnoreCase))
        {
            return Task.CompletedTask;
        }

        canvasHoveredEdgeId = edgeId;
        if (!inspectorOpen)
        {
            return Task.CompletedTask;
        }

        StateHasChanged();
        return Task.CompletedTask;
    }

    private void ClearInspectorEdgeHighlights()
    {
        inspectorHoveredEdgeId = null;
        inspectorPinnedEdgeId = null;
        canvasHoveredEdgeId = null;
        if (canvasComponent is not null)
        {
            _ = canvasComponent.SetInspectorEdgeHoverAsync(null);
            _ = canvasComponent.FocusEdgeAsync(null, centerOnEdge: false);
        }
    }

    private static double? GetValueAt(double?[]? series, int index)
    {
        if (series is null || index < 0 || index >= series.Length)
        {
            return null;
        }

        return series[index];
    }

    private static IReadOnlyList<double?> TrimSeries(double?[]? source, int limit, int fallbackLength = 0)
    {
        if (source is null || source.Length == 0)
        {
            return fallbackLength == 0
                ? Array.Empty<double?>()
                : Enumerable.Repeat<double?>(null, fallbackLength).ToArray();
        }

        if (source.Length <= limit)
        {
            return source.ToArray();
        }

        var start = Math.Max(0, source.Length - limit);
        var result = new double?[limit];
        Array.Copy(source, start, result, 0, limit);
        return result;
    }

private static IReadOnlyList<double?> TrimSeriesAt(double?[]? source, int limit, int anchorIndex, int fallbackLength = 0)
{
    var effectiveLength = Math.Max(limit, fallbackLength);
    if (effectiveLength <= 0)
    {
        return Array.Empty<double?>();
    }

    var result = new double?[effectiveLength];

    if (source is null || source.Length == 0)
    {
        return result;
    }

    var length = source.Length;
    var anchor = Math.Clamp(anchorIndex, 0, length - 1);
    var copyCount = Math.Min(effectiveLength, anchor + 1);
    if (copyCount <= 0)
    {
        return result;
    }

    var sourceStart = anchor - copyCount + 1;
    Array.Copy(source, sourceStart, result, effectiveLength - copyCount, copyCount);
    return result;
}

    private static void ApplyLegacyOverlayFields(string rawJson, TopologyOverlaySettings settings)
    {
        try
        {
            using var document = JsonDocument.Parse(rawJson);
            var root = document.RootElement;

            settings.ShowLabels = ResolveLegacyOverlay(root, "labels", settings.ShowLabels);
            settings.ShowEdgeArrows = ResolveLegacyOverlay(root, "edgeArrows", settings.ShowEdgeArrows);
            settings.ShowEdgeShares = ResolveLegacyOverlay(root, "edgeShares", settings.ShowEdgeShares);
            settings.ShowSparklines = ResolveLegacyOverlay(root, "sparklines", settings.ShowSparklines);
        }
        catch
        {
            // Legacy payload parsing failure can be ignored.
        }
    }

    private static bool ResolveLegacyOverlay(JsonElement root, string propertyName, bool currentValue)
    {
        if (root.TryGetProperty(propertyName, out var property) && property.ValueKind == JsonValueKind.Number)
        {
            var legacy = property.GetInt32();
            return legacy switch
            {
                1 => true,
                2 => false,
                _ => currentValue
            };
        }

        return currentValue;
    }

    private Task OnBinChanged(int value)
    {
        if (value == selectedBin)
        {
            return Task.CompletedTask;
        }

        UpdateActiveMetrics(value);
        // Rebuild sparklines anchored at the new selection so sampling works across the whole day.
        BuildNodeSparklines();
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task ToggleFeatureBar()
    {
        featureBarOpen = !featureBarOpen;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void ResetState()
    {
        loadCts?.Cancel();
        loadCts?.Dispose();
        loadCts = null;
        windowReloadCts?.Cancel();
        windowReloadCts?.Dispose();
        windowReloadCts = null;
        topologyGraph = null;
        windowData = null;
        seriesIndex = null;
        runDisplayName = null;
        timestamps = Array.Empty<DateTimeOffset>();
        inspectorOpen = false;
        inspectorPinned = false;
        inspectorNodeId = null;
        inspectorMetricsExpanded = false;
        ClearInspectorEdgeHighlights();
        loggedMissingMetricKinds.Clear();
        activeMetrics = new Dictionary<string, NodeBinMetrics>(StringComparer.OrdinalIgnoreCase);
        nodeSparklines = new Dictionary<string, NodeSparklineData>(StringComparer.OrdinalIgnoreCase);
        nodesMissingSparkline = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        selectedBin = 0;
        visibleStartBin = 0;
        visibleEndBin = 0;
        selectedBinLabel = string.Empty;
        selectedTimestampLabel = string.Empty;
        timelineTicks = Array.Empty<TimelineTick>();
        errorMessage = null;
        hasLoaded = false;
        isLoading = false;
        pointerNeedsJump = false;
        featureBarOpen = false;
        operationalViewOnly = false;
        savedIncludeExpressionNodes = null;
        savedIncludeConstNodes = null;
        savedEnableFullDag = null;
        sectionExpansionState = CreateDefaultSectionState();
        currentViewportSnapshot = null;
        pendingViewportSnapshot = null;
        restoredSelectedBin = null;
        windowWarnings = Array.Empty<TimeTravelStateWarningDto>();
        UpdateNodeWarningMap();
        saveRunStateDebounceCts?.Cancel();
        saveRunStateDebounceCts?.Dispose();
        saveRunStateDebounceCts = null;
    }

    private void UpdateNodeWarningMap()
    {
        if (windowWarnings.Count == 0)
        {
            nodeWarningsForCanvas = EmptyNodeWarnings;
            return;
        }

        var grouped = windowWarnings
            .Where(w => !string.IsNullOrWhiteSpace(w.NodeId))
            .GroupBy(w => w.NodeId!, StringComparer.OrdinalIgnoreCase)
            .ToDictionary(
                g => g.Key,
                g => (IReadOnlyList<NodeWarningPayload>)g.Select(w =>
                {
                    var code = string.IsNullOrWhiteSpace(w.Code) ? "warning" : w.Code.Trim();
                    var message = string.IsNullOrWhiteSpace(w.Message) ? string.Empty : w.Message.Trim();
                    return new NodeWarningPayload(code, message);
                }).ToArray(),
                StringComparer.OrdinalIgnoreCase);

        nodeWarningsForCanvas = grouped.Count == 0 ? EmptyNodeWarnings : grouped;
        Logger?.LogDebug("Node warning map rebuilt: {Count} nodes", nodeWarningsForCanvas.Count);
    }

    public void Dispose()
    {
        loadCts?.Cancel();
        loadCts?.Dispose();
        windowReloadCts?.Cancel();
        windowReloadCts?.Dispose();
        windowReloadCts = null;
        if (hotkeyRegistrationId.HasValue)
        {
            _ = JS.InvokeVoidAsync("FlowTime.TopologyHotkeys.unregister", hotkeyRegistrationId.Value);
        }
        selfReference?.Dispose();
        saveRunStateDebounceCts?.Cancel();
        saveRunStateDebounceCts?.Dispose();
        saveRunStateDebounceCts = null;
    }
}

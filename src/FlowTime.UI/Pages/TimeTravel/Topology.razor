@page "/time-travel/topology"
@using MudBlazor
@using Microsoft.JSInterop
@using FlowTime.UI.Components.Topology
@using FlowTime.UI.Services
@using System.Collections.Generic
@using System.Globalization
@using System.Linq
@using System.Text.Json
@using System.Threading
@inject ITimeTravelDataService DataService
@inject NavigationManager Navigation
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>Time-Travel Topology</PageTitle>

<MudStack Row="true" Class="topology-layout" AlignItems="@AlignItems.Stretch" Spacing="2">
    @if (featureBarOpen)
    {
        <MudPaper Class="topology-feature-panel" Elevation="1">
            <TopologyFeatureBar Settings="overlaySettings"
                                 SettingsChanged="OnOverlaySettingsChanged"
                                 CloseRequested="CloseFeatureBar" />
        </MudPaper>
    }

    <MudPaper Class="pa-5 topology-page" Elevation="1">
        <MudStack Spacing="3">
            <MudStack Row="true" AlignItems="@AlignItems.Center" Justify="@Justify.SpaceBetween">
                <MudStack Row="true" AlignItems="@AlignItems.Center" Spacing="1">
                    <MudText Typo="Typo.h5">@GetTemplateTitle()</MudText>
                </MudStack>
                <MudIconButton Icon="@Icons.Material.Filled.Tune"
                               Color="Color.Primary"
                               Size="Size.Medium"
                               AriaLabel="Open topology feature bar"
                               OnClick="OpenFeatureBar" />
            </MudStack>

            @if (string.IsNullOrWhiteSpace(RunId))
            {
                <MudAlert Severity="Severity.Info">
                    Select a run from the Artifacts list to inspect its topology.
                </MudAlert>
            }
            else if (!string.IsNullOrWhiteSpace(errorMessage))
            {
                <MudAlert Severity="Severity.Error" Variant="Variant.Outlined">
                    <MudText Typo="Typo.body1">@errorMessage</MudText>
                </MudAlert>
            }
            else if (isLoading)
            {
                <MudPaper Class="pa-6 d-flex flex-column align-center justify-center" Elevation="0">
                    <MudProgressCircular Color="Color.Primary" Diameter="64" Indeterminate="true" />
                    <MudText Typo="Typo.caption" Class="mt-2">Loading topologyâ€¦</MudText>
                </MudPaper>
            }
            else if (topologyGraph is null)
            {
                <MudAlert Severity="Severity.Warning">
                    Topology data was not available for run <strong>@RunId</strong>.
                </MudAlert>
            }
            else
            {
                <MudStack Spacing="2">
                    <MudPaper Class="pa-3 timeline-paper" Elevation="0">
                        <MudStack Spacing="1">
                            @{ var runInfo = GetRunInfo(); }
                            <MudStack Row="true" AlignItems="@AlignItems.Center" Justify="@Justify.SpaceBetween">
                                <MudText Typo="Typo.caption">@selectedTimestampLabel</MudText>
                                <MudStack Row="true" AlignItems="@AlignItems.Center" Justify="@Justify.FlexEnd" Spacing="1">
                                    <MudText Typo="Typo.caption" Color="Color.Secondary">Run @RunId</MudText>
                                    @if (!string.IsNullOrWhiteSpace(runInfo))
                                    {
                                        <MudText Typo="Typo.caption" Class="topology-run-info" Color="Color.Info">@runInfo</MudText>
                                    }
                                </MudStack>
                            </MudStack>
                            <div class="timeline-dial">
                                <div class="timeline-track @(visibleStartBin == visibleEndBin ? "is-disabled" : string.Empty)">
                                    <svg class="timeline-svg" viewBox="0 0 100 12" preserveAspectRatio="none">
                                        <rect class="timeline-track-bg" x="0" y="4" width="100" height="4" />
                                        @foreach (var tick in timelineTicks)
                                        {
                                            <line class="timeline-tick-line"
                                                  x1="@tick.Percent.ToString("0.###", CultureInfo.InvariantCulture)"
                                                  x2="@tick.Percent.ToString("0.###", CultureInfo.InvariantCulture)"
                                                  y1="1"
                                                  y2="11" />
                                        }
                                    </svg>
                                    <div class="timeline-pointer @(isDialPointerDragging ? "is-dragging" : string.Empty)"
                                         style="left: @DialPercent.ToString("0.###", CultureInfo.InvariantCulture)%; --timeline-transition-duration: @PointerTransitionDuration;"></div>
                                    <input class="timeline-range"
                                           type="range"
                                           min="@visibleStartBin"
                                           max="@visibleEndBin"
                                           step="1"
                                           value="@selectedBin"
                                           disabled="@(visibleStartBin == visibleEndBin)"
                                           @oninput="OnDialInput"
                                           @onpointerdown="StartDialDrag"
                                           @onpointerup="EndDialDrag"
                                           @onpointercancel="EndDialDrag"
                                           @onpointerleave="EndDialDrag" />
                                </div>
                                <div class="timeline-labels">
                                    @foreach (var tick in timelineTicks)
                                    {
                                        <span class="timeline-label" style="left:@tick.Percent.ToString("0.###", CultureInfo.InvariantCulture)%">@tick.Label</span>
                                    }
                                </div>
                                <div class="timeline-controls">
                                    <MudIconButton Icon="@(isPlaying ? Icons.Material.Filled.Pause : Icons.Material.Filled.PlayArrow)"
                                                   Color="Color.Primary"
                                                   Size="Size.Small"
                                                   Disabled="@(visibleStartBin == visibleEndBin)"
                                                   OnClick="TogglePlaybackAsync" />
                                    <MudIconButton Icon="@Icons.Material.Filled.SkipPrevious"
                                                   Size="Size.Small"
                                                   Disabled="@(selectedBin <= visibleStartBin)"
                                                   OnClick="GoToPreviousBin" />
                                    <MudIconButton Icon="@Icons.Material.Filled.SkipNext"
                                                   Size="Size.Small"
                                                   Disabled="@(selectedBin >= visibleEndBin)"
                                                   OnClick="GoToNextBin" />
                                    <MudIconButton Icon="@Icons.Material.Filled.Loop"
                                                   Size="Size.Small"
                                                   Color="@(loopPlayback ? Color.Primary : Color.Default)"
                                                   OnClick="ToggleLoop" />
                                    <MudChipSet T="double"
                                                Choice="true"
                                                SelectedValue="@playbackSecondsPerFrame"
                                                SelectedValueChanged="OnPlaybackSpeedChipChanged"
                                                Class="timeline-speed-set">
                                        @foreach (var option in PlaybackSpeedOptions)
                                        {
                                            <MudChip T="double"
                                                     Value="@option"
                                                     Variant="Variant.Outlined"
                                                     Color="Color.Default"
                                                     DisableRipple="true"
                                                     Size="Size.Small"
                                                     Class="timeline-speed-chip">
                                                @option.ToString("0.##")s
                                            </MudChip>
                                        }
                                    </MudChipSet>
                                </div>
                            </div>
                        </MudStack>
                    </MudPaper>

                    <TopologyCanvas Graph="topologyGraph"
                                    NodeMetrics="activeMetrics"
                                    NodeSparklines="nodeSparklines"
                                    OverlaySettings="overlaySettings"
                                    ActiveBin="selectedBin"
                                    ZoomPercentChanged="HandleCanvasZoomChanged" />

                    <div class="topology-legend">
                        <span class="legend-item">
                            <span class="legend-swatch success"></span>
                            Healthy
                        </span>
                        <span class="legend-item">
                            <span class="legend-swatch warning"></span>
                            Warning
                        </span>
                        <span class="legend-item">
                            <span class="legend-swatch error"></span>
                            Error
                        </span>
                        <span class="legend-item">
                            <span class="legend-swatch neutral"></span>
                            No data
                        </span>
                    </div>
                </MudStack>
            }
        </MudStack>
    </MudPaper>
</MudStack>

@code {
    [Parameter, SupplyParameterFromQuery(Name = "runId")]
    public string? RunId { get; set; }

    private string? currentRunId;
    private string? runDisplayName;
    private string? errorMessage;
    private bool isLoading;
    private bool hasLoaded;
    private CancellationTokenSource? loadCts;

    private bool featureBarOpen = true;
    private TopologyOverlaySettings overlaySettings = TopologyOverlaySettings.Default.Clone();
    private bool attemptedRestore;
    private bool overlaySettingsLoaded;
    private DotNetObjectReference<Topology>? selfReference;
    private int? hotkeyRegistrationId;

    private TopologyGraph? topologyGraph;
    private IReadOnlyDictionary<string, NodeBinMetrics> activeMetrics = new Dictionary<string, NodeBinMetrics>(StringComparer.OrdinalIgnoreCase);
    private IReadOnlyDictionary<string, NodeSparklineData> nodeSparklines = new Dictionary<string, NodeSparklineData>(StringComparer.OrdinalIgnoreCase);
    private TimeTravelStateWindowDto? windowData;
    private SeriesIndex? seriesIndex;
    private IReadOnlyList<DateTimeOffset> timestamps = Array.Empty<DateTimeOffset>();

    private int selectedBin;
    private int visibleStartBin;
    private int visibleEndBin;
    private string selectedBinLabel = string.Empty;
    private string selectedTimestampLabel = string.Empty;
    private IReadOnlyList<TimelineTick> timelineTicks = Array.Empty<TimelineTick>();
    private bool isPlaying;
    private bool loopPlayback;
    private double playbackSecondsPerFrame = 1d;
    private CancellationTokenSource? playbackCts;
    private Task playbackTask = Task.CompletedTask;
    private bool isDialPointerDragging;
    private bool pointerNeedsJump;

    private static readonly double[] PlaybackSpeedOptions = new[] { 0.25d, 0.5d, 1d, 2d };

    private sealed record TimelineTick(int Bin, double Percent, string Label);

    private double DialPercent
    {
        get
        {
            if (visibleEndBin <= visibleStartBin)
            {
                return 0d;
            }

            var fraction = (selectedBin - visibleStartBin) / (double)(visibleEndBin - visibleStartBin);
            return Math.Clamp(fraction * 100d, 0d, 100d);
        }
    }

    private string PointerTransitionDuration =>
        (!isDialPointerDragging && isPlaying && !pointerNeedsJump)
            ? $"{Math.Max(playbackSecondsPerFrame, 0.01):0.###}s"
            : "0s";

    private static readonly JsonSerializerOptions overlaySerializerOptions = new(JsonSerializerDefaults.Web);
    private const string OverlaySettingsStorageKey = "ft.topology.overlaySettings.v1";
    private const int SparklinePointLimit = 48;

    protected override async Task OnParametersSetAsync()
    {
        if (!overlaySettingsLoaded)
        {
            await LoadOverlaySettingsAsync();
            overlaySettingsLoaded = true;
        }

        if (string.IsNullOrWhiteSpace(RunId))
        {
            if (!attemptedRestore)
            {
                attemptedRestore = true;
                var lastRunId = await JS.InvokeAsync<string?>("localStorage.getItem", LastRunStorageKey);
                if (!string.IsNullOrWhiteSpace(lastRunId))
                {
                    Navigation.NavigateTo($"/time-travel/topology?runId={Uri.EscapeDataString(lastRunId)}");
                    return;
                }
            }

            ResetState();
            return;
        }

        if (string.Equals(RunId, currentRunId, StringComparison.OrdinalIgnoreCase) && hasLoaded)
        {
            return;
        }

        currentRunId = RunId;
        await LoadAsync(RunId);
    }

    private async Task LoadOverlaySettingsAsync()
    {
        try
        {
            var json = await JS.InvokeAsync<string?>("localStorage.getItem", OverlaySettingsStorageKey);
            if (!string.IsNullOrWhiteSpace(json))
            {
                var stored = JsonSerializer.Deserialize<TopologyOverlaySettings>(json, overlaySerializerOptions);
                if (stored is not null)
                {
                    overlaySettings = stored;
                    ApplyLegacyOverlayFields(json, overlaySettings);
                }
            }
        }
        catch
        {
            // Ignore deserialization/storage errors
        }

        overlaySettingsLoaded = true;

        if (selfReference is null)
        {
            selfReference = DotNetObjectReference.Create(this);
        }

        if (!hotkeyRegistrationId.HasValue)
        {
            try
            {
                hotkeyRegistrationId = await JS.InvokeAsync<int>("FlowTime.TopologyHotkeys.register", selfReference);
            }
            catch
            {
                hotkeyRegistrationId = null;
            }
        }
    }

    private async Task SaveOverlaySettingsAsync()
    {
        try
        {
            var json = JsonSerializer.Serialize(overlaySettings, overlaySerializerOptions);
            await JS.InvokeVoidAsync("localStorage.setItem", OverlaySettingsStorageKey, json);
        }
        catch
        {
            // Ignore storage failures
        }
    }

    private async Task LoadAsync(string runId)
    {
        loadCts?.Cancel();
        loadCts?.Dispose();
        loadCts = new CancellationTokenSource();

        isLoading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            var ct = loadCts.Token;

            var graphTask = DataService.GetGraphAsync(runId, BuildGraphQueryOptions(), ct);
            var indexTask = DataService.GetSeriesIndexAsync(runId, ct);

            await Task.WhenAll(graphTask, indexTask);

            var graphResult = await graphTask;
            if (!graphResult.Success || graphResult.Value is null)
            {
                errorMessage = graphResult.Error ?? "Topology graph is unavailable.";
                return;
            }

            var indexResult = await indexTask;
            if (!indexResult.Success || indexResult.Value is null)
            {
                errorMessage = indexResult.Error ?? "Run index metadata could not be retrieved.";
                return;
            }

            topologyGraph = GraphMapper.Map(graphResult.Value, overlaySettings.RespectUiPositions);
            seriesIndex = indexResult.Value;

            var totalBins = Math.Max(1, seriesIndex.Grid.Bins);
            var sliceEnd = totalBins - 1;
            var sliceStart = Math.Max(0, sliceEnd - 499);
            visibleStartBin = sliceStart;
            visibleEndBin = sliceEnd;

            var windowResult = await DataService.GetStateWindowAsync(runId, sliceStart, sliceEnd, ct);
            if (!windowResult.Success || windowResult.Value is null)
            {
                errorMessage = windowResult.Error ?? "Failed to load run state window.";
                return;
            }

            windowData = windowResult.Value;
            BuildNodeSparklines();
            timestamps = windowData.TimestampsUtc.ToList();
            runDisplayName = windowData.Metadata.TemplateTitle ?? windowData.Metadata.TemplateId ?? runId;

            await JS.InvokeVoidAsync("localStorage.setItem", LastRunStorageKey, runId);

            selectedBin = visibleEndBin;
            RefreshTimelineTicks();
            UpdateActiveMetrics(selectedBin);

            hasLoaded = true;
        }
        catch (OperationCanceledException)
        {
            // ignored; a new load started
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load topology: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private void OpenFeatureBar()
    {
        featureBarOpen = true;
        StateHasChanged();
    }

    private Task CloseFeatureBar()
    {
        featureBarOpen = false;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task OnOverlaySettingsChanged(TopologyOverlaySettings updated)
    {
        var previous = overlaySettings.Clone();

        overlaySettings = updated.Clone();
        await SaveOverlaySettingsAsync();

        var requiresGraphReload = previous.EnableFullDag != overlaySettings.EnableFullDag
            || previous.RespectUiPositions != overlaySettings.RespectUiPositions;

        if (requiresGraphReload && hasLoaded)
        {
            await RefreshGraphAsync();
        }
        else
        {
            StateHasChanged();
        }
    }

    private async Task HandleCanvasZoomChanged(double zoomPercent)
    {
        var clamped = Math.Clamp(zoomPercent, 30d, 400d);
        if (Math.Abs(overlaySettings.ZoomPercent - clamped) < 0.1d)
        {
            return;
        }

        var updated = overlaySettings.Clone();
        updated.ZoomPercent = clamped;
        await OnOverlaySettingsChanged(updated);
    }

    private GraphQueryOptions BuildGraphQueryOptions()
    {
        var options = new GraphQueryOptions
        {
            Mode = overlaySettings.EnableFullDag ? "full" : "operational"
        };

        if (overlaySettings.EnableFullDag)
        {
            var dependencyFields = new List<string>(6);

            if (overlaySettings.ShowArrivalsDependencies)
            {
                dependencyFields.Add("arrivals");
            }

            if (overlaySettings.ShowServedDependencies)
            {
                dependencyFields.Add("served");
            }

            if (overlaySettings.ShowErrorsDependencies)
            {
                dependencyFields.Add("errors");
            }

            if (overlaySettings.ShowQueueDependencies)
            {
                dependencyFields.Add("queue");
            }

            if (overlaySettings.ShowCapacityDependencies)
            {
                dependencyFields.Add("capacity");
            }

            if (overlaySettings.ShowExpressionDependencies)
            {
                dependencyFields.Add("expr");
            }

            if (dependencyFields.Count > 0 && dependencyFields.Count < 6)
            {
                options.DependencyFields = dependencyFields;
            }
        }

        return options;
    }

    private async Task RefreshGraphAsync()
    {
        if (string.IsNullOrWhiteSpace(currentRunId))
        {
            return;
        }

        try
        {
            var graphResult = await DataService.GetGraphAsync(currentRunId, BuildGraphQueryOptions());
            if (!graphResult.Success || graphResult.Value is null)
            {
                errorMessage = graphResult.Error ?? "Topology graph is unavailable.";
                StateHasChanged();
                return;
            }

            topologyGraph = GraphMapper.Map(graphResult.Value, overlaySettings.RespectUiPositions);
            errorMessage = null;
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to refresh topology: {ex.Message}";
        }

        StateHasChanged();
    }

    private Task OnDialInput(ChangeEventArgs args)
    {
        StopPlayback();
        if (int.TryParse(args.Value?.ToString(), NumberStyles.Integer, CultureInfo.InvariantCulture, out var value))
        {
            return OnBinChanged(value);
        }

        return Task.CompletedTask;
    }

    private Task GoToNextBin()
    {
        StopPlayback();
        var next = Math.Min(selectedBin + 1, visibleEndBin);
        return OnBinChanged(next);
    }

    private Task GoToPreviousBin()
    {
        StopPlayback();
        var previous = Math.Max(selectedBin - 1, visibleStartBin);
        return OnBinChanged(previous);
    }

    private Task TogglePlaybackAsync()
    {
        if (isPlaying)
        {
            StopPlayback();
        }
        else
        {
            StartPlayback();
        }

        return Task.CompletedTask;
    }

    private void ToggleLoop()
    {
        loopPlayback = !loopPlayback;
    }

    private Task OnPlaybackSpeedChipChanged(double value)
    {
        playbackSecondsPerFrame = Math.Clamp(value, 0.1d, 10d);
        return Task.CompletedTask;
    }

    private void StartDialDrag(PointerEventArgs _)
    {
        if (!isDialPointerDragging)
        {
            isDialPointerDragging = true;
            StateHasChanged();
        }
    }

    private void EndDialDrag(PointerEventArgs _)
    {
        if (isDialPointerDragging)
        {
            isDialPointerDragging = false;
            StateHasChanged();
        }
    }

    private const string LastRunStorageKey = "ft.topology.lastRunId";

    private void UpdateActiveMetrics(int bin)
    {
        if (windowData is null)
        {
            activeMetrics = new Dictionary<string, NodeBinMetrics>(StringComparer.OrdinalIgnoreCase);
            selectedBinLabel = bin.ToString(CultureInfo.InvariantCulture);
            selectedTimestampLabel = string.Empty;
            return;
        }

        var spanStart = windowData.Window.StartBin;
        var localIndex = bin - spanStart;
        if (localIndex < 0 || localIndex >= windowData.Window.BinCount)
        {
            activeMetrics = new Dictionary<string, NodeBinMetrics>(StringComparer.OrdinalIgnoreCase);
            selectedBinLabel = bin.ToString(CultureInfo.InvariantCulture);
            selectedTimestampLabel = string.Empty;
            return;
        }

        var metrics = new Dictionary<string, NodeBinMetrics>(StringComparer.OrdinalIgnoreCase);
        foreach (var node in windowData.Nodes)
        {
            double? Get(string key)
            {
                if (node.Series.TryGetValue(key, out var values) && localIndex < values.Length)
                {
                    return values[localIndex];
                }
                return null;
            }

            var arrivals = Get("arrivals");
            var served = Get("served");
            var errors = Get("errors");
            var throughput = Get("throughputRatio");
            var utilization = Get("utilization");
            var queue = Get("queue");
            var latency = Get("latencyMinutes");

            double? successRate = throughput;
            if (successRate is null && arrivals.HasValue && arrivals.Value > 0 && served.HasValue)
            {
                successRate = served.Value / arrivals.Value;
            }

            double? errorRate = null;
            var denominator = arrivals ?? served;
            if (errors.HasValue && denominator.HasValue && denominator.Value > 0)
            {
                errorRate = errors.Value / denominator.Value;
            }

            var timestamp = localIndex < timestamps.Count ? timestamps[localIndex] : (DateTimeOffset?)null;

            metrics[node.Id] = new NodeBinMetrics(
                successRate,
                utilization,
                errorRate,
                queue,
                latency,
                timestamp);
        }

        activeMetrics = metrics;
        selectedBin = bin;
        selectedBinLabel = bin.ToString(CultureInfo.InvariantCulture);
        selectedTimestampLabel = FormatTimestamp(localIndex);
    }

    private void RefreshTimelineTicks()
    {
        if (visibleEndBin < visibleStartBin)
        {
            timelineTicks = Array.Empty<TimelineTick>();
            return;
        }

        if (visibleEndBin == visibleStartBin)
        {
            timelineTicks = new[]
            {
                new TimelineTick(visibleStartBin, 0d, BuildTickLabel(visibleStartBin))
            };
            return;
        }

        var span = visibleEndBin - visibleStartBin;
        var desired = span switch
        {
            <= 3 => span + 1,
            <= 12 => 4,
            <= 48 => 6,
            _ => 8
        };
        desired = Math.Max(2, desired);

        var ticks = new List<TimelineTick>(desired + 2);
        var step = span / Math.Max(1d, desired - 1d);
        var seen = new HashSet<int>();

        for (var i = 0; i <= span; i++)
        {
            var bin = visibleStartBin + i;

            if (seen.Contains(bin))
            {
                continue;
            }

            var percent = ((bin - visibleStartBin) / (double)span) * 100d;
            percent = Math.Clamp(percent, 0d, 100d);
            ticks.Add(new TimelineTick(bin, percent, BuildTickLabel(bin)));
            seen.Add(bin);
        }

        ticks.Sort((a, b) => a.Bin.CompareTo(b.Bin));
        timelineTicks = ticks;
    }

    private string BuildTickLabel(int bin)
    {
        if (windowData is not null)
        {
            var spanStart = windowData.Window.StartBin;
            var localIndex = bin - spanStart;
            if (localIndex >= 0 && localIndex < timestamps.Count)
            {
                var ts = timestamps[localIndex];
                return ts.ToString("HH:mm", CultureInfo.InvariantCulture);
            }
        }

        return $"Bin {bin}";
    }

    private void StartPlayback()
    {
        if (isPlaying || visibleStartBin == visibleEndBin)
        {
            return;
        }

        playbackCts?.Cancel();
        playbackCts = new CancellationTokenSource();
        var token = playbackCts.Token;
        isPlaying = true;
        playbackTask = RunPlaybackLoopAsync(token);
        StateHasChanged();
    }

    private void StopPlayback()
    {
        playbackCts?.Cancel();
        pointerNeedsJump = false;
    }

    private async Task RunPlaybackLoopAsync(CancellationToken token)
    {
        try
        {
            while (!token.IsCancellationRequested)
            {
                await Task.Delay(TimeSpan.FromSeconds(playbackSecondsPerFrame), token);

                var shouldJumpAfterPause = false;
                await InvokeAsync(() =>
                {
                    if (visibleStartBin == visibleEndBin)
                    {
                        StopPlayback();
                        return;
                    }

                    var next = selectedBin + 1;
                    if (next > visibleEndBin)
                    {
                        if (loopPlayback)
                        {
                            pointerNeedsJump = true;
                            shouldJumpAfterPause = true;
                            return;
                        }
                        else
                        {
                            StopPlayback();
                            return;
                        }
                    }

                    pointerNeedsJump = false;

                    UpdateActiveMetrics(next);
                    StateHasChanged();
                });

                if (shouldJumpAfterPause)
                {
                    await Task.Delay(TimeSpan.FromSeconds(1), token);

                    await InvokeAsync(() =>
                    {
                        if (token.IsCancellationRequested)
                        {
                            return;
                        }

                        pointerNeedsJump = true;
                        UpdateActiveMetrics(visibleStartBin);
                        StateHasChanged();
                    });
                }
            }
        }
        catch (TaskCanceledException)
        {
            // expected when playback is stopped
        }
        finally
        {
            await InvokeAsync(() =>
            {
                playbackCts?.Dispose();
                playbackCts = null;
                isPlaying = false;
                playbackTask = Task.CompletedTask;
                StateHasChanged();
            });
        }
    }

    private string FormatTimestamp(int localIndex)
    {
        if (localIndex < 0 || localIndex >= timestamps.Count)
        {
            return string.Empty;
        }

        var ts = timestamps[localIndex];
        return ts.ToString("dd MMM yyyy HH:mm 'UTC'", CultureInfo.InvariantCulture);
    }

    private void BuildNodeSparklines()
    {
        if (windowData is null)
        {
            nodeSparklines = new Dictionary<string, NodeSparklineData>(StringComparer.OrdinalIgnoreCase);
            return;
        }

        var result = new Dictionary<string, NodeSparklineData>(StringComparer.OrdinalIgnoreCase);
        foreach (var node in windowData.Nodes)
        {
            var successSeries = BuildSuccessRateSeries(node);
            if (successSeries is null)
            {
                continue;
            }

            var trimmedSuccess = TrimSeries(successSeries, SparklinePointLimit);
            var successStartIndex = Math.Max(0, successSeries.Length - trimmedSuccess.Count);
            var trimmedUtilization = TrimSeries(TryGetSeries(node, "utilization"), SparklinePointLimit, trimmedSuccess.Count);
            var trimmedErrorRate = TrimSeries(BuildErrorRateSeries(node), SparklinePointLimit, trimmedSuccess.Count);
            var trimmedQueue = TrimSeries(TryGetSeries(node, "queue"), SparklinePointLimit, trimmedSuccess.Count);

            var sparkline = NodeSparklineData.Create(
                trimmedSuccess,
                trimmedUtilization,
                trimmedErrorRate,
                trimmedQueue,
                successStartIndex,
                0d,
                1d);

            result[node.Id] = sparkline;
        }

        nodeSparklines = result;
    }

    private string GetRunInfo()
    {
        return string.Empty;
    }

    private string GetTemplateTitle()
    {
        if (!string.IsNullOrWhiteSpace(runDisplayName))
        {
            return runDisplayName!;
        }

        return "Time-Travel Topology";
    }

    private static double?[]? BuildSuccessRateSeries(TimeTravelNodeSeriesDto node)
    {
        if (node is null)
        {
            return null;
        }

        var throughput = TryGetSeries(node, "throughputRatio");
        var arrivals = TryGetSeries(node, "arrivals");
        var served = TryGetSeries(node, "served");

        var length = Math.Max(
            throughput?.Length ?? 0,
            Math.Max(arrivals?.Length ?? 0, served?.Length ?? 0));

        if (length <= 0)
        {
            return null;
        }

        var values = new double?[length];
        for (var i = 0; i < length; i++)
        {
            var throughputValue = GetValueAt(throughput, i);
            if (throughputValue.HasValue)
            {
                values[i] = throughputValue;
                continue;
            }

            var arrivalsValue = GetValueAt(arrivals, i);
            var servedValue = GetValueAt(served, i);

            if (arrivalsValue.HasValue && arrivalsValue.Value > 0 && servedValue.HasValue)
            {
                values[i] = servedValue.Value / arrivalsValue.Value;
            }
            else if ((!arrivalsValue.HasValue || arrivalsValue.Value <= 0) && servedValue.HasValue)
            {
                values[i] = servedValue.Value > 0 ? 1d : 0d;
            }
            else
            {
                values[i] = null;
            }
        }

        return values;
    }

    private static double?[]? BuildErrorRateSeries(TimeTravelNodeSeriesDto node)
    {
        if (node is null)
        {
            return null;
        }

        var errors = TryGetSeries(node, "errors");
        var arrivals = TryGetSeries(node, "arrivals");
        var served = TryGetSeries(node, "served");

        var length = Math.Max(errors?.Length ?? 0, Math.Max(arrivals?.Length ?? 0, served?.Length ?? 0));
        if (length <= 0)
        {
            return null;
        }

        var values = new double?[length];
        for (var i = 0; i < length; i++)
        {
            var errorsValue = GetValueAt(errors, i);
            if (!errorsValue.HasValue)
            {
                values[i] = null;
                continue;
            }

            var denominator = GetValueAt(arrivals, i) ?? GetValueAt(served, i);
            if (denominator.HasValue && denominator.Value > 0)
            {
                values[i] = errorsValue.Value / denominator.Value;
            }
            else
            {
                values[i] = errorsValue.Value > 0 ? 1d : 0d;
            }
        }

        return values;
    }

    private static double?[]? TryGetSeries(TimeTravelNodeSeriesDto node, string key)
    {
        if (node.Series is null || string.IsNullOrWhiteSpace(key))
        {
            return null;
        }

        if (node.Series.TryGetValue(key, out var series) && series is not null && series.Length > 0)
        {
            return series;
        }

        return null;
    }

    private static double? GetValueAt(double?[]? series, int index)
    {
        if (series is null || index < 0 || index >= series.Length)
        {
            return null;
        }

        return series[index];
    }

    private static IReadOnlyList<double?> TrimSeries(double?[]? source, int limit, int fallbackLength = 0)
    {
        if (source is null || source.Length == 0)
        {
            return fallbackLength == 0
                ? Array.Empty<double?>()
                : Enumerable.Repeat<double?>(null, fallbackLength).ToArray();
        }

        if (source.Length <= limit)
        {
            return source.ToArray();
        }

        var start = Math.Max(0, source.Length - limit);
        var result = new double?[limit];
        Array.Copy(source, start, result, 0, limit);
        return result;
    }

    private static void ApplyLegacyOverlayFields(string rawJson, TopologyOverlaySettings settings)
    {
        try
        {
            using var document = JsonDocument.Parse(rawJson);
            var root = document.RootElement;

            settings.ShowLabels = ResolveLegacyOverlay(root, "labels", settings.ShowLabels);
            settings.ShowEdgeArrows = ResolveLegacyOverlay(root, "edgeArrows", settings.ShowEdgeArrows);
            settings.ShowEdgeShares = ResolveLegacyOverlay(root, "edgeShares", settings.ShowEdgeShares);
            settings.ShowSparklines = ResolveLegacyOverlay(root, "sparklines", settings.ShowSparklines);
        }
        catch
        {
            // Legacy payload parsing failure can be ignored.
        }
    }

    private static bool ResolveLegacyOverlay(JsonElement root, string propertyName, bool currentValue)
    {
        if (root.TryGetProperty(propertyName, out var property) && property.ValueKind == JsonValueKind.Number)
        {
            var legacy = property.GetInt32();
            return legacy switch
            {
                1 => true,
                2 => false,
                _ => currentValue
            };
        }

        return currentValue;
    }

    private Task OnBinChanged(int value)
    {
        if (value == selectedBin)
        {
            return Task.CompletedTask;
        }

        UpdateActiveMetrics(value);
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task ToggleFeatureBar()
    {
        featureBarOpen = !featureBarOpen;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void ResetState()
    {
        loadCts?.Cancel();
        topologyGraph = null;
        windowData = null;
        seriesIndex = null;
        runDisplayName = null;
        timestamps = Array.Empty<DateTimeOffset>();
        activeMetrics = new Dictionary<string, NodeBinMetrics>(StringComparer.OrdinalIgnoreCase);
        nodeSparklines = new Dictionary<string, NodeSparklineData>(StringComparer.OrdinalIgnoreCase);
        selectedBin = 0;
        visibleStartBin = 0;
        visibleEndBin = 0;
        selectedBinLabel = string.Empty;
        selectedTimestampLabel = string.Empty;
        timelineTicks = Array.Empty<TimelineTick>();
        errorMessage = null;
        hasLoaded = false;
        isLoading = false;
        pointerNeedsJump = false;
    }

    public void Dispose()
    {
        loadCts?.Cancel();
        loadCts?.Dispose();
        if (hotkeyRegistrationId.HasValue)
        {
            _ = JS.InvokeVoidAsync("FlowTime.TopologyHotkeys.unregister", hotkeyRegistrationId.Value);
        }
        selfReference?.Dispose();
    }
}

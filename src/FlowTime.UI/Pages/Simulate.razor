@page "/simulate"
@using System.Text.Json
@using System.Text.Json.Serialization
@using MudBlazor
@using FlowTime.UI.Services
@inject IFlowTimeApiClient ApiClient
@inject NavigationManager Navigation
@inject ILogger<Simulate> Logger

<PageTitle>Simulate</PageTitle>

<MudContainer MaxWidth="MaxWidth.False">
    <MudStack Spacing="3">
        <MudPaper Class="pa-4" Elevation="2">
            <MudText Typo="Typo.h4" GutterBottom="true">Simulate → Gold Run</MudText>
            <MudText Typo="Typo.body1" Color="Color.Secondary">
                Kick off a simulation using a FlowTime template. The orchestration writes a gold run under <code>data/runs/&lt;runId&gt;</code>,
                which immediately shows up under Artifacts and can be opened in the Time-Travel workspace.
                <br />
                <strong>Note:</strong> Telemetry mode requires a capture directory (not yet wired in this UI), so the default mode is <em>simulation</em>.
            </MudText>
        </MudPaper>

        <MudPaper Class="pa-4" Elevation="1">
            <MudForm @ref="_form" Model="@this">
                <MudGrid>
                    <MudItem xs="12" md="6">
                        <MudTextField @bind-Value="_templateId"
                                      Label="Template ID"
                                      Required="true"
                                      Disabled="_isRunning"
                                      Placeholder="e.g. it-system-microservices" />
                    </MudItem>
                    <MudItem xs="12" md="3">
                    <MudSelect T="string" @bind-Value="_mode" Label="Mode" Disabled="_isRunning">
                        <MudSelectItem T="string" Value="@("telemetry")">telemetry</MudSelectItem>
                        <MudSelectItem T="string" Value="@("simulation")">simulation</MudSelectItem>
                        </MudSelect>
                    </MudItem>
                    <MudItem xs="12" md="3">
                        <MudTextField @bind-Value="_runLabel"
                                      Label="Run ID (optional)"
                                      Disabled="_isRunning"
                                      HelperText="Leave blank to auto-generate" />
                    </MudItem>
                    <MudItem xs="12" md="6">
                        <MudSwitch @bind-Value="_deterministicRunId"
                                   Disabled="_isRunning"
                                   Color="Color.Secondary"
                                   Label="Use deterministic run id" />
                    </MudItem>
                    <MudItem xs="12">
                        <MudTextField @bind-Value="_parametersText"
                                      Label="Parameters (JSON object)"
                                      Lines="4"
                                      Disabled="_isRunning"
                                      Placeholder="{ &quot;seed&quot;: 42, &quot;arrivalRate&quot;: 15 }"
                                      Variant="Variant.Outlined"
                                      Margin="Margin.Dense"
                                      />
                    </MudItem>
                </MudGrid>

                @if (!string.IsNullOrEmpty(_validationError))
                {
                    <MudAlert Severity="Severity.Error" Variant="Variant.Outlined" Class="mt-2">
                        @_validationError
                    </MudAlert>
                }

                <MudStack Row="true" Spacing="2" Class="mt-4">
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               Disabled="_isRunning"
                               OnClick="StartRunAsync"
                               StartIcon="@Icons.Material.Filled.PlayArrow">
                        Start
                    </MudButton>
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Warning"
                               Disabled="!_isRunning"
                               OnClick="CancelRun"
                               StartIcon="@Icons.Material.Filled.Cancel">
                        Cancel
                    </MudButton>
                    <MudSpacer />
                    <MudButton Variant="Variant.Text"
                               Color="Color.Secondary"
                               Disabled="_logs.Count == 0"
                               OnClick="ClearLogs"
                               StartIcon="@Icons.Material.Filled.DeleteSweep">
                        Clear Logs
                    </MudButton>
                </MudStack>
            </MudForm>
        </MudPaper>

        <MudPaper Class="pa-4" Elevation="1">
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                <MudChip T="string"
                         Color="@GetStatusColor()"
                         Variant="Variant.Outlined"
                         Icon="@GetStatusIcon()">
                    @GetStatusText()
                </MudChip>
                @if (!string.IsNullOrEmpty(_statusMessage))
                {
                    <MudText Typo="Typo.body2">@_statusMessage</MudText>
                }
            </MudStack>

            <MudDivider Class="my-3" />

            <MudPaper Class="pa-2 log-surface" Elevation="0" Style="max-height: 260px; overflow-y: auto;">
                @if (_logs.Count == 0)
                {
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        Logs will appear here once the orchestration starts.
                    </MudText>
                }
                else
                {
                    @foreach (var entry in _logs)
                    {
                        <MudText Typo="Typo.caption" Class="d-block">
                            <span style="color:@GetLogColor(entry.Level)">
                                [@entry.Timestamp:HH:mm:ss] [@entry.Level.ToUpperInvariant()] @entry.Message
                            </span>
                        </MudText>
                    }
                }
            </MudPaper>
        </MudPaper>

        @if (_resultSummary is not null)
        {
            <MudPaper Class="pa-4" Elevation="1">
                <MudStack Spacing="2">
                    <MudText Typo="Typo.h6">Run Summary</MudText>
                    <MudDivider Class="mb-2" />
                    <MudList T="string" Dense="true">
                        <MudListItem T="string">
                            <MudText Typo="Typo.subtitle2">Run ID</MudText>
                            <MudText Typo="Typo.body2">@_resultSummary.RunId</MudText>
                        </MudListItem>
                        <MudListItem T="string">
                            <MudText Typo="Typo.subtitle2">Template</MudText>
                            <MudText Typo="Typo.body2">@_resultSummary.TemplateId</MudText>
                        </MudListItem>
                        <MudListItem T="string">
                            <MudText Typo="Typo.subtitle2">Created (UTC)</MudText>
                            <MudText Typo="Typo.body2">@(_resultSummary.CreatedUtc?.ToString("yyyy-MM-dd HH:mm:ss") ?? "—")</MudText>
                        </MudListItem>
                        <MudListItem T="string">
                            <MudText Typo="Typo.subtitle2">Grid</MudText>
                            <MudText Typo="Typo.body2">@(_resultSummary.GridBins.HasValue
                                ? $"{_resultSummary.GridBins} bins · {_resultSummary.GridBinMinutes} min"
                                : "Unavailable")</MudText>
                        </MudListItem>
                        <MudListItem T="string">
                            <MudText Typo="Typo.subtitle2">Warnings</MudText>
                            <MudText Typo="Typo.body2">@_resultSummary.WarningCount</MudText>
                        </MudListItem>
                        <MudListItem T="string">
                            <MudText Typo="Typo.subtitle2">Artifacts</MudText>
                            <MudStack Row="true" Spacing="1">
                                <MudChip T="string"
                                         Size="Size.Small"
                                         Variant="Variant.Outlined"
                                         Color="@(_resultSummary.HasManifest ? Color.Success : Color.Warning)">
                                    manifest.json
                                </MudChip>
                                <MudChip T="string"
                                         Size="Size.Small"
                                         Variant="Variant.Outlined"
                                         Color="@(_resultSummary.HasSeriesIndex ? Color.Success : Color.Warning)">
                                    series/index.json
                                </MudChip>
                            </MudStack>
                        </MudListItem>
                    </MudList>

                    <MudStack Row="true" Spacing="2">
                        <MudButton Variant="Variant.Filled"
                                   Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.AutoAwesome"
                                   OnClick="() => OpenInTimeTravel(_resultSummary.RunId)">
                            Open in Time-Travel
                        </MudButton>
                        <MudButton Variant="Variant.Outlined"
                                   Color="Color.Secondary"
                                   StartIcon="@Icons.Material.Filled.TableRows"
                                   OnClick="() => ViewInArtifacts(_resultSummary.RunId)">
                            View in Artifacts
                        </MudButton>
                    </MudStack>
                </MudStack>
            </MudPaper>
        }
    </MudStack>
</MudContainer>

@code {
    private MudForm? _form;
    private string _templateId = string.Empty;
    private string _mode = "simulation";
    private string _runLabel = string.Empty;
    private bool _deterministicRunId;
    private string _parametersText = string.Empty;
    private string? _validationError;

    private bool _isRunning;
    private string? _statusMessage;
    private RunExecutionStatus _status = RunExecutionStatus.Idle;
    private readonly List<RunLogEntry> _logs = new();
    private RunResultSummary? _resultSummary;
    private CancellationTokenSource? _cts;

    private async Task StartRunAsync()
    {
        if (_isRunning)
        {
            return;
        }

        _validationError = null;
        _resultSummary = null;

        var parameters = ParseParameters();
        if (parameters is null && !string.IsNullOrWhiteSpace(_parametersText))
        {
            _validationError = "Parameters must be a valid JSON object.";
            return;
        }

        if (string.IsNullOrWhiteSpace(_templateId))
        {
            _validationError = "Template ID is required.";
            return;
        }

        _isRunning = true;
        _status = RunExecutionStatus.Queued;
        _statusMessage = null;
        _logs.Clear();
        AddLog("Queued run request.", "info");

        _cts = new CancellationTokenSource();

        try
        {
            await Task.Yield(); // allow UI to update

            _status = RunExecutionStatus.Running;
            AddLog("Submitting run to orchestrator…", "info");

            var request = BuildRunRequest(parameters);
            var payloadPreview = JsonSerializer.Serialize(request, new JsonSerializerOptions(JsonSerializerDefaults.Web)
            {
                WriteIndented = true,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
            });
            AddLog($"Payload preview:\n{payloadPreview}", "info");
            var result = await ApiClient.CreateRunAsync(request, _cts.Token);

            if (!result.Success || result.Value?.Metadata?.RunId is null)
            {
                _status = RunExecutionStatus.Failed;
                var error = result.Error ?? "Run orchestration failed.";
                _statusMessage = error;
                AddLog(error, "error");
                return;
            }

            var runId = result.Value.Metadata.RunId;
            AddLog($"Run {runId} completed. Validating artifacts…", "info");

            _resultSummary = await BuildSummaryAsync(runId, result.Value, _cts.Token);

            _status = RunExecutionStatus.Succeeded;
            _statusMessage = $"Run {runId} is ready.";
            AddLog("Artifacts validated. You can open the run in Time-Travel or view it in Artifacts.", "success");
        }
        catch (OperationCanceledException)
        {
            _status = RunExecutionStatus.Canceled;
            _statusMessage = "Run canceled.";
            AddLog("Run canceled by user.", "warn");
        }
        catch (Exception ex)
        {
            _status = RunExecutionStatus.Failed;
            _statusMessage = ex.Message;
            AddLog($"Unexpected error: {ex.Message}", "error");
            Logger.LogError(ex, "Unexpected error during simulation orchestration.");
        }
        finally
        {
            _cts?.Dispose();
            _cts = null;
            _isRunning = false;
            StateHasChanged();
        }
    }

    private void CancelRun()
    {
        if (!_isRunning || _cts is null)
        {
            return;
        }

        _cts.Cancel();
    }

    private RunCreateRequestDto BuildRunRequest(Dictionary<string, JsonElement>? parameters)
    {
        RunCreationOptionsDto? options = null;
        options = new RunCreationOptionsDto(
            DeterministicRunId: _deterministicRunId,
            RunId: string.IsNullOrWhiteSpace(_runLabel) ? null : _runLabel.Trim(),
            DryRun: false,
            OverwriteExisting: true);

        return new RunCreateRequestDto(
            TemplateId: _templateId.Trim(),
            Mode: string.IsNullOrWhiteSpace(_mode) ? "telemetry" : _mode,
            Parameters: parameters,
            Telemetry: null,
            Options: options);
    }

    private Dictionary<string, JsonElement>? ParseParameters()
    {
        if (string.IsNullOrWhiteSpace(_parametersText))
        {
            return null;
        }

        try
        {
            using var doc = JsonDocument.Parse(_parametersText);
            if (doc.RootElement.ValueKind != JsonValueKind.Object)
            {
                return null;
            }

            var dict = new Dictionary<string, JsonElement>(StringComparer.OrdinalIgnoreCase);
            foreach (var prop in doc.RootElement.EnumerateObject())
            {
                dict[prop.Name] = prop.Value.Clone();
            }

            return dict;
        }
        catch (JsonException)
        {
            return null;
        }
    }

    private async Task<RunResultSummary> BuildSummaryAsync(string runId, RunCreateResponseDto response, CancellationToken ct)
    {
        DateTimeOffset? created = null;
        int warningCount = response.Warnings?.Count ?? 0;

        try
        {
            var lookup = await ApiClient.GetRunSummariesAsync(pageSize: 200, ct: ct);
            if (lookup.Success && lookup.Value?.Items is not null)
            {
                var match = lookup.Value.Items.FirstOrDefault(r => string.Equals(r.RunId, runId, StringComparison.OrdinalIgnoreCase));
                if (match is not null)
                {
                    created = match.CreatedUtc;
                    warningCount = Math.Max(warningCount, match.WarningCount);
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to retrieve run summary list.");
        }

        bool hasManifest = !string.IsNullOrWhiteSpace(response.Metadata?.Storage?.MetadataPath);
        bool hasSeriesIndex = false;
        int? bins = null;
        int? binMinutes = null;

        var indexResult = await ApiClient.GetRunIndexAsync(runId, ct);
        if (indexResult.Success && indexResult.Value is not null)
        {
            hasSeriesIndex = true;
            bins = indexResult.Value.Grid?.Bins;
            try
            {
                binMinutes = indexResult.Value.Grid?.BinMinutes;
            }
            catch
            {
                binMinutes = null;
            }
        }

        return new RunResultSummary(
            RunId: runId,
            TemplateId: response.Metadata?.TemplateId ?? _templateId,
            CreatedUtc: created,
            GridBins: bins,
            GridBinMinutes: binMinutes,
            WarningCount: warningCount,
            HasManifest: hasManifest,
            HasSeriesIndex: hasSeriesIndex);
    }

    private void OpenInTimeTravel(string runId)
    {
        Navigation.NavigateTo($"/time-travel/dashboard?runId={Uri.EscapeDataString(runId)}");
    }

    private void ViewInArtifacts(string runId)
    {
        Navigation.NavigateTo($"/artifacts?focus={Uri.EscapeDataString(runId)}");
    }

    private void ClearLogs()
    {
        _logs.Clear();
    }

    private void AddLog(string message, string level)
    {
        _logs.Add(new RunLogEntry(DateTimeOffset.UtcNow, level, message));
        StateHasChanged();
    }

    private string GetStatusText() => _status switch
    {
        RunExecutionStatus.Idle => "Idle",
        RunExecutionStatus.Queued => "Queued",
        RunExecutionStatus.Running => "Running…",
        RunExecutionStatus.Succeeded => "Succeeded",
        RunExecutionStatus.Failed => "Failed",
        RunExecutionStatus.Canceled => "Canceled",
        _ => "Unknown"
    };

    private string GetStatusIcon() => _status switch
    {
        RunExecutionStatus.Idle => Icons.Material.Filled.HourglassEmpty,
        RunExecutionStatus.Queued => Icons.Material.Filled.Schedule,
        RunExecutionStatus.Running => Icons.Material.Filled.Autorenew,
        RunExecutionStatus.Succeeded => Icons.Material.Filled.CheckCircle,
        RunExecutionStatus.Canceled => Icons.Material.Filled.Cancel,
        RunExecutionStatus.Failed => Icons.Material.Filled.Error,
        _ => Icons.Material.Filled.Info
    };

    private Color GetStatusColor() => _status switch
    {
        RunExecutionStatus.Succeeded => Color.Success,
        RunExecutionStatus.Failed => Color.Error,
        RunExecutionStatus.Canceled => Color.Warning,
        RunExecutionStatus.Running => Color.Info,
        RunExecutionStatus.Queued => Color.Secondary,
        _ => Color.Default
    };

    private string GetLogColor(string level) => level.ToLowerInvariant() switch
    {
        "success" => "#2e7d32",
        "info" => "#1e88e5",
        "warn" => "#f9a825",
        "warning" => "#f9a825",
        "error" => "#c62828",
        _ => "var(--mud-palette-text-primary)"
    };

    private enum RunExecutionStatus
    {
        Idle,
        Queued,
        Running,
        Succeeded,
        Failed,
        Canceled
    }

    private sealed record RunLogEntry(DateTimeOffset Timestamp, string Level, string Message);

    private sealed record RunResultSummary(
        string RunId,
        string TemplateId,
        DateTimeOffset? CreatedUtc,
        int? GridBins,
        int? GridBinMinutes,
        int WarningCount,
        bool HasManifest,
        bool HasSeriesIndex);
}

@using FlowTime.UI.Services
@using static FlowTime.UI.Pages.TemplateRunner
@using MudBlazor
@inject ITemplateService TemplateService
@inject ISnackbar Snackbar
@inject FeatureFlagService FeatureFlags
@implements IDisposable

<MudStack Spacing="2">
    @if (templates == null)
    {
        @if (isLoading)
        {
            @if (FeatureFlags.UseDemoMode)
            {
                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                <MudText Typo="Typo.body2">Loading demo templates...</MudText>
            }
            else
            {
                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                <MudText Typo="Typo.body2">Connecting to FlowTime-Sim API...</MudText>
            }
        }
        else
        {
            @if (FeatureFlags.UseDemoMode)
            {
                <MudAlert Severity="Severity.Error" Class="mb-3">
                    <MudText Typo="Typo.body2">
                        <strong>Failed to Load Demo Templates</strong><br/>
                        An unexpected error occurred while loading built-in templates.
                    </MudText>
                </MudAlert>
            }
            else
            {
                <MudAlert Severity="Severity.Error" Class="mb-3">
                    <MudText Typo="Typo.body2">
                        <strong>FlowTime-Sim API Not Available</strong><br/>
                        Please ensure the FlowTime-Sim service is running and accessible.
                    </MudText>
                </MudAlert>
            }
        }
    }
    else if (!filteredTemplates.Any())
    {
        @if (templates.Any())
        {
            <MudAlert Severity="Severity.Info">No templates match the current filter</MudAlert>
        }
        else
        {
            <MudAlert Severity="Severity.Info">No templates available</MudAlert>
        }
    }
    else
    {
        @foreach (var template in filteredTemplates)
        {
            <MudCard Class="@GetCardClass(template)" Style="cursor: pointer;" 
                     @onclick="() => SelectTemplate(template)">
                <MudCardContent>
                    <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Start" Class="mb-2">
                        <MudText Typo="Typo.h6">@template.Name</MudText>
                        <MudChip T="string" Size="Size.Small" 
                                Color="@(FeatureFlags.UseDemoMode ? Color.Warning : Color.Success)"
                                Variant="Variant.Filled">
                            @(FeatureFlags.UseDemoMode ? "DEMO" : "API")
                        </MudChip>
                    </MudStack>
                    <MudText Typo="Typo.body2" Class="mb-2">@template.Description</MudText>
                    <MudChip T="string" Size="Size.Small" Color="@GetCategoryColor(template.Category)">
                        @template.Category
                    </MudChip>
                    @if (template.Tags.Any())
                    {
                        <div class="mt-2">
                            @foreach (var tag in template.Tags)
                            {
                                <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined" Class="mr-1">
                                    @tag
                                </MudChip>
                            }
                        </div>
                    }
                </MudCardContent>
            </MudCard>
        }
    }
</MudStack>

@code {
    [Parameter] public EventCallback<TemplateInfo> OnTemplateSelected { get; set; }
    [Parameter] public EventCallback<List<TemplateInfo>?> OnTemplatesLoaded { get; set; }
    [Parameter] public TemplateFilter TemplateFilter { get; set; } = TemplateFilter.All;
    
    private List<TemplateInfo>? templates;
    private string? selectedTemplateId;
    private List<TemplateInfo> filteredTemplates = new();
    private bool isLoading = true;

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to mode changes
        FeatureFlags.Changed += OnModeChanged;
    await LoadTemplatesAsync();
    }

    private async void OnModeChanged()
    {
        await LoadTemplatesAsync();
        // Clear selection since templates changed
        selectedTemplateId = null;
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadTemplatesAsync()
    {
        isLoading = true;
        try
        {
            await FeatureFlags.EnsureLoadedAsync();
            templates = await TemplateService.GetTemplatesAsync();
            ApplyFilter();
            await OnTemplatesLoaded.InvokeAsync(templates);
            await InvokeAsync(StateHasChanged);
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("FlowTime-Sim API") || ex.Message.Contains("FlowTime API"))
        {
            // API-specific error - don't show generic error, let the UI handle it
            templates = null;
            filteredTemplates = new List<TemplateInfo>();
            await OnTemplatesLoaded.InvokeAsync(templates);
            await InvokeAsync(StateHasChanged);
            var apiName = FeatureFlags.UseDemoMode ? "Demo templates" : "FlowTime API";
            Snackbar.Add($"{apiName} is not available", Severity.Warning);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load templates: {ex.Message}", Severity.Error);
            templates = null;
            filteredTemplates = new List<TemplateInfo>();
            await OnTemplatesLoaded.InvokeAsync(templates);
            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            isLoading = false;
        }
    }

    protected override void OnParametersSet()
    {
        ApplyFilter();
    }

    private void ApplyFilter()
    {
        if (templates == null)
        {
            filteredTemplates = new List<TemplateInfo>();
            return;
        }

        filteredTemplates = TemplateFilter switch
        {
            TemplateFilter.Demo => templates.Where(t => 
                t.Category.Equals("theoretical", StringComparison.OrdinalIgnoreCase) || 
                t.Tags.Any(tag => tag.Contains("demo") || tag.Contains("quick") || tag.Contains("beginner"))).ToList(),
            TemplateFilter.Domain => templates.Where(t => 
                t.Category.Equals("domain", StringComparison.OrdinalIgnoreCase) || 
                t.Tags.Any(tag => tag.Contains("manufacturing") || tag.Contains("transportation") || tag.Contains("microservices") || tag.Contains("it-systems"))).ToList(),
            _ => templates.ToList()
        };
    }

    public void Dispose()
    {
        FeatureFlags.Changed -= OnModeChanged;
    }

    private async Task SelectTemplate(TemplateInfo template)
    {
        selectedTemplateId = template.Id;
        await OnTemplateSelected.InvokeAsync(template);
        StateHasChanged();
    }

    private string GetCardClass(TemplateInfo template)
    {
        var baseClass = "mb-2";
        if (template.Id == selectedTemplateId)
        {
            baseClass += " mud-theme-primary";
        }
        return baseClass;
    }

    private Color GetCategoryColor(string category)
    {
        return category.ToLowerInvariant() switch
        {
            "transportation" => Color.Primary,
            "supply-chain" => Color.Secondary,
            "manufacturing" => Color.Tertiary,
            "network" => Color.Info,
            "finance" => Color.Success,
            _ => Color.Default
        };
    }
}

@using FlowTime.UI.Services
@using MudBlazor
@inject ITemplateService TemplateService
@inject INotificationService NotificationService
@inject FeatureFlagService FeatureFlags
@implements IDisposable

<MudGrid Spacing="3" Justify="Justify.FlexStart">
    @if (templates == null)
    {
        <MudItem xs="12">
            @RenderLoadingOrError()
        </MudItem>
    }
    else if (filteredTemplates.Count() == 0)
    {
        <MudItem xs="12">
            <MudAlert Severity="Severity.Info" Variant="Variant.Outlined">
                No templates match the current filter.
            </MudAlert>
        </MudItem>
    }
    else
    {
        @foreach (var template in filteredTemplates)
        {
            <MudItem xs="12" sm="6" md="4" lg="3">
                @RenderTemplateCard()(template)
            </MudItem>
        }
    }
</MudGrid>

@code {
    [Parameter] public EventCallback<TemplateInfo> OnTemplateSelected { get; set; }
    [Parameter] public EventCallback<List<TemplateInfo>?> OnTemplatesLoaded { get; set; }
    [Parameter] public HashSet<string> SelectedTags { get; set; } = new();
    [Parameter] public TemplateInfo? SelectedTemplate { get; set; }
    
    private List<TemplateInfo>? templates;
    private string? selectedTemplateId;
    private List<TemplateInfo> filteredTemplates = new();
    private bool isLoading = true;

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to mode changes
        FeatureFlags.Changed += OnModeChanged;
        await LoadTemplatesAsync();
    }

    protected override void OnParametersSet()
    {
        // Sync selectedTemplateId with SelectedTemplate parameter
        selectedTemplateId = SelectedTemplate?.Id;
        ApplyFilter();
    }

    private async void OnModeChanged()
    {
        await LoadTemplatesAsync();
        // Clear selection since templates changed
        selectedTemplateId = null;
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadTemplatesAsync()
    {
        isLoading = true;
        try
        {
            await FeatureFlags.EnsureLoadedAsync();
            templates = await TemplateService.GetTemplatesAsync();
            ApplyFilter();
            await OnTemplatesLoaded.InvokeAsync(templates);
            await InvokeAsync(StateHasChanged);
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("FlowTime-Sim API") || ex.Message.Contains("FlowTime API"))
        {
            // API-specific error - don't show generic error, let the UI handle it
            templates = null;
            filteredTemplates = new List<TemplateInfo>();
            await OnTemplatesLoaded.InvokeAsync(templates);
            await InvokeAsync(StateHasChanged);
            var apiName = FeatureFlags.UseDemoMode ? "Demo templates" : "FlowTime API";
            NotificationService.Add($"{apiName} is not available", Severity.Warning);
        }
        catch (Exception ex)
        {
            NotificationService.Add($"Failed to load templates: {ex.Message}", Severity.Error);
            templates = null;
            filteredTemplates = new List<TemplateInfo>();
            await OnTemplatesLoaded.InvokeAsync(templates);
            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            isLoading = false;
        }
    }

    private void ApplyFilter()
    {
        if (templates == null)
        {
            filteredTemplates = new List<TemplateInfo>();
            return;
        }

        // If no tags selected, show all templates
        if (!SelectedTags.Any())
        {
            filteredTemplates = templates.ToList();
            return;
        }

        // Show templates that have ALL selected tags (AND logic)
        filteredTemplates = templates.Where(template =>
            SelectedTags.All(selectedTag => 
                template.Tags.Any(templateTag => 
                    templateTag.Equals(selectedTag, StringComparison.OrdinalIgnoreCase)))).ToList();
    }

    public void Dispose()
    {
        FeatureFlags.Changed -= OnModeChanged;
    }

    private async Task SelectTemplate(TemplateInfo template)
    {
        selectedTemplateId = template.Id;
        await OnTemplateSelected.InvokeAsync(template);
        StateHasChanged();
    }

    private string GetCardClass(TemplateInfo template)
    {
        var baseClass = "mb-2";
        if (template.Id == selectedTemplateId)
        {
            baseClass += " mud-theme-info";
        }
        return baseClass;
    }

    private Color GetCategoryColor(string category)
    {
        return category.ToLowerInvariant() switch
        {
            "transportation" => Color.Primary,
            "supply-chain" => Color.Secondary,
            "manufacturing" => Color.Tertiary,
            "network" => Color.Info,
            "finance" => Color.Success,
            _ => Color.Default
        };
    }

    private RenderFragment RenderLoadingOrError() => __builder =>
    {
        @if (isLoading)
        {
            @if (FeatureFlags.UseDemoMode)
            {
                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                <MudText Typo="Typo.body2">Loading demo templates...</MudText>
            }
            else
            {
                <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                <MudText Typo="Typo.body2">Connecting to FlowTime-Sim API...</MudText>
            }
        }
        else
        {
            @if (FeatureFlags.UseDemoMode)
            {
                <MudAlert Severity="Severity.Error" Class="mb-3">
                    <MudText Typo="Typo.body2">
                        <strong>Failed to Load Demo Templates</strong><br/>
                        An unexpected error occurred while loading built-in templates.
                    </MudText>
                </MudAlert>
            }
            else
            {
                <MudAlert Severity="Severity.Error" Class="mb-3">
                    <MudText Typo="Typo.body2">
                        <strong>FlowTime-Sim API Not Available</strong><br/>
                        Check that the FlowTime-Sim service is running and accessible.
                    </MudText>
                </MudAlert>
            }
        }
    };

    private RenderFragment<TemplateInfo> RenderTemplateCard() => template =>
        @<MudCard Class="@GetCardClass(template)" 
                 Style="cursor: pointer; height: 100%;" 
                 onclick="@(() => SelectTemplate(template))">
            <MudCardContent>
                <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Start" Class="mb-2">
                    <MudText Typo="Typo.h6">@template.Name</MudText>
                    @if (FeatureFlags.UseDemoMode)
                    {
                        <MudChip T="string" Size="Size.Small" Color="Color.Default" Variant="Variant.Outlined">
                            DEMO
                        </MudChip>
                    }
                </MudStack>
                <MudText Typo="Typo.body2" Class="mb-2">@template.Description</MudText>
                <MudChip T="string" Size="Size.Small" Color="Color.Default">
                    @template.Category
                </MudChip>
                @if (template.Tags.Any())
                {
                    <div class="mt-2">
                        @foreach (var tag in template.Tags)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Default" Variant="Variant.Outlined" Class="mr-1">
                                @tag
                            </MudChip>
                        }
                    </div>
                }
            </MudCardContent>
        </MudCard>;
}

@using FlowTime.UI.Services
@using FlowTime.UI.Configuration
@using System.Globalization
@using Microsoft.JSInterop
@using MudBlazor
@inject ISimResultsService SimResults
@inject INotificationService NotificationService
@inject IJSRuntime JSRuntime
@inject FeatureFlagService FeatureFlags
@inject IConfiguration Configuration
@inject IHttpClientFactory HttpClientFactory

<MudStack Spacing="4">
    @if (Result != null)
    {
        <MudCard Outlined="true">
            <MudCardContent>
                <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-3">
                    <MudText Typo="Typo.h6">Simulation Results</MudText>
                    <MudChip T="string" Color="@GetStatusColor(Result.Status)" Size="Size.Small">
                        @Result.Status.ToUpperInvariant()
                    </MudChip>
                </MudStack>
                
                <MudGrid>
                    <MudItem xs="12" sm="6" md="3">
                        <MudText Typo="Typo.caption">Run ID</MudText>
                        <MudText Typo="Typo.body2" Class="font-weight-bold">@Result.RunId</MudText>
                    </MudItem>
                    <MudItem xs="12" sm="6" md="3">
                        <MudText Typo="Typo.caption">Duration</MudText>
                        <MudText Typo="Typo.body2" Class="font-weight-bold">
                            @(Result.EndTime?.Subtract(Result.StartTime).TotalSeconds.ToString("F1") ?? "N/A") seconds
                        </MudText>
                    </MudItem>
                    <MudItem xs="12" sm="6" md="3">
                        <MudText Typo="Typo.caption">Started</MudText>
                        <MudText Typo="Typo.body2" Class="font-weight-bold">
                            @Result.StartTime.ToString("HH:mm:ss")
                        </MudText>
                    </MudItem>
                    <MudItem xs="12" sm="6" md="3">
                        <MudText Typo="Typo.caption">Completed</MudText>
                        <MudText Typo="Typo.body2" Class="font-weight-bold">
                            @(Result.EndTime?.ToString("HH:mm:ss") ?? "N/A")
                        </MudText>
                    </MudItem>
                </MudGrid>

                @if (!string.IsNullOrEmpty(Result.ErrorMessage))
                {
                    <MudAlert Severity="Severity.Error" Class="mt-3">
                        <MudText Typo="Typo.subtitle2">Error</MudText>
                        <MudText Typo="Typo.body2">@Result.ErrorMessage</MudText>
                    </MudAlert>
                }
                else if (Result.Status == "completed" && !string.IsNullOrEmpty(Result.ResultsUrl))
                {
                    @if (isLoadingResults)
                    {
                        <MudAlert Severity="Severity.Info" Class="mt-3">
                            <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                                <MudProgressCircular Size="@Size.Small" Indeterminate="true" />
                                <MudText Typo="Typo.body2">Loading simulation data...</MudText>
                            </MudStack>
                        </MudAlert>
                    }
                }

                @* Show actual series data when loaded (artifact-first pattern) *@
                @if (simulationData != null)
                {
                    <div class="mt-4">
                        <MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Class="mb-3">
                            <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
                                <MudIcon Icon="@Icons.Material.Filled.BarChart" />
                                <MudText Typo="Typo.h6">Time Series Data</MudText>
                                <MudChip T="string" Size="Size.Small" Color="Color.Info">
                                    @simulationData.Series.Count series
                                </MudChip>
                                <MudChip T="string" Size="Size.Small" Color="Color.Secondary">
                                    @simulationData.Bins time bins (@simulationData.BinSize @simulationData.BinUnit each)
                                </MudChip>
                            </MudStack>
                            

                        </MudStack>
                        
                        @{
                            var isITTemplate = Result?.Metadata?.GetValueOrDefault("templateId")?.ToString() == "it-system-microservices";
                            var isApiMode = !FeatureFlags.UseDemoMode;
                            var dataSource = Result?.Metadata?.GetValueOrDefault("source")?.ToString();
                        }
                        
                        @if (isITTemplate && isApiMode && dataSource == "sim")
                        {
                            <MudAlert Severity="Severity.Warning" Class="mb-3">
                                <MudText Typo="Typo.caption">
                                    <strong>Note:</strong> IT system templates work best in <strong>Demo mode</strong> for realistic microservices data. 
                                    API mode provides simplified queueing model results. Switch to Demo mode for detailed microservices telemetry.
                                </MudText>
                            </MudAlert>
                        }
                        
                        <MudAlert Severity="Severity.Info" Class="mb-3">
                            <MudText Typo="Typo.caption">
                                <strong>Data represents:</strong> @(isITTemplate ? "IT system microservices telemetry" : "Simulation time series"). 
                                Each series shows throughput (requests/transactions per time bin) over @FormatTotalTime(simulationData.Bins, simulationData.BinSize, simulationData.BinUnit).
                                Values are cumulative counts for each @FormatBinSize(simulationData.BinSize, simulationData.BinUnit) time window.
                            </MudText>
                        </MudAlert>
                        
                        <MudSimpleTable Striped="true" Dense="true">
                            <thead>
                                <tr>
                                    <th>Series ID</th>
                                    <th>Min</th>
                                    <th>Max</th>
                                    <th>Average</th>
                                    <th>Total</th>
                                    <th>Download</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var series in simulationData.Series)
                                {
                                    <tr>
                                        <td><strong>@series.Key</strong></td>
                                        <td>@series.Value.Min().ToString("F2")</td>
                                        <td>@series.Value.Max().ToString("F2")</td>
                                        <td>@series.Value.Average().ToString("F2")</td>
                                        <td>@series.Value.Sum().ToString("F2")</td>
                                        <td>
                                            <MudButton Variant="Variant.Text"
                                                     Color="Color.Primary"
                                                     Size="Size.Small"
                                                     StartIcon="@Icons.Material.Filled.Download"
                                                     OnClick="@(() => DownloadSeries(series.Key))">
                                                CSV
                                            </MudButton>
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </MudSimpleTable>
                    </div>
                }

                @* Show minimal metadata (artifact-first - metadata is not authoritative) *@
                @if (Result.Metadata.Any())
                {
                    <div class="mt-4">
                        <MudStack Row AlignItems="AlignItems.Center" Spacing="2" Class="mb-3">
                            <MudIcon Icon="@Icons.Material.Filled.Info" />
                            <MudText Typo="Typo.h6">Run Metadata</MudText>
                        </MudStack>
                        
                        @if (IsSimMode())
                        {
                            <MudAlert Severity="Severity.Info" Class="mb-2">
                                <MudText Typo="Typo.caption">
                                    Metadata shown here is not authoritative. Actual series data is loaded from artifacts above.
                                </MudText>
                            </MudAlert>
                        }
                        else
                        {
                            <MudAlert Severity="Severity.Success" Class="mb-2">
                                <MudText Typo="Typo.caption">
                                    Rich simulation metadata generated from FlowTime API. This includes model analysis and performance insights.
                                </MudText>
                            </MudAlert>
                        }
                        
                        <MudSimpleTable Striped="true" Dense="true">
                            <tbody>
                                @foreach (var item in Result.Metadata.Where(m => IsDisplayableMetadata(m.Key)))
                                {
                                    <tr>
                                        <td><strong>@FormatMetadataKey(item.Key)</strong></td>
                                        <td>@FormatMetadataValue(item.Value)</td>
                                    </tr>
                                }
                                @* Add grid information if simulation data is loaded *@
                                @if (simulationData != null)
                                {
                                    <tr>
                                        <td><strong>Grid Configuration</strong></td>
                                        <td>@simulationData.Bins bins × @simulationData.BinSize @simulationData.BinUnit each</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Time Coverage</strong></td>
                                        <td>@FormatTotalTime(simulationData.Bins, simulationData.BinSize, simulationData.BinUnit)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Series Count</strong></td>
                                        <td>@simulationData.Series.Count time series</td>
                                    </tr>
                                }
                            </tbody>
                        </MudSimpleTable>
                    </div>
                }
            </MudCardContent>
        </MudCard>
    }
</MudStack>

@code {
    [Parameter] public SimulationRunResult? Result { get; set; }
    [Parameter] public EventCallback OnViewResults { get; set; }
    [Parameter] public EventCallback OnDownloadResults { get; set; }

    private bool isLoadingResults;
    private bool hasLoadedResults;
    private SimResultData? simulationData;

    private Color GetStatusColor(string status)
    {
        return status.ToLowerInvariant() switch
        {
            "completed" => Color.Success,
            "failed" => Color.Error,
            "running" => Color.Warning,
            "pending" => Color.Info,
            _ => Color.Default
        };
    }

    private async Task LoadResults()
    {
        if (Result?.RunId == null || Result.Status != "completed" || string.IsNullOrEmpty(Result.ResultsUrl))
            return;

        isLoadingResults = true;
        StateHasChanged();

        try
        {
            // Load results using artifact-first pattern
            var result = await SimResults.GetSimulationResultsAsync(Result.RunId);
            
            if (result.Success && result.Value != null)
            {
                simulationData = result.Value;
                hasLoadedResults = true;
                
                // Trigger the parent callback
                await OnViewResults.InvokeAsync();
            }
            else
            {
                NotificationService.Add($"Failed to load simulation data: {result.Error}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            NotificationService.Add($"Error loading simulation results: {ex.Message}", Severity.Error);
        }
        finally
        {
            isLoadingResults = false;
            StateHasChanged();
        }
    }

    private async Task DownloadSeries(string seriesId)
    {
        if (Result?.RunId == null || string.IsNullOrEmpty(seriesId))
        {
            NotificationService.Add("Invalid series or run ID", Severity.Warning);
            return;
        }

        try
        {
            // Check for mode mismatch
            var resultSource = Result?.Metadata.GetValueOrDefault("source")?.ToString();
            var currentlyInDemoMode = FeatureFlags.UseDemoMode;
            
            if (resultSource == "sim" && !currentlyInDemoMode)
            {
                NotificationService.Add("This result was created in Demo mode, but you're currently in API mode. Switch to Demo mode to download.", Severity.Warning);
                return;
            }
            else if (resultSource != "sim" && currentlyInDemoMode)
            {
                NotificationService.Add("This result was created in API mode, but you're currently in Demo mode. Switch to API mode to download.", Severity.Warning);
                return;
            }

            // Determine the appropriate download URL based on current feature flag
            string downloadUrl;
            if (FeatureFlags.UseDemoMode)
            {
                // Demo mode: Use versioned URL to FlowTime-Sim API
                var simConfig = Configuration.GetSection(FlowTimeSimApiOptions.SectionName).Get<FlowTimeSimApiOptions>() 
                    ?? new FlowTimeSimApiOptions();
                var baseUrl = simConfig.BaseUrl?.TrimEnd('/') ?? "";
                downloadUrl = $"{baseUrl}/{simConfig.ApiVersion}/sim/runs/{Result.RunId}/series/{seriesId}";
            }
            else
            {
                // API mode: Use versioned URL to FlowTime API
                var apiConfig = Configuration.GetSection(FlowTimeApiOptions.SectionName).Get<FlowTimeApiOptions>() 
                    ?? new FlowTimeApiOptions();
                var baseUrl = apiConfig.BaseUrl?.TrimEnd('/') ?? "";
                downloadUrl = $"{baseUrl}/{apiConfig.ApiVersion}/runs/{Result.RunId}/series/{seriesId}";
            }
            
            // Open download URL in new tab to trigger browser download
            await JSRuntime.InvokeVoidAsync("window.open", downloadUrl, "_blank");
            NotificationService.Add($"Downloading {seriesId}.csv", Severity.Success);
        }
        catch (Exception ex)
        {
            NotificationService.Add($"Error downloading series {seriesId}: {ex.Message}", Severity.Error);
        }
    }

    private string FormatMetadataValue(object value)
    {
        return value switch
        {
            Dictionary<string, object> dict => string.Join(", ", dict.Select(kvp => $"{kvp.Key}: {FormatNestedValue(kvp.Value)}")),
            string str => str,
            IEnumerable<object> list => string.Join(", ", list.Select(FormatNestedValue)),
            _ => value?.ToString() ?? string.Empty
        };
    }

    private string FormatNestedValue(object value)
    {
        return value switch
        {
            double d => d.ToString("F2", CultureInfo.InvariantCulture),
            float f => f.ToString("F2", CultureInfo.InvariantCulture),
            decimal m => m.ToString("F2", CultureInfo.InvariantCulture),
            _ => value?.ToString() ?? string.Empty
        };
    }

    private string FormatMetadataKey(string key)
    {
        // Convert camelCase to Title Case for better display
        return System.Text.RegularExpressions.Regex.Replace(key, @"([A-Z])", " $1").Trim()
            .Replace("Id", "ID")
            .Replace("Url", "URL")
            .Replace("Api", "API");
    }

    private static bool IsDisplayableMetadata(string key)
    {
        // For Sim mode: Only show basic metadata - artifacts are authoritative for actual data
        // For API mode: Show all rich metadata
        return key is not ("source"); // Hide internal source field
    }

    private string FormatBinSize(int binSize, string binUnit)
    {
        // Format bin size with unit (e.g., "1 hour", "60 minutes", "2 days")
        var unit = binSize == 1 ? binUnit.TrimEnd('s') : binUnit; // Singular if size is 1
        return $"{binSize} {unit}";
    }

    private string FormatTotalTime(int bins, int binSize, string binUnit)
    {
        // Calculate total time and format in the most appropriate unit
        var totalMinutes = bins * (binUnit.ToLowerInvariant() switch
        {
            "minutes" => binSize,
            "hours" => binSize * 60,
            "days" => binSize * 1440,
            "weeks" => binSize * 10080,
            _ => binSize
        });

        // Choose most appropriate display unit
        if (totalMinutes < 60) return $"{totalMinutes} minutes";
        if (totalMinutes < 1440) return $"{totalMinutes / 60.0:F1} hours";
        if (totalMinutes < 10080) return $"{totalMinutes / 1440.0:F1} days";
        return $"{totalMinutes / 10080.0:F1} weeks";
    }

    private bool IsSimMode()
    {
        // Check current feature flag setting rather than just result metadata
        // This ensures downloads use the correct service based on current mode
        return FeatureFlags.UseDemoMode;
    }

    private string? lastLoadedRunId;
    
    protected override async Task OnParametersSetAsync()
    {
        // Reset state when Result changes - use RunId comparison to avoid endless loops
        var currentRunId = Result?.RunId;
        if (currentRunId != null && currentRunId != lastLoadedRunId)
        {
            hasLoadedResults = false;
            simulationData = null;
            lastLoadedRunId = null;
            
            // Auto-load results for completed runs
            if (Result?.Status == "completed" && !string.IsNullOrEmpty(Result.ResultsUrl))
            {
                await LoadResults();
                lastLoadedRunId = currentRunId;
            }
        }
    }
}

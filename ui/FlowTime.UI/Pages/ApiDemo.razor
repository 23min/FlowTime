@page "/api-demo"
@layout ExpertLayout
@using FlowTime.UI.Services
@using FlowTime.UI.Components
@using MudBlazor
@inject IRunClient RunClient
@inject HttpClient Http
@inject ISnackbar Snackbar
@inject PreferencesService Prefs

<PageTitle>API Demo</PageTitle>

<MudText Typo="Typo.h4" GutterBottom="true">API Demo</MudText>
<MudText Class="mb-1">Interact with FlowTime API using the typed client.</MudText>
<MudText Typo="Typo.caption" Class="mb-4" Style="font-family:monospace">Client Mode: @(clientModeLabel)
</MudText>
@if (Flags.UseDemoMode)
{
    <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Elevation="0" Class="mb-4">
        <b>Demo Mode:</b> Showing deterministic stub outputs (optimized for UI iteration). The <em>extended</em> model
        selection does not change demo numeric results. Switch to <b>API</b> mode to evaluate the real model.
    </MudAlert>
}

@if (anyLoading)
{
    <MudProgressLinear Indeterminate="true" Color="Color.Primary" Class="mb-3" />
}

<MudPaper Class="pa-4 mb-4" Elevation="1">
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-2">
        <MudText Typo="Typo.h6" Class="mb-0">Model</MudText>
        <MudSelect T="string" Value="@selectedModelKey" ValueChanged="HandleModelChanged" Dense="true"
            Variant="Variant.Outlined" Style="min-width:220px">
            @foreach (var kv in modelCatalog)
            {
                <MudSelectItem Value="@kv.Key">@kv.Key</MudSelectItem>
            }
        </MudSelect>
        <MudTooltip Text="Switch between predefined static models (no editing in this milestone).">
            <MudIcon Color="Color.Info" Icon="@Icons.Material.Filled.Info" />
        </MudTooltip>
    </MudStack>
    <MudPaper Class="pa-2 code-block" Elevation="0">@CurrentModelYaml</MudPaper>
    <MudStack Row="true" Spacing="2" Class="mt-3">
        <MudButton Variant="Variant.Filled" Class="action-btn" Color="@RunButtonColor" OnClick="RunModel"
            Disabled="@runLoading">
            @if (runLoading)
            {
                <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
            }
            @RunButtonLabel
        </MudButton>
        <MudButton Variant="Variant.Outlined" Class="action-btn" Color="@GraphButtonColor" OnClick="GraphModel"
            Disabled="@graphLoading">
            @if (graphLoading)
            {
                <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
            }
            @GraphButtonLabel
        </MudButton>
    </MudStack>
</MudPaper>

<MudExpansionPanels MultiExpansion="true">
    @if (runResult is not null)
    {
        <MudExpansionPanel Text="Run Result (series)" Expanded="@expandRun">
            <MudText Typo="Typo.subtitle2" Class="mb-2">Order: @string.Join(", ", runResult.Order)</MudText>
            @if (Flags.UseDemoMode && selectedModelKey != "simple")
            {
                <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Elevation="0" Dense="true" Class="mb-3">
                    Extended model selected, but demo mode returns fixed simple model data.
                </MudAlert>
            }
            <MudTable T="KeyValuePair<string, double[]>" Items="runResult.Series" Dense="true" Hover="true" Bordered="true"
                Striped="true" Elevation="0">
                <HeaderContent>
                    <MudTh>Series</MudTh>
                    <MudTh>Values</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Series">@context.Key</MudTd>
                    <MudTd DataLabel="Values">@string.Join(", ", context.Value)</MudTd>
                </RowTemplate>
            </MudTable>
            @if (chartSeries?.Count > 0)
            {
                <MudText Typo="Typo.caption" Class="mt-4 mb-1" Style="opacity:.75;">Series</MudText>
                <MudChart @key="chartRenderVersion" Class="mb-2" Style="height:220px;" ChartType="ChartType.Line"
                    XAxisLabels="@chartLabels" ChartSeries="@chartSeries" />
                @if (!string.IsNullOrEmpty(chartDiag))
                {
                    <MudText Typo="Typo.caption" Class="mb-2" Style="font-family:monospace; opacity:.55;">@chartDiag</MudText>
                }
            }
        </MudExpansionPanel>
    }
    @if (graphResult is not null)
    {
        var stats = ComputeGraphStats(graphResult);
        <MudExpansionPanel Text="Graph Structure" Expanded="@expandGraph">
            <MudText Typo="Typo.subtitle2" Class="mb-2">Order: @string.Join(", ", graphResult.Order)</MudText>
            <MudText Typo="Typo.caption" Class="mb-2">Nodes: @stats.Total · Sources: @stats.Sources · Sinks: @stats.Sinks ·
                Max FanOut: @stats.MaxFanOut</MudText>
            @if (Flags.UseDemoMode && selectedModelKey != "simple")
            {
                <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Elevation="0" Dense="true" Class="mb-3">
                    Structural graph reflects simulation stub, not the extended model.
                </MudAlert>
            }
            <MudTable T="NodeInfoView" Hover="true" Dense="true" Items="nodeViews" Elevation="0" Bordered="true"
                Striped="true">
                <HeaderContent>
                    <MudTh>#</MudTh>
                    <MudTh>Node</MudTh>
                    <MudTh>Inputs</MudTh>
                    <MudTh>In</MudTh>
                    <MudTh>Out</MudTh>
                    <MudTh>Role</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="#">@context.Order</MudTd>
                    <MudTd DataLabel="Node">@context.Id</MudTd>
                    <MudTd DataLabel="Inputs">@string.Join(", ", context.Inputs)</MudTd>
                    <MudTd DataLabel="In">@context.InDegree</MudTd>
                    <MudTd DataLabel="Out">@context.OutDegree</MudTd>
                    <MudTd DataLabel="Role">
                        @if (context.IsSource)
                        {
                            <MudChip T="string" Color="Color.Info" Variant="Variant.Outlined" Size="Size.Small">source</MudChip>
                        }
                        @if (context.IsSink)
                        {
                            <MudChip T="string" Color="Color.Warning" Variant="Variant.Outlined" Size="Size.Small">sink
                            </MudChip>
                        }
                    </MudTd>
                </RowTemplate>
            </MudTable>
            <MudDivider Class="my-3" />
            <MudText Typo="Typo.caption" Class="mb-1" Style="opacity:.75;">Micro DAG</MudText>
            <MicroDag Structure="graphResult" Height="140" />
        </MudExpansionPanel>
    }
</MudExpansionPanels>

@code {
    private bool runLoading, graphLoading;
    private GraphRunResult? runResult;
    private GraphStructureResult? graphResult;
    private List<NodeInfoView> nodeViews = new();
    private string clientModeLabel = "api";
    [Inject] private FeatureFlagService Flags { get; set; } = default!;
    private string? lastError;

    private enum ReqState { Idle, Loading }
    private enum Outcome { None, Success, Failed }
    private ReqState runState = ReqState.Idle;
    private ReqState graphState = ReqState.Idle;
    private bool expandRun = true;
    private bool expandGraph = false;

    // Model catalog loaded from static files in wwwroot/models (no editing in this milestone)
    private readonly Dictionary<string, string> modelCatalog = new();

    private string selectedModelKey = "simple"; // overridden by stored pref if present
    private string CurrentModelYaml => modelCatalog.TryGetValue(selectedModelKey, out var y) ? y : "(model not loaded)";

    private void OnModelChanged()
    {
        // Reset previous results when switching models
        runResult = null;
        graphResult = null;
        nodeViews.Clear();
        chartSeries?.Clear();
    }
    private async Task HandleModelChanged(string key)
    {
        selectedModelKey = key;
        OnModelChanged();
        await Prefs.SetModelKeyAsync(selectedModelKey);
        StateHasChanged();
    }

    private async Task RunModel()
    {
        runLoading = true;
        runState = ReqState.Loading;
        lastError = null;
        try
        {
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(12));
            Console.WriteLine($"[ApiDemo] Running model key='{selectedModelKey}' ({CurrentModelYaml.Length} chars)");
            var yaml = CurrentModelYaml; // snapshot in case user switches mid-run
            var res = await RunClient.RunAsync(yaml, cts.Token);
            if (res.Success && res.Value is not null)
            {
                runResult = res.Value;
                BuildChart();
                expandRun = true;
                expandGraph = false;
                // success outcome only reflected via results presence; no chip for run
            }
            else
            {
                runResult = null;
                lastError = $"Run failed ({res.StatusCode}): {res.Error}";
                // failure; no chip, error via snackbar
                Snackbar.Add(lastError, Severity.Error);
            }
        }
        catch (Exception ex)
        {
            runResult = null;
            // failure; no chip
            lastError = $"Run error: {ex.Message}";
            Snackbar.Add(lastError, Severity.Error);
        }
        finally { runLoading = false; runState = ReqState.Idle; await InvokeAsync(StateHasChanged); }
    }

    private async Task GraphModel()
    {
        graphLoading = true;
        graphState = ReqState.Loading;
        lastError = null;
        try
        {
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(12));
            Console.WriteLine($"[ApiDemo] Graph model key='{selectedModelKey}' ({CurrentModelYaml.Length} chars)");
            var yaml = CurrentModelYaml;
            var res = await RunClient.GraphAsync(yaml, cts.Token);
            if (res.Success && res.Value is not null)
            {
                graphResult = res.Value;
                nodeViews = BuildNodeViews(graphResult);
                expandGraph = true;
                expandRun = false;
            }
            else
            {
                graphResult = null;
                nodeViews.Clear();
                lastError = $"Graph failed ({res.StatusCode}): {res.Error}";
                // failure outcome; no chip
                Snackbar.Add(lastError, Severity.Error);
            }
        }
        catch (Exception ex)
        {
            graphResult = null;
            // failure outcome
            lastError = $"Graph error: {ex.Message}";
            Snackbar.Add(lastError, Severity.Error);
        }
        finally { graphLoading = false; graphState = ReqState.Idle; await InvokeAsync(StateHasChanged); }
    }

    // Removed sample JSON fallback loaders.

    private string RunButtonLabel => runState == ReqState.Loading ? "Running..." : "Run /run";
    private Color RunButtonColor => Color.Secondary; // always neutral
    private string GraphButtonLabel => graphState == ReqState.Loading ? "Loading..." : "Graph /graph";
    private Color GraphButtonColor => Color.Secondary; // always neutral

    private bool anyLoading => runState == ReqState.Loading || graphState == ReqState.Loading;

    private record NodeInfoView(int Order, string Id, IReadOnlyList<string> Inputs, int InDegree, int OutDegree, bool
    IsSource, bool IsSink);

    // Charting
    private List<ChartSeries>? chartSeries;
    private string[]? chartLabels;
    private string? chartDiag;
    private int chartRenderVersion = 0;
    private void BuildChart()
    {
        if (runResult is null) { chartSeries = null; chartLabels = null; chartDiag = null; return; }
        chartLabels = Enumerable.Range(0, runResult.Bins).Select(i => i.ToString()).ToArray();
        if (runResult.Series.Count == 0) { chartSeries = new List<ChartSeries>(); chartDiag = "(no series)"; return; }
        // Respect declared evaluation order, but only include those with data, up to 4
        chartSeries = new List<ChartSeries>();
        int idx = 0;
        var diagParts = new List<string>();
        foreach (var name in runResult.Order)
        {
            if (!runResult.Series.TryGetValue(name, out var raw)) continue;
            if (idx++ == 4) break;
            var data = raw.Select(v => v).ToArray();
            // (debug logging removed)
            chartSeries.Add(new ChartSeries { Name = name, Data = data });
            var (min, max) = (data.Min(), data.Max());
            diagParts.Add(FormatSeriesRange(name, min, max));
        }
        chartDiag = string.Join(" | ", diagParts);
        // Constant series now render correctly after MudBlazor upgrade.
        chartRenderVersion++; // force re-render
    }

    private static string FormatSeriesRange(string name, double min, double max)
    => min == max ? $"{name}:{min:0.###}" : $"{name}:{min:0.###}-{max:0.###}";


    private List<NodeInfoView> BuildNodeViews(GraphStructureResult g)
    {
        var inDeg = new Dictionary<string, int>();
        var outDeg = new Dictionary<string, int>();
        var orderIndex = new Dictionary<string, int>();
        for (int i = 0; i < g.Order.Count; i++) orderIndex[g.Order[i]] = i;
        foreach (var n in g.Nodes)
        {
            if (!outDeg.ContainsKey(n.Id)) outDeg[n.Id] = 0;
            foreach (var inp in n.Inputs)
            {
                inDeg[inp] = inDeg.TryGetValue(inp, out var v) ? v + 1 : 1;
                outDeg[n.Id] = outDeg[n.Id] + 1;
            }
            if (!inDeg.ContainsKey(n.Id)) inDeg[n.Id] = inDeg.GetValueOrDefault(n.Id, 0);
        }
        return g.Nodes.Select(n => new NodeInfoView(
        orderIndex.GetValueOrDefault(n.Id, int.MaxValue),
        n.Id,
        n.Inputs,
        inDeg.GetValueOrDefault(n.Id, 0),
        outDeg.GetValueOrDefault(n.Id, 0),
        n.Inputs.Count == 0,
        !g.Nodes.Any(other => other.Inputs.Contains(n.Id))
        )).OrderBy(v => v.Order).ThenBy(v => v.Id).ToList();
    }

    private (int Total, int Sources, int Sinks, int MaxFanOut) ComputeGraphStats(GraphStructureResult g)
    {
        var views = nodeViews.Count > 0 ? nodeViews : BuildNodeViews(g);
        return (views.Count, views.Count(v => v.IsSource), views.Count(v => v.IsSink), views.Count == 0 ? 0 : views.Max(v =>
        v.OutDegree));
    }

    protected override async Task OnInitializedAsync()
    {
        await Flags.EnsureLoadedAsync();
        clientModeLabel = Flags.UseDemoMode ? "demo" : "api";
        Flags.Changed += OnFlagsChanged;
        await Prefs.EnsureLoadedAsync();
        await LoadModelsAsync();
        if (!string.IsNullOrWhiteSpace(Prefs.ModelKey) && modelCatalog.ContainsKey(Prefs.ModelKey))
        {
            selectedModelKey = Prefs.ModelKey;
        }
    }

    private async void OnFlagsChanged()
    {
        clientModeLabel = Flags.UseDemoMode ? "demo" : "api";
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose() => Flags.Changed -= OnFlagsChanged;

    private async Task LoadModelsAsync()
    {
        try
        {
            // Load both models; ignore if already loaded
            if (!modelCatalog.ContainsKey("simple"))
            {
                var simple = await Http.GetStringAsync("/models/simple.yaml");
                modelCatalog["simple"] = simple;
            }
            if (!modelCatalog.ContainsKey("extended"))
            {
                var extended = await Http.GetStringAsync("/models/extended.yaml");
                modelCatalog["extended"] = extended;
            }
        }
        catch (Exception ex)
        {
            lastError = "Model load error: " + ex.Message;
            Snackbar.Add(lastError, Severity.Error);
        }
    }

}

@page "/api-demo"
@using FlowTime.UI.Services
@using FlowTime.UI.Components
@using MudBlazor
@inject IRunClient RunClient
@inject HttpClient Http
@inject ISnackbar Snackbar

<PageTitle>API Demo</PageTitle>

<MudText Typo="Typo.h4" GutterBottom="true">API Demo</MudText>
<MudText Class="mb-1">Interact with FlowTime API using the typed client.</MudText>
<MudText Typo="Typo.caption" Class="mb-4" Style="font-family:monospace">Client Mode: @(clientModeLabel)
</MudText>
@if (Flags.UseSimulation)
{
    <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Elevation="0" Class="mb-4">
        <b>Simulation Mode:</b> Showing deterministic stub outputs (optimized for UI iteration). The <em>extended</em> model selection does not change simulated numeric results. Switch to <b>API</b> mode to evaluate the real model.
    </MudAlert>
}

@if (anyLoading)
{
    <MudProgressLinear Indeterminate="true" Color="Color.Primary" Class="mb-3" />
}

<MudPaper Class="pa-4 mb-4" Elevation="1">
    <MudStack Row="true" Spacing="2">
        <MudButton Variant="Variant.Filled" Class="action-btn" Color="@HealthButtonColor" OnClick="CheckHealth" Disabled="@healthLoading">
            @if (healthLoading)
            {
                <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
            }
            @HealthButtonLabel
        </MudButton>
    @if (healthOutcome == Outcome.Success && health is not null)
        {
            <MudChip T="string" Color="Color.Success" Variant="Variant.Filled">ok</MudChip>
        }
    else if (healthOutcome == Outcome.Failed)
        {
            <MudChip T="string" Color="Color.Error" Variant="Variant.Filled">failed</MudChip>
        }
    </MudStack>
</MudPaper>

<MudPaper Class="pa-4 mb-4" Elevation="1">
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-2">
        <MudText Typo="Typo.h6" Class="mb-0">Model</MudText>
        <MudSelect T="string" Value="@selectedModelKey" ValueChanged="HandleModelChanged" Dense="true" Variant="Variant.Outlined" Style="min-width:220px"  AnchorOrigin="Origin.BottomCenter">
            @foreach (var kv in modelCatalog)
            {
                <MudSelectItem Value="@kv.Key">@kv.Key</MudSelectItem>
            }
        </MudSelect>
        <MudTooltip Text="Switch between predefined static models (no editing in this milestone).">
            <MudIcon Color="Color.Info" Icon="@Icons.Material.Filled.Info" />
        </MudTooltip>
    </MudStack>
    <MudPaper Class="pa-2 code-block" Elevation="0">@CurrentModelYaml</MudPaper>
    <MudStack Row="true" Spacing="2" Class="mt-3">
    <MudButton Variant="Variant.Filled" Class="action-btn" Color="@RunButtonColor" OnClick="RunModel" Disabled="@runLoading">
    @if (runLoading) { <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" /> }
        @RunButtonLabel
    </MudButton>
    <MudButton Variant="Variant.Outlined" Class="action-btn" Color="@GraphButtonColor" OnClick="GraphModel" Disabled="@graphLoading">
    @if (graphLoading) { <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" /> }
        @GraphButtonLabel
    </MudButton>
    </MudStack>
</MudPaper>

<MudExpansionPanels MultiExpansion="true">
    @if (runResult is not null)
    {
    <MudExpansionPanel Text="Run Result (series)" Expanded="@expandRun">
            <MudText Typo="Typo.subtitle2" Class="mb-2">Order: @string.Join(", ", runResult.Order)</MudText>
            @if (Flags.UseSimulation && selectedModelKey != "simple")
            {
                <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Elevation="0" Dense="true" Class="mb-3">
                    Extended model selected, but simulation client returns fixed simple model data.
                </MudAlert>
            }
            <MudTable T="KeyValuePair<string, double[]>" Items="runResult.Series" Dense="true" Hover="true" Bordered="true"
                Striped="true" Elevation="0">
                <HeaderContent>
                    <MudTh>Series</MudTh>
                    <MudTh>Values</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Series">@context.Key</MudTd>
                    <MudTd DataLabel="Values">@string.Join(", ", context.Value)</MudTd>
                </RowTemplate>
            </MudTable>
            @if (chartSeries?.Count > 0)
            {
                <MudText Typo="Typo.caption" Class="mt-4 mb-1" Style="opacity:.75;">Chart (first up to 4 series)</MudText>
                <MudChart Class="mb-2" ChartType="ChartType.Line" labels="@chartLabels" datasets="@chartSeries" />
            }
        </MudExpansionPanel>
    }
    @if (graphResult is not null)
    {
        var stats = ComputeGraphStats(graphResult);
    <MudExpansionPanel Text="Graph Structure" Expanded="@expandGraph">
            <MudText Typo="Typo.subtitle2" Class="mb-2">Order: @string.Join(", ", graphResult.Order)</MudText>
            <MudText Typo="Typo.caption" Class="mb-2">Nodes: @stats.Total · Sources: @stats.Sources · Sinks: @stats.Sinks · Max FanOut: @stats.MaxFanOut</MudText>
            @if (Flags.UseSimulation && selectedModelKey != "simple")
            {
                <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Elevation="0" Dense="true" Class="mb-3">
                    Structural graph reflects simulation stub, not the extended model.
                </MudAlert>
            }
        <MudTable T="NodeInfoView" Hover="true" Dense="true" Items="nodeViews" Elevation="0" Bordered="true" Striped="true">
                <HeaderContent>
            <MudTh>#</MudTh>
                    <MudTh>Node</MudTh>
                    <MudTh>Inputs</MudTh>
                    <MudTh>In</MudTh>
                    <MudTh>Out</MudTh>
                    <MudTh>Role</MudTh>
                </HeaderContent>
                <RowTemplate>
            <MudTd DataLabel="#">@context.Order</MudTd>
                    <MudTd DataLabel="Node">@context.Id</MudTd>
                    <MudTd DataLabel="Inputs">@string.Join(", ", context.Inputs)</MudTd>
                    <MudTd DataLabel="In">@context.InDegree</MudTd>
                    <MudTd DataLabel="Out">@context.OutDegree</MudTd>
                    <MudTd DataLabel="Role">
                        @if (context.IsSource) { <MudChip T="string" Color="Color.Info" Variant="Variant.Outlined" Size="Size.Small">source</MudChip> }
                        @if (context.IsSink) { <MudChip T="string" Color="Color.Warning" Variant="Variant.Outlined" Size="Size.Small">sink</MudChip> }
                    </MudTd>
                </RowTemplate>
            </MudTable>
            <MudDivider Class="my-3" />
            <MudText Typo="Typo.caption" Class="mb-1" Style="opacity:.75;">Micro DAG</MudText>
            <MicroDag Structure="graphResult" Height="140" />
        </MudExpansionPanel>
    }
</MudExpansionPanels>

@code {
    private bool healthLoading, runLoading, graphLoading;
    private bool? health;
    private GraphRunResult? runResult;
    private GraphStructureResult? graphResult;
    private List<NodeInfoView> nodeViews = new();
    private string clientModeLabel = "api";
    [Inject] private FeatureFlagService Flags { get; set; } = default!;
    private string? lastError;
    // No auto health probe; user initiated only per requirements.

    private enum ReqState { Idle, Loading }
    private enum Outcome { None, Success, Failed }
    private ReqState healthState = ReqState.Idle;
    private ReqState runState = ReqState.Idle;
    private ReqState graphState = ReqState.Idle;
    private Outcome healthOutcome = Outcome.None; // still used for health chip
    private bool expandRun = true;
    private bool expandGraph = false;

    // Static model catalog (no editing in this milestone)
    private readonly Dictionary<string,string> modelCatalog = new()
    {
        ["simple"] =
            "grid:\n" +
            "  bins: 8\n" +
            "  binMinutes: 60\n" +
            "nodes:\n" +
            "  - id: demand\n" +
            "    kind: const\n" +
            "    values: [10,10,10,10,10,10,10,10]\n" +
            "  - id: served\n" +
            "    kind: expr\n" +
            "    expr: \"demand * 0.8\"\n" +
            "outputs:\n" +
            "  - series: served\n" +
            "    as: served.csv\n",
        ["extended"] =
            "grid:\n" +
            "  bins: 8\n" +
            "  binMinutes: 60\n" +
            "nodes:\n" +
            "  - id: demand\n" +
            "    kind: const\n" +
            "    values: [12,14,16,18,20,18,16,14]\n" +
            "  - id: adjusted\n" +
            "    kind: expr\n" +
            "    expr: \"demand * 0.75\"\n" +
            "  - id: boosted\n" +
            "    kind: expr\n" +
            "    expr: \"adjusted + 5\"\n" +
            "  - id: final\n" +
            "    kind: expr\n" +
            "    expr: \"boosted * 1.1\"\n" +
            "outputs:\n" +
            "  - series: final\n" +
            "    as: final.csv\n"
    };

    private string selectedModelKey = "simple";
    private string CurrentModelYaml => modelCatalog[selectedModelKey];
    private void OnModelChanged()
    {
        // Reset previous results when switching models
        runResult = null;
        graphResult = null;
        nodeViews.Clear();
        chartSeries?.Clear();
    }
    private Task HandleModelChanged(string key)
    {
        selectedModelKey = key;
        OnModelChanged();
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task CheckHealth()
    {
        healthLoading = true;
        healthState = ReqState.Loading;
        lastError = null;
        try
        {
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(8));
            var res = await RunClient.HealthAsync(cts.Token);
            if (res.Success)
            {
                health = true;
                healthOutcome = Outcome.Success;
            }
            else
            {
                health = null;
                lastError = $"Health failed ({res.StatusCode}): {res.Error}";
                healthOutcome = Outcome.Failed;
                Snackbar.Add(lastError, Severity.Error);
            }
        }
        catch
        {
            healthOutcome = Outcome.Failed;
            lastError = "Health request error (offline)";
            Snackbar.Add(lastError, Severity.Error);
        }
        finally { healthLoading = false; healthState = ReqState.Idle; await InvokeAsync(StateHasChanged); }
    }

    // Removed OnAfterRender auto health + sample pre-population.

    private async Task RunModel()
    {
        runLoading = true;
        runState = ReqState.Loading;
        lastError = null;
        try
        {
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(12));
            Console.WriteLine($"[ApiDemo] Running model key='{selectedModelKey}' ({CurrentModelYaml.Length} chars)");
            var yaml = CurrentModelYaml; // snapshot in case user switches mid-run
            var res = await RunClient.RunAsync(yaml, cts.Token);
            if (res.Success && res.Value is not null)
            {
                runResult = res.Value;
                BuildChart();
                expandRun = true;
                expandGraph = false;
                // success outcome only reflected via results presence; no chip for run
            }
            else
            {
                runResult = null;
                lastError = $"Run failed ({res.StatusCode}): {res.Error}";
                // failure; no chip, error via snackbar
                Snackbar.Add(lastError, Severity.Error);
            }
        }
        catch (Exception ex)
        {
            runResult = null;
            // failure; no chip
            lastError = $"Run error: {ex.Message}";
            Snackbar.Add(lastError, Severity.Error);
        }
        finally { runLoading = false; runState = ReqState.Idle; await InvokeAsync(StateHasChanged); }
    }

    private async Task GraphModel()
    {
        graphLoading = true;
        graphState = ReqState.Loading;
        lastError = null;
        try
        {
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(12));
            Console.WriteLine($"[ApiDemo] Graph model key='{selectedModelKey}' ({CurrentModelYaml.Length} chars)");
            var yaml = CurrentModelYaml;
            var res = await RunClient.GraphAsync(yaml, cts.Token);
            if (res.Success && res.Value is not null)
            {
                graphResult = res.Value;
                nodeViews = BuildNodeViews(graphResult);
                expandGraph = true;
                expandRun = false;
            }
            else
            {
                graphResult = null;
                nodeViews.Clear();
                lastError = $"Graph failed ({res.StatusCode}): {res.Error}";
                // failure outcome; no chip
                Snackbar.Add(lastError, Severity.Error);
            }
        }
        catch (Exception ex)
        {
            graphResult = null;
            // failure outcome
            lastError = $"Graph error: {ex.Message}";
            Snackbar.Add(lastError, Severity.Error);
        }
        finally { graphLoading = false; graphState = ReqState.Idle; await InvokeAsync(StateHasChanged); }
    }

    // Removed sample JSON fallback loaders.

    private string HealthButtonLabel => healthState == ReqState.Loading ? "Checking..." : "Check Health";
    private Color HealthButtonColor => Color.Primary; // always neutral color
    private string RunButtonLabel => runState == ReqState.Loading ? "Running..." : "Run /run";
    private Color RunButtonColor => Color.Secondary; // always neutral
    private string GraphButtonLabel => graphState == ReqState.Loading ? "Loading..." : "Graph /graph";
    private Color GraphButtonColor => Color.Secondary; // always neutral

    private bool anyLoading => healthState == ReqState.Loading || runState == ReqState.Loading || graphState == ReqState.Loading;

    private record NodeInfoView(int Order, string Id, IReadOnlyList<string> Inputs, int InDegree, int OutDegree, bool IsSource, bool IsSink);

    // Charting
    private List<ChartSeries>? chartSeries;
    private string[]? chartLabels;
    private void BuildChart()
    {
        if (runResult is null) { chartSeries = null; chartLabels = null; return; }
        chartLabels = Enumerable.Range(0, runResult.Bins).Select(i => i.ToString()).ToArray();
        // Limit to first 4 series to avoid clutter
        chartSeries = runResult.Series.Take(4).Select(kv => new ChartSeries
        {
            Name = kv.Key,
            Data = kv.Value.Select(v => v).ToArray()
        }).ToList();
    }

    private List<NodeInfoView> BuildNodeViews(GraphStructureResult g)
    {
        var inDeg = new Dictionary<string,int>();
        var outDeg = new Dictionary<string,int>();
        var orderIndex = new Dictionary<string,int>();
        for (int i=0;i<g.Order.Count;i++) orderIndex[g.Order[i]] = i;
        foreach (var n in g.Nodes)
        {
            if (!outDeg.ContainsKey(n.Id)) outDeg[n.Id]=0;
            foreach (var inp in n.Inputs)
            {
                inDeg[inp] = inDeg.TryGetValue(inp, out var v)? v+1 : 1;
                outDeg[n.Id] = outDeg[n.Id] + 1;
            }
            if (!inDeg.ContainsKey(n.Id)) inDeg[n.Id]=inDeg.GetValueOrDefault(n.Id,0);
        }
        return g.Nodes.Select(n => new NodeInfoView(
            orderIndex.GetValueOrDefault(n.Id, int.MaxValue),
            n.Id,
            n.Inputs,
            inDeg.GetValueOrDefault(n.Id,0),
            outDeg.GetValueOrDefault(n.Id,0),
            n.Inputs.Count==0,
            !g.Nodes.Any(other => other.Inputs.Contains(n.Id))
        )).OrderBy(v=>v.Order).ThenBy(v=>v.Id).ToList();
    }

    private (int Total,int Sources,int Sinks,int MaxFanOut) ComputeGraphStats(GraphStructureResult g)
    {
        var views = nodeViews.Count>0? nodeViews : BuildNodeViews(g);
        return (views.Count, views.Count(v=>v.IsSource), views.Count(v=>v.IsSink), views.Count==0?0:views.Max(v=>v.OutDegree));
    }

    protected override async Task OnInitializedAsync()
    {
        await Flags.EnsureLoadedAsync();
        clientModeLabel = Flags.UseSimulation ? "sim" : "api";
        Flags.Changed += OnFlagsChanged;
    }

    private async void OnFlagsChanged()
    {
        clientModeLabel = Flags.UseSimulation ? "sim" : "api";
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose() => Flags.Changed -= OnFlagsChanged;

}

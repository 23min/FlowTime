@page "/api-demo"
@using FlowTime.UI.Services
@using FlowTime.UI.Components
@using MudBlazor
@inject IRunClient RunClient
@inject HttpClient Http
@inject INotificationService NotificationService
@inject PreferencesService Prefs

<PageTitle>API Testing (FlowTime Engine)</PageTitle>

<MudText Typo="Typo.h4" GutterBottom="true">API Testing</MudText>
<MudText Class="mb-4">Interact with FlowTime Engine API through a guided workflow.</MudText>

@if (Flags.UseDemoMode)
{
    <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Elevation="0" Class="mb-4">
        <b>Demo Mode:</b> Showing deterministic stub outputs (optimized for UI iteration). The <em>extended</em> model
        selection does not change demo numeric results. Switch to <b>API</b> mode to evaluate the real model.
    </MudAlert>
}

@if (anyLoading)
{
    <MudProgressLinear Indeterminate="true" Color="Color.Primary" Class="mb-3" />
}

<MudTabs Elevation="2" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-6" Class="api-wizard-tabs" @bind-ActivePanelIndex="activeTabIndex">
    <MudTabPanel Text="1. Model" Icon="@Icons.Material.Filled.Description">
        <MudText Typo="Typo.h6" Class="mb-3">Select Model</MudText>
        <MudText Class="mb-4">Choose a FlowTime model to analyze. The YAML definition will be shown below.</MudText>
        
        <MudPaper Class="pa-4 mb-4" Elevation="1">
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-3">
                <MudText Typo="Typo.subtitle1" Class="mb-0">Model:</MudText>
                <MudSelect T="string" Value="@selectedModelKey" ValueChanged="HandleModelChanged" Dense="true"
                    Variant="Variant.Outlined">
                    @foreach (var kv in modelCatalog)
                    {
                        <MudSelectItem Value="@kv.Key">@kv.Key</MudSelectItem>
                    }
                </MudSelect>
                <MudSpacer />
                <MudButton Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.AccountTree"
                    OnClick="AnalyzeAndSwitchToGraph" Disabled="@(string.IsNullOrEmpty(selectedModelKey) || graphLoading)"
                    Size="Size.Medium" Style="min-width: 120px;">
                    @if (graphLoading)
                    {
                        <MudProgressCircular Class="mr-1" Size="Size.Small" Indeterminate="true" />
                    }
                    Analyze
                </MudButton>
                <MudButton Variant="Variant.Outlined" Color="Color.Success" StartIcon="@Icons.Material.Filled.PlayArrow"
                    OnClick="RunAndSwitchToResults" Disabled="@(string.IsNullOrEmpty(selectedModelKey) || runLoading)"
                    Size="Size.Medium" Style="min-width: 120px;">
                    @if (runLoading)
                    {
                        <MudProgressCircular Class="mr-1" Size="Size.Small" Indeterminate="true" />
                    }
                    Run
                </MudButton>
            </MudStack>
            
            @if (!string.IsNullOrEmpty(selectedModelKey))
            {
                <MudText Typo="Typo.subtitle2" Class="mb-2">Model Definition (YAML):</MudText>
                <MudPaper Class="pa-2 code-block" Elevation="0" Style="max-height: 400px; overflow-y: auto;">@CurrentModelYaml</MudPaper>
            }
        </MudPaper>
    </MudTabPanel>

    <MudTabPanel Text="2. Graph" Icon="@Icons.Material.Filled.AccountTree" Disabled="@string.IsNullOrEmpty(selectedModelKey)">
        <MudText Typo="Typo.h6" Class="mb-3">Graph Structure</MudText>
        <MudText Class="mb-2">View how the model compiles into a computation graph with nodes and connections.</MudText>
        <MudText Typo="Typo.body2" Class="mb-4" Style="color: var(--mud-palette-text-secondary);">
            Calls the engine /graph endpoint to parse and validate the model structure.
        </MudText>
        
        <MudPaper Class="pa-4 mb-4" Elevation="1" Style="min-height: 200px;">
            @if (graphResult is null)
            {
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-3">
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Large" OnClick="GraphModel" Disabled="@graphLoading">
                        @if (graphLoading)
                        {
                            <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                        }
                        @(graphLoading ? "Analyzing..." : "Analyze Graph")
                    </MudButton>
                    <MudText Typo="Typo.caption" Style="color: var(--mud-palette-text-secondary);">
                        Model: <strong>@(selectedModelKey ?? "None")</strong>
                    </MudText>
                </MudStack>
            }
            
            @if (graphResult is null)
            {
                <MudStack AlignItems="AlignItems.Center" Spacing="3" Class="py-4" Style="opacity: 0.6;">
                    <MudIcon Icon="@Icons.Material.Filled.AccountTree" Size="Size.Large" Color="Color.Primary" />
                    <MudText Typo="Typo.body2" Align="Align.Center">
                        Ready to compile your model into a computation graph and see the node structure.
                    </MudText>
                </MudStack>
            }
            
            @if (graphResult is not null)
            {
                var stats = ComputeGraphStats(graphResult);
                <MudText Typo="Typo.caption" Class="mb-2" Style="color: var(--mud-palette-text-secondary);">
                    Nodes: @stats.Total, Sources: @stats.Sources, Sinks: @stats.Sinks, Max Fanout: @stats.MaxFanOut
                </MudText>
                @if (Flags.UseDemoMode && selectedModelKey != "simple")
                {
                    <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Elevation="0" Dense="true" Class="mb-3">
                        Structural graph reflects simulation stub, not the extended model.
                    </MudAlert>
                }
                
                <MudText Typo="Typo.subtitle1" Class="mt-4 mb-2" Style="font-weight: 500;">Node Structure</MudText>
                <MudTable T="NodeInfoView" Hover="true" Dense="true" Items="nodeViews" Elevation="0" Bordered="true"
                    Striped="true">
                    <HeaderContent>
                        <MudTh>#</MudTh>
                        <MudTh>Node</MudTh>
                        <MudTh>Inputs</MudTh>
                        <MudTh>In</MudTh>
                        <MudTh>Out</MudTh>
                        <MudTh>Role</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="#">@context.Order</MudTd>
                        <MudTd DataLabel="Node">@context.Id</MudTd>
                        <MudTd DataLabel="Inputs">@string.Join(", ", context.Inputs)</MudTd>
                        <MudTd DataLabel="In">@context.InDegree</MudTd>
                        <MudTd DataLabel="Out">@context.OutDegree</MudTd>
                        <MudTd DataLabel="Role">
                            @if (context.IsSource)
                            {
                                <MudChip T="string" Color="Color.Info" Variant="Variant.Outlined" Size="Size.Small">source</MudChip>
                            }
                            @if (context.IsSink)
                            {
                                <MudChip T="string" Color="Color.Warning" Variant="Variant.Outlined" Size="Size.Small">sink</MudChip>
                            }
                        </MudTd>
                    </RowTemplate>
                </MudTable>
                
                <MudDivider Class="my-4" />
                <MudText Typo="Typo.subtitle1" Class="mb-2" Style="font-weight: 500;">Graph Visualization</MudText>
                <MicroDag Structure="graphResult" Height="250" />
                <div style="height: 40px;"></div>
            }
        </MudPaper>
    </MudTabPanel>

    <MudTabPanel Text="3. Results" Icon="@Icons.Material.Filled.Timeline" Disabled="@string.IsNullOrEmpty(selectedModelKey)">
        <MudText Typo="Typo.h6" Class="mb-3">Simulation Results</MudText>
        <MudText Class="mb-2">Execute the model to generate time series data and view the results.</MudText>
        <MudText Typo="Typo.body2" Class="mb-4" Style="color: var(--mud-palette-text-secondary);">
            Calls the engine /run endpoint to execute the model and generate time series data.
        </MudText>
        
        <MudPaper Class="pa-4 mb-4" Elevation="1" Style="min-height: 200px;">
            @if (runResult is null)
            {
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-3">
                    <MudButton Variant="Variant.Filled" Color="Color.Success" OnClick="RunModel" Disabled="@runLoading">
                        @if (runLoading)
                        {
                            <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                        }
                        @(runLoading ? "Running..." : "Run Simulation")
                    </MudButton>
                    <MudText Typo="Typo.caption" Style="color: var(--mud-palette-text-secondary);">
                        Model: <strong>@(selectedModelKey ?? "None")</strong>
                    </MudText>
                </MudStack>
                
                <MudStack AlignItems="AlignItems.Center" Spacing="3" Class="py-4" Style="opacity: 0.6;">
                    <MudIcon Icon="@Icons.Material.Filled.Timeline" Size="Size.Large" Color="Color.Primary" />
                    <MudText Typo="Typo.body2" Align="Align.Center">
                        Ready to execute your model and generate time series data with detailed results.
                    </MudText>
                </MudStack>
            }
            
            @if (runResult is not null)
            {
                <MudText Typo="Typo.caption" Class="mb-3">
                    Generated @runResult.Series.Count series with @runResult.Order.Count time steps
                </MudText>
                @if (Flags.UseDemoMode && selectedModelKey != "simple")
                {
                    <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Elevation="0" Dense="true" Class="mb-3">
                        Extended model selected, but demo mode returns fixed simple model data.
                    </MudAlert>
                }
                
                @if (chartSeries?.Count > 0)
                {
                    <MudText Typo="Typo.subtitle1" Class="mt-4 mb-2" Style="font-weight: 500;">Time Series Chart</MudText>
                    <MudChart @key="chartRenderVersion" Class="mb-3" Style="height:280px;" ChartType="ChartType.Line"
                        XAxisLabels="@chartLabels" ChartSeries="@chartSeries" />
                }
                
                <MudText Typo="Typo.subtitle1" Class="mt-4 mb-2" Style="font-weight: 500;">Raw Data</MudText>
                <MudTable T="KeyValuePair<string, double[]>" Items="runResult.Series" Dense="true" Hover="true" Bordered="true"
                    Striped="true" Elevation="0">
                    <HeaderContent>
                        <MudTh>Series</MudTh>
                        <MudTh>Values</MudTh>
                        <MudTh>Min</MudTh>
                        <MudTh>Max</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="Series">@context.Key</MudTd>
                        <MudTd DataLabel="Values">@string.Join(", ", context.Value.Select(v => v.ToString("F2")))</MudTd>
                        <MudTd DataLabel="Min">@context.Value.Min().ToString("F2")</MudTd>
                        <MudTd DataLabel="Max">@context.Value.Max().ToString("F2")</MudTd>
                    </RowTemplate>
                </MudTable>
            }
        </MudPaper>
    </MudTabPanel>
</MudTabs>



@code {
    private bool runLoading, graphLoading;
    private GraphRunResult? runResult;
    private GraphStructureResult? graphResult;
    private List<NodeInfoView> nodeViews = new();
    private string clientModeLabel = "api";
    [Inject] private FeatureFlagService Flags { get; set; } = default!;
    private string? lastError;
    private int activeTabIndex = 0; // 0=Model, 1=Graph, 2=Results

    private enum ReqState { Idle, Loading }
    private enum Outcome { None, Success, Failed }
    private ReqState runState = ReqState.Idle;
    private ReqState graphState = ReqState.Idle;

    // Model catalog loaded from static files in wwwroot/models (no editing in this milestone)
    private readonly Dictionary<string, string> modelCatalog = new();

    private string selectedModelKey = "simple"; // overridden by stored pref if present
    private string CurrentModelYaml => modelCatalog.TryGetValue(selectedModelKey, out var y) ? y : "(model not loaded)";

    private void OnModelChanged()
    {
        // Reset previous results when switching models
        runResult = null;
        graphResult = null;
        nodeViews.Clear();
        chartSeries?.Clear();
    }
    private async Task HandleModelChanged(string key)
    {
        selectedModelKey = key;
        OnModelChanged();
        await Prefs.SetModelKeyAsync(selectedModelKey);
        StateHasChanged();
    }

    private async Task RunModel()
    {
        runLoading = true;
        runState = ReqState.Loading;
        lastError = null;
        try
        {
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(12));
            Console.WriteLine($"[ApiDemo] Running model key='{selectedModelKey}' ({CurrentModelYaml.Length} chars)");
            var yaml = CurrentModelYaml; // snapshot in case user switches mid-run
            var res = await RunClient.RunAsync(yaml, cts.Token);
            if (res.Success && res.Value is not null)
            {
                runResult = res.Value;
                BuildChart();
                // success outcome only reflected via results presence; no chip for run
            }
            else
            {
                runResult = null;
                lastError = $"Run failed ({res.StatusCode}): {res.Error}";
                // failure; no chip, error via snackbar and notifications
                NotificationService.Add(lastError, Severity.Error);
            }
        }
        catch (Exception ex)
        {
            runResult = null;
            // failure; no chip
            lastError = $"Run error: {ex.Message}";
            NotificationService.Add(lastError, Severity.Error);
        }
        finally { runLoading = false; runState = ReqState.Idle; await InvokeAsync(StateHasChanged); }
    }

    private async Task GraphModel()
    {
        graphLoading = true;
        graphState = ReqState.Loading;
        lastError = null;
        try
        {
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(12));
            Console.WriteLine($"[ApiDemo] Graph model key='{selectedModelKey}' ({CurrentModelYaml.Length} chars)");
            var yaml = CurrentModelYaml;
            var res = await RunClient.GraphAsync(yaml, cts.Token);
            if (res.Success && res.Value is not null)
            {
                graphResult = res.Value;
                nodeViews = BuildNodeViews(graphResult);
            }
            else
            {
                graphResult = null;
                nodeViews.Clear();
                lastError = $"Graph failed ({res.StatusCode}): {res.Error}";
                // failure outcome; no chip, error via snackbar and notifications
                NotificationService.Add(lastError, Severity.Error);
            }
        }
        catch (Exception ex)
        {
            graphResult = null;
            // failure outcome
            lastError = $"Graph error: {ex.Message}";
            NotificationService.Add(lastError, Severity.Error);
        }
        finally { graphLoading = false; graphState = ReqState.Idle; await InvokeAsync(StateHasChanged); }
    }

    // Removed sample JSON fallback loaders.

    private string RunButtonLabel => runState == ReqState.Loading ? "Running..." : "Run /run";
    private Color RunButtonColor => Color.Secondary; // always neutral
    private string GraphButtonLabel => graphState == ReqState.Loading ? "Loading..." : "Graph /graph";
    private Color GraphButtonColor => Color.Secondary; // always neutral

    private bool anyLoading => runState == ReqState.Loading || graphState == ReqState.Loading;

    private record NodeInfoView(int Order, string Id, IReadOnlyList<string> Inputs, int InDegree, int OutDegree, bool
    IsSource, bool IsSink);

    // Charting
    private List<ChartSeries>? chartSeries;
    private string[]? chartLabels;
    private string? chartDiag;
    private int chartRenderVersion = 0;
    private void BuildChart()
    {
        if (runResult is null) { chartSeries = null; chartLabels = null; chartDiag = null; return; }
        chartLabels = Enumerable.Range(0, runResult.Bins).Select(i => i.ToString()).ToArray();
        if (runResult.Series.Count == 0) { chartSeries = new List<ChartSeries>(); chartDiag = "(no series)"; return; }
        // Respect declared evaluation order, but only include those with data, up to 4
        chartSeries = new List<ChartSeries>();
        int idx = 0;
        var diagParts = new List<string>();
        foreach (var name in runResult.Order)
        {
            if (!runResult.Series.TryGetValue(name, out var raw)) continue;
            if (idx++ == 4) break;
            var data = raw.Select(v => v).ToArray();
            // (debug logging removed)
            chartSeries.Add(new ChartSeries { Name = name, Data = data });
            var (min, max) = (data.Min(), data.Max());
            diagParts.Add(FormatSeriesRange(name, min, max));
        }
        chartDiag = string.Join(" | ", diagParts);
        // Constant series now render correctly after MudBlazor upgrade.
        chartRenderVersion++; // force re-render
    }

    private static string FormatSeriesRange(string name, double min, double max)
    => min == max ? $"{name}:{min:F2}" : $"{name}:{min:F2}-{max:F2}";


    private List<NodeInfoView> BuildNodeViews(GraphStructureResult g)
    {
        var inDeg = new Dictionary<string, int>();
        var outDeg = new Dictionary<string, int>();
        var orderIndex = new Dictionary<string, int>();
        for (int i = 0; i < g.Order.Count; i++) orderIndex[g.Order[i]] = i;
        foreach (var n in g.Nodes)
        {
            if (!outDeg.ContainsKey(n.Id)) outDeg[n.Id] = 0;
            foreach (var inp in n.Inputs)
            {
                inDeg[inp] = inDeg.TryGetValue(inp, out var v) ? v + 1 : 1;
                outDeg[n.Id] = outDeg[n.Id] + 1;
            }
            if (!inDeg.ContainsKey(n.Id)) inDeg[n.Id] = inDeg.GetValueOrDefault(n.Id, 0);
        }
        return g.Nodes.Select(n => new NodeInfoView(
        orderIndex.GetValueOrDefault(n.Id, int.MaxValue),
        n.Id,
        n.Inputs,
        inDeg.GetValueOrDefault(n.Id, 0),
        outDeg.GetValueOrDefault(n.Id, 0),
        n.Inputs.Count == 0,
        !g.Nodes.Any(other => other.Inputs.Contains(n.Id))
        )).OrderBy(v => v.Order).ThenBy(v => v.Id).ToList();
    }

    private (int Total, int Sources, int Sinks, int MaxFanOut) ComputeGraphStats(GraphStructureResult g)
    {
        var views = nodeViews.Count > 0 ? nodeViews : BuildNodeViews(g);
        return (views.Count, views.Count(v => v.IsSource), views.Count(v => v.IsSink), views.Count == 0 ? 0 : views.Max(v =>
        v.OutDegree));
    }

    protected override async Task OnInitializedAsync()
    {
        await Flags.EnsureLoadedAsync();
        clientModeLabel = Flags.UseDemoMode ? "demo" : "api";
        Flags.Changed += OnFlagsChanged;
        await Prefs.EnsureLoadedAsync();
        await LoadModelsAsync();
        if (!string.IsNullOrWhiteSpace(Prefs.ModelKey) && modelCatalog.ContainsKey(Prefs.ModelKey))
        {
            selectedModelKey = Prefs.ModelKey;
        }
    }

    private async void OnFlagsChanged()
    {
        clientModeLabel = Flags.UseDemoMode ? "demo" : "api";
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose() => Flags.Changed -= OnFlagsChanged;

    private async Task LoadModelsAsync()
    {
        try
        {
            // Define all available models
            var modelNames = new[]
            {
                "simple",
                "extended", 
                "invalid-array-length",
                "it-system-monitoring",
                "transport-logistics",
                "supply-chain-dynamics",
                "healthcare-patient-care"
            };

            // Load each model if not already loaded
            foreach (var modelName in modelNames)
            {
                if (!modelCatalog.ContainsKey(modelName))
                {
                    try
                    {
                        var modelContent = await Http.GetStringAsync($"/models/{modelName}.yaml");
                        modelCatalog[modelName] = modelContent;
                    }
                    catch (Exception ex)
                    {
                        // Log individual model load failures but continue with others
                        Console.WriteLine($"Failed to load model '{modelName}': {ex.Message}");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            lastError = "Model load error: " + ex.Message;
            NotificationService.Add(lastError, Severity.Error);
        }
    }

    private async Task AnalyzeAndSwitchToGraph()
    {
        activeTabIndex = 1; // Switch to Graph tab
        await GraphModel(); // Call existing graph analysis method
    }

    private async Task RunAndSwitchToResults()
    {
        activeTabIndex = 2; // Switch to Results tab
        await RunModel(); // Call existing run method
    }

}

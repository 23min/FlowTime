# Milestone M2 â€” PMF Support

**Status:** ðŸ“‹ PLANNED  
**Owner:** Core Team  
**Target:** Post M1.5 Expression Language  
**Dependencies:** M1.5 (Expression Language), SIM-M2.1 (PMF Generator Support)

---

## Summary

Introduce **Probability Mass Function (PMF) support** to enable uncertainty modeling in FlowTime workflows. This milestone adds PMF nodes that convert discrete probability distributions into expected value time series, enabling "what-if" analysis with probabilistic parameters while maintaining FlowTime's deterministic evaluation philosophy.

**Key Innovation:** Transform uncertainty into deterministic expected values for fast, explainable scenario analysis without requiring full Monte Carlo simulation.

**Scope:** PMF nodes with expected value calculation only. Full distribution propagation and Monte Carlo simulation deferred to later milestones (M15).

---

## Goals

### Primary Goal
Enable workflow designers to model uncertainty in business processes using discrete probability distributions, producing deterministic expected value series that integrate seamlessly with FlowTime's expression language.

### Secondary Goals
- Maintain deterministic, single-pass evaluation with probabilistic inputs
- Support common uncertainty patterns (arrivals, attempts, variability)
- Provide foundation for probabilistic capacity planning
- Enable integration with FlowTime-Sim PMF generators for testing

---

## Functional Requirements

### **FR-M2-1: PMF Node Implementation**
Support `pmf` node kind with discrete probability mass function specification.

**Input Format:**
```yaml
nodes:
  - id: customer_attempts
    kind: pmf
    pmf:
      "1": 0.6    # 60% chance of 1 attempt
      "2": 0.3    # 30% chance of 2 attempts
      "3": 0.1    # 10% chance of 3 attempts
```

**Requirements:**
- Parse PMF specification from YAML `pmf` field
- Validate probabilities are non-negative and sum to approximately 1.0
- Support integer and decimal values as PMF outcomes
- Normalize probabilities if they don't exactly sum to 1.0
- Generate meaningful validation errors for malformed PMFs

### **FR-M2-2: Expected Value Calculation**
Convert PMF distributions to expected value time series aligned to the canonical grid.

**Mathematical Foundation:**
```
E[X] = Î£ (value Ã— probability)
```

**Implementation:**
- Calculate expected value once during node initialization
- Emit constant expected value across all time bins
- Support expression integration: `served = MIN(capacity, customer_attempts)`
- Maintain Series<double> output type for downstream compatibility

### **FR-M2-3: PMF Validation and Normalization**
Robust validation and automatic normalization of PMF specifications.

**Validation Rules:**
- All probabilities must be non-negative
- Probabilities should sum to 1.0 (within tolerance of 1e-6)
- At least one outcome must be specified
- Values must be numeric (integer or decimal)
- Duplicate values are not allowed

**Normalization:**
- If probabilities sum to close to 1.0 but not exactly, normalize automatically
- Log normalization warnings for transparency
- Throw validation errors for severely malformed PMFs (e.g., sum < 0.5 or sum > 2.0)

### **FR-M2-4: Expression Language Integration**
PMF nodes integrate seamlessly with M1.5 expression language.

**Usage Examples:**
```yaml
# Basic PMF usage
- id: arrivals
  kind: pmf
  pmf: { "1": 0.4, "2": 0.3, "3": 0.2, "4": 0.1 }

# PMF in expressions
- id: load_estimate
  kind: expr
  expr: "arrivals / capacity"

# PMF with temporal operations
- id: trend_analysis
  kind: expr
  expr: "arrivals + SHIFT(arrivals, -1)"

# PMF with functions
- id: constrained_arrivals
  kind: expr
  expr: "MIN(arrivals, max_capacity)"
```

### **FR-M2-5: Artifact Integration**
PMF nodes produce standard FlowTime artifacts compatible with existing tooling.

**Output Requirements:**
- Generate series CSV files with expected values: `t,value`
- Include PMF metadata in run.json and series/index.json
- Support existing artifact endpoints and UI integration
- Maintain deterministic artifact hashing for reproducibility

---

## Architecture

### Core Components

```
src/FlowTime.Core/
  Pmf/
    Pmf.cs                     # PMF data structure and validation
    PmfNode.cs                 # PMF node implementation
  Models/
    ModelParser.cs             # Extended to parse PMF nodes
```

### **Pmf.cs - Core PMF Data Structure**
```csharp
public class Pmf
{
    public IReadOnlyDictionary<double, double> Distribution { get; }
    public double ExpectedValue { get; }
    
    public Pmf(Dictionary<double, double> distribution)
    {
        ValidateDistribution(distribution);
        Distribution = NormalizeDistribution(distribution);
        ExpectedValue = CalculateExpectedValue();
    }
    
    private static void ValidateDistribution(Dictionary<double, double> dist)
    {
        // Validate non-negative probabilities, reasonable sum, etc.
    }
    
    private static Dictionary<double, double> NormalizeDistribution(Dictionary<double, double> dist)
    {
        // Normalize probabilities to sum to 1.0
    }
    
    private double CalculateExpectedValue()
    {
        return Distribution.Sum(kvp => kvp.Key * kvp.Value);
    }
}
```

### **PmfNode.cs - PMF Node Implementation**
```csharp
public class PmfNode : INode
{
    public NodeId Id { get; }
    public Pmf Pmf { get; }
    
    public PmfNode(NodeId id, Pmf pmf)
    {
        Id = id;
        Pmf = pmf;
    }
    
    public Series<double> Evaluate(TimeGrid grid, IReadOnlyDictionary<NodeId, Series<double>> inputs)
    {
        // Return constant expected value series across all bins
        var values = new double[grid.Bins];
        Array.Fill(values, Pmf.ExpectedValue);
        return new Series<double>(values);
    }
    
    public IEnumerable<NodeId> GetInputs() => Enumerable.Empty<NodeId>();
}
```

### **ModelParser Extensions**
Extend existing ModelParser to handle PMF node specifications:

```csharp
private static INode ParsePmfNode(NodeSpec nodeSpec)
{
    if (nodeSpec.Pmf == null)
        throw new ModelParseException($"PMF node {nodeSpec.Id} missing 'pmf' field");
        
    // Parse PMF dictionary from YAML
    var distribution = new Dictionary<double, double>();
    foreach (var kvp in nodeSpec.Pmf)
    {
        if (!double.TryParse(kvp.Key, out var value))
            throw new ModelParseException($"Invalid PMF value '{kvp.Key}' in node {nodeSpec.Id}");
        if (kvp.Value < 0)
            throw new ModelParseException($"Negative probability {kvp.Value} for value {value} in node {nodeSpec.Id}");
        distribution[value] = kvp.Value;
    }
    
    var pmf = new Pmf(distribution);
    return new PmfNode(new NodeId(nodeSpec.Id), pmf);
}
```

---

## Example Models

### **PMF Concept Clarification**
PMFs model **uncertainty within each time bin**, not patterns across time bins.

```yaml
# WRONG: This doesn't create a daily traffic pattern
# This PMF gives the same expected value (2.3) for ALL hours
traffic_wrong:
  kind: pmf
  pmf: { "1": 0.3, "2": 0.4, "3": 0.2, "4": 0.1 }  # Expected: 2.3 every hour

# RIGHT: Time-varying pattern with different values per hour
traffic_pattern:
  kind: const
  values: [
    # Night: 00:00-05:59 (low traffic)
    2, 1, 1, 1, 1, 3,
    # Morning: 06:00-09:59 (rush hour)  
    15, 25, 30, 20,
    # Mid-morning: 10:00-11:59
    12, 18,
    # Lunch: 12:00-13:59 (peak)
    28, 32,
    # Afternoon: 14:00-15:59
    15, 22,
    # Evening: 16:00-18:59 (rush hour)
    35, 40, 30,
    # Night: 19:00-23:59 (declining)
    18, 12, 8, 5, 3
  ]

# COMBINED: Time pattern + uncertainty
base_hourly_traffic:
  kind: const  
  values: [2, 1, 1, 1, 1, 3, 15, 25, 30, 20, 12, 18, 28, 32, 15, 22, 35, 40, 30, 18, 12, 8, 5, 3]

uncertainty_factor:
  kind: pmf
  pmf: { "0.8": 0.2, "1.0": 0.6, "1.2": 0.2 }  # Â±20% daily variation

actual_traffic:
  kind: expr  
  expr: "base_hourly_traffic * uncertainty_factor"
```

### **Basic PMF Model**
```yaml
grid:
  bins: 24
  binMinutes: 60

nodes:
  - id: customer_attempts
    kind: pmf
    pmf:
      "1": 0.5    # 50% single attempt
      "2": 0.3    # 30% double attempt  
      "3": 0.2    # 20% triple attempt
  
  - id: capacity
    kind: const
    values: [100, 100, 100, 100, 100, 100, 100, 100, 
             100, 100, 100, 100, 100, 100, 100, 100,
             100, 100, 100, 100, 100, 100, 100, 100]
  
  - id: served
    kind: expr
    expr: "MIN(customer_attempts, capacity)"

outputs:
  - series: customer_attempts
    as: attempts.csv
  - series: served  
    as: served.csv
```

**Expected Behavior:**
- `customer_attempts` expected value: 1Ã—0.5 + 2Ã—0.3 + 3Ã—0.2 = 1.7 attempts
- All 24 bins contain value 1.7 in attempts.csv
- `served` will be MIN(1.7, 100) = 1.7 across all bins

### **Complex PMF with Expressions**
```yaml
grid:
  bins: 4
  binMinutes: 60

nodes:
  - id: base_demand
    kind: pmf
    pmf:
      "10": 0.2
      "15": 0.5  
      "20": 0.3
  
  - id: surge_factor
    kind: pmf
    pmf:
      "1.0": 0.7   # 70% normal load
      "1.5": 0.2   # 20% moderate surge
      "2.0": 0.1   # 10% high surge
  
  - id: total_demand
    kind: expr
    expr: "base_demand * surge_factor"
  
  - id: capacity
    kind: const
    values: [25, 25, 25, 25]
  
  - id: utilization
    kind: expr
    expr: "total_demand / capacity"

outputs:
  - series: total_demand
    as: demand.csv
  - series: utilization
    as: utilization.csv
```

**Expected Behavior:**
- `base_demand` expected: 10Ã—0.2 + 15Ã—0.5 + 20Ã—0.3 = 15.5
- `surge_factor` expected: 1.0Ã—0.7 + 1.5Ã—0.2 + 2.0Ã—0.1 = 1.1  
- `total_demand` expected: 15.5 Ã— 1.1 = 17.05
- `utilization` expected: 17.05 / 25 = 0.682 (68.2%)

---

## Testing Strategy

### **Unit Tests**
```csharp
[TestClass]
public class PmfTests
{
    [TestMethod]
    public void Pmf_CalculatesCorrectExpectedValue()
    {
        var distribution = new Dictionary<double, double>
        {
            { 1.0, 0.6 },
            { 2.0, 0.3 },
            { 3.0, 0.1 }
        };
        
        var pmf = new Pmf(distribution);
        
        Assert.AreEqual(1.5, pmf.ExpectedValue, 1e-10);
    }
    
    [TestMethod]
    public void Pmf_NormalizesProbabilities()
    {
        var distribution = new Dictionary<double, double>
        {
            { 1.0, 0.6 },
            { 2.0, 0.3 },
            { 3.0, 0.09 }  // Sum = 0.99, should normalize
        };
        
        var pmf = new Pmf(distribution);
        var sum = pmf.Distribution.Values.Sum();
        
        Assert.AreEqual(1.0, sum, 1e-10);
    }
    
    [TestMethod]
    [ExpectedException(typeof(ArgumentException))]
    public void Pmf_RejectsNegativeProbabilities()
    {
        var distribution = new Dictionary<double, double>
        {
            { 1.0, 0.6 },
            { 2.0, -0.1 }  // Invalid
        };
        
        new Pmf(distribution);
    }
}

[TestClass]
public class PmfNodeTests
{
    [TestMethod]
    public void PmfNode_EmitsExpectedValueSeries()
    {
        var pmf = new Pmf(new Dictionary<double, double>
        {
            { 1.0, 0.4 },
            { 2.0, 0.6 }
        });
        var node = new PmfNode(new NodeId("test"), pmf);
        var grid = new TimeGrid(4, 60);
        
        var result = node.Evaluate(grid, new Dictionary<NodeId, Series<double>>());
        
        Assert.AreEqual(4, result.Values.Length);
        Assert.AreEqual(1.6, result.Values[0], 1e-10); // 1*0.4 + 2*0.6
        Assert.AreEqual(1.6, result.Values[1], 1e-10);
        Assert.AreEqual(1.6, result.Values[2], 1e-10);
        Assert.AreEqual(1.6, result.Values[3], 1e-10);
    }
}
```

### **Integration Tests**
- End-to-end YAML parsing and evaluation
- CLI/API parity testing for PMF models
- Expression integration with PMF nodes
- Artifact generation and validation

### **Performance Tests**
- PMF initialization overhead
- Large PMF distributions (20+ discrete values)
- High-value PMFs (values in 1,000-100,000 range)
- Memory usage for PMF-heavy models

---

## Realistic PMF Value Ranges

### **Typical Business Scenarios (1-day window)**

#### Small Business (Hourly bins)
```yaml
# Customer support tickets per hour
support_tickets:
  kind: pmf
  pmf: { "0": 0.1, "1": 0.3, "2": 0.3, "3": 0.2, "4": 0.1 }
  # Expected: 1.9 tickets/hour

# Online orders per hour  
orders:
  kind: pmf
  pmf: { "1": 0.2, "2": 0.3, "3": 0.25, "4": 0.15, "5": 0.1 }
  # Expected: 2.6 orders/hour
```

#### Medium Business (Hourly bins)
```yaml
# API requests per hour (hundreds)
api_requests:
  kind: pmf  
  pmf: { "80": 0.1, "120": 0.2, "150": 0.4, "180": 0.2, "220": 0.1 }
  # Expected: 150 requests/hour

# User sessions per hour
user_sessions:
  kind: pmf
  pmf: { "20": 0.15, "40": 0.25, "60": 0.3, "80": 0.2, "100": 0.1 }
  # Expected: 58 sessions/hour
```

#### Large Business (Hourly bins)
```yaml
# Payment transactions per hour (thousands)
payments:
  kind: pmf
  pmf: { "800": 0.1, "1200": 0.3, "1500": 0.4, "1800": 0.15, "2200": 0.05 }
  # Expected: 1470 payments/hour

# Page views per hour (tens of thousands)  
page_views:
  kind: pmf
  pmf: { "8000": 0.2, "12000": 0.3, "15000": 0.3, "18000": 0.15, "22000": 0.05 }
  # Expected: 14100 page views/hour
```

### **High-Scale Scenarios**
For systems handling millions of events, consider:
- Using larger time bins (e.g., daily instead of hourly)
- Aggregating related events into logical units
- Focusing on rate-based PMFs (events per second) rather than absolute counts

### **PMF Complexity Guidelines**
- **Simple models**: 3-5 discrete values (recommended for initial modeling)
- **Detailed models**: 5-15 discrete values (good for established processes)
- **Complex models**: 15+ discrete values (use sparingly, profile performance)

### **Value Range Validation**
The M2 implementation will include optional validation warnings:
- Values > 100,000: Log performance warning
- Values > 1,000,000: Suggest using larger time bins  
- PMFs with > 50 discrete values: Suggest simplification

---

## Compatibility

### **Backward Compatibility**
- No breaking changes to existing node types
- New `pmf` node kind is additive only
- Existing M0/M1/M1.5 models continue to work unchanged
- Schema version remains at 1 (no structural artifact changes)

### **Forward Compatibility**
- PMF node design enables future extensions:
  - Distribution propagation (M15+)
  - Monte Carlo sampling modes
  - Conditional PMFs and dependency modeling
  - Runtime PMF updates from telemetry

### **FlowTime-Sim Integration**
- PMF expected values calculated by Engine M2
- FlowTime-Sim SIM-M2.1 generates synthetic data matching PMF distributions
- Contract testing ensures Engine PMF calculations match Sim PMF sampling
- Artifact compatibility maintained for cross-tool workflows

---

## Implementation Plan

### **Phase 1: Core PMF Infrastructure**
1. Implement `Pmf` class with validation and expected value calculation
2. Create `PmfNode` with Series emission
3. Extend `ModelParser` to parse PMF specifications
4. Add comprehensive unit tests

### **Phase 2: Integration**
1. Update CLI to support PMF nodes
2. Update API to handle PMF models
3. Add integration tests for end-to-end workflows
4. Validate expression language compatibility

### **Phase 3: Testing and Documentation**
1. Performance testing and optimization
2. Contract testing with FlowTime-Sim
3. Update documentation and examples
4. User acceptance testing

### **Phase 4: Release**
1. Final testing and validation
2. Release documentation
3. Tag and merge to main
4. Coordinate with SIM-M2.1 completion

---

## Acceptance Criteria

### **Functional**
âœ… PMF nodes parse from YAML with validation  
âœ… Expected value calculation is mathematically correct  
âœ… PMF nodes integrate with expression language (operators and functions)  
âœ… Generated artifacts match existing format and schema  
âœ… CLI and API produce identical results for PMF models  

### **Quality**
âœ… Comprehensive unit test coverage (>95%)  
âœ… Integration tests for CLI/API parity  
âœ… Performance tests validate no significant overhead  
âœ… Error handling provides clear, actionable messages  

### **Documentation**
âœ… M2 design document completed  
âœ… API/CLI usage examples documented  
âœ… PMF modeling best practices guide  
âœ… Release notes with migration guide  

### **Integration**
âœ… FlowTime-Sim SIM-M2.1 compatibility validated  
âœ… Contract tests pass for Engine â†” Sim PMF workflows  
âœ… UI can load and display PMF-based artifacts  

---

## Questions and Considerations

### **Open Questions**

1. **PMF Value Types**: Should we support only numeric values, or also categorical outcomes (mapped to numbers)?
   - **Recommendation**: Start with numeric only for simplicity, extend later if needed

2. **Probability Precision**: What tolerance should we use for probability sum validation?
   - **Recommendation**: 1e-6 tolerance with automatic normalization for small deviations

3. **Large PMF Performance**: How should we handle PMFs with 20+ discrete values and high-magnitude values (>100,000)?
   - **Recommendation**: Profile performance during M2 implementation, add validation warnings for extreme cases

4. **PMF Metadata**: Should we store PMF source information and value range validation?
   - **Recommendation**: Add optional metadata field for traceability and range validation warnings

5. **Performance Thresholds**: What constitutes acceptable performance for realistic PMF ranges?
   - **Recommendation**: Target <1ms overhead for typical business PMFs (3-15 values, <10,000 magnitude)

6. **PMF vs Time-Varying Patterns**: How do PMFs relate to time-of-day patterns?
   - **Clarification**: PMFs model uncertainty **within** each time bin, not patterns **across** time bins
   - **Time-varying patterns** require `const` nodes with different values per bin
   - **Combined modeling**: Use expressions to combine time patterns with PMF uncertainty

7. **PMF Training from Telemetry**: Should M2 include tools to derive PMFs from historical data?
   - **Recommendation**: **Defer to M9** (Data Import & Fitting). M2 focuses on PMF evaluation only
   - **Workaround**: Users can analyze telemetry externally and manually specify PMFs in M2

### **Integration Points**

1. **FlowTime-Sim Coordination**: Ensure SIM-M2.1 PMF generators produce data that validates Engine expected value calculations
2. **UI Integration**: Consider how PMF nodes should be displayed in future UI milestone
3. **Performance Impact**: Validate that PMF expected value calculation doesn't significantly impact evaluation performance

### **Risk Mitigation**

1. **Mathematical Accuracy**: Use established numerical algorithms for expected value calculation
2. **Edge Cases**: Comprehensive testing for degenerate PMFs (single value, extreme probabilities)
3. **User Experience**: Clear error messages and validation to prevent common PMF specification mistakes

---

## Success Metrics

- **Functional**: All M2 functional requirements implemented and tested
- **Performance**: PMF evaluation adds <5% overhead to baseline model evaluation
- **Adoption**: M2 enables realistic uncertainty modeling for capacity planning use cases
- **Integration**: Seamless workflow from FlowTime-Sim PMF generation to Engine analysis

M2 establishes FlowTime as a practical tool for probabilistic business process analysis while maintaining its core deterministic evaluation philosophy.# Scenarios

- Probabilistic arrivals/attempts: represent uncertainty with a PMF and use expected value series for quick scenario math.
- Examples:
  - attempts.pmf = { 1: 0.6, 2: 0.3, 3: 0.1 } â†’ expected attempts per bin.
  - combine PMFâ€‘derived series with capacity via basic arithmetic to estimate load.

## How the code works

- PMF definitions are parsed and normalized.
- A PmfNode emits an expectedâ€‘value Series aligned to the grid.
- Downstream nodes consume this series like any other, using BinaryOp/Add/Mul to combine with baselines or capacity.

## Why itâ€™s useful now

- Quick, explainable uncertainty modeling without full Monte Carlo.
- Fits cleanly into the node graph; deterministic and auditable.

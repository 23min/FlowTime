# Milestone M-01.05 â€” Expressions & Built-ins

> **ðŸ“‹ Charter Notice**: This completed milestone predates the [FlowTime-Engine Charter](../flowtime-engine-charter.md). Expression language capabilities delivered here remain core to the charter execution engine. See [ROADMAP.md](../ROADMAP.md) for current milestones.

**Status:** âœ… COMPLETED (2025-09-10) *(Pre-Charter)*  
**Owner:** Core Team  
**Target:** Post M-0/M-1 Foundation  
**Dependencies:** M-0 (DAG Foundation), M-1 (Artifacts Contract)

---

## Summary

Transform FlowTime from a basic DAG calculator into a true "spreadsheet for flows" by implementing a focused expression language with built-in functions. This milestone introduces the SHIFT temporal operator and basic stateful node support.

**Key Innovation:** Maintain single-pass, causal evaluation while enabling temporal relationships through simple history buffers.

**Scope:** Deliberately focused on expressions and SHIFT onlyâ€”advanced retry modeling deferred to later milestones when use cases are better understood.

---

## Goals

### Primary Goal
Enable users to write intuitive, spreadsheet-like expressions that reference other nodes and apply temporal operations, making FlowTime models more expressive and maintainable.

### Secondary Goals
- Establish minimal stateful node architecture for SHIFT operator
- Maintain deterministic, single-pass evaluation philosophy  
- Improve model readability and reduce boilerplate
- Validate expression parsing approach before adding complexity

---

## Functional Requirements

### **FR-M-01.05-1: Expression Parser**
- Parse arithmetic expressions: `+`, `-`, `*`, `/`
- Support function calls: `SHIFT(demand, 1)`, `MIN(a, b)`, `MAX(a, b)`, `CLAMP(x, lo, hi)`
- Handle node references: `demand`, `capacity`, `served`
- Support parentheses for precedence: `(demand + retries) * 0.8`
- Generate meaningful parse errors with line/column information

**Input Examples:**
```yaml
expr: "demand * 0.8"
expr: "demand + SHIFT(demand, 1)"  
expr: "MIN(capacity, demand + retries)"
expr: "CLAMP(utilization, 0.0, 1.0)"
```

### **FR-M-01.05-2: Node Reference Resolution**
- Resolve node IDs to their series during compilation
- Detect undefined references at compile time
- Support forward references (topological sort handles evaluation order)
- Validate reference cycles are broken by explicit delays

### **FR-M-01.05-3: SHIFT Built-in Function**
- `SHIFT(series, k)` where k â‰¥ 0 (positive lag only for causality)
- Returns series shifted k bins into the future
- `SHIFT(x, 0)` = identity (no-op)
- `SHIFT(x, 1)` = [0, x[0], x[1], x[2], ...]
- `SHIFT(x, 2)` = [0, 0, x[0], x[1], ...]

**Validation Rules:**
- Lag parameter must be non-negative integer
- Lag must be compile-time constant (no dynamic shifts)

### **FR-M-01.05-4: Stateful Primitives Foundation** 
- Design `IStatefulNode` interface for nodes with history buffers
- Implement `ShiftNode` as first stateful node
- Establish evaluation pattern: process bin-by-bin, update state
- Prepare architecture for CONV, EMA, backlog nodes in future milestones

### **FR-M-01.05-5: Causal Evaluation with History Buffers**
- Maintain single-pass evaluation through bins 0, 1, 2...
- Stateful nodes store limited history in circular buffers
- All temporal dependencies flow backward in time (causal)
- No algebraic loops or iterative convergence required

### **FR-M-01.05-6: Elementwise Functions**
- `MIN(a, b)` and `MAX(a, b)` - element-wise minimum/maximum
- `CLAMP(x, lo, hi)` - clamp each element to range [lo, hi]
- Support both series-series and series-scalar operations
- Handle broadcasting rules consistently

---

## Technical Architecture

### Expression Language Grammar (EBNF)
```ebnf
Expression  = Term (('+' | '-') Term)*
Term        = Factor (('*' | '/') Factor)*  
Factor      = Number | NodeRef | FunctionCall | '(' Expression ')'
FunctionCall = Identifier '(' (Expression (',' Expression)*)? ')'
NodeRef     = Identifier
Number      = [0-9]+ ('.' [0-9]+)?
Identifier  = [a-zA-Z_][a-zA-Z0-9_]*
```

### Core Classes

```csharp
// Expression AST nodes
public abstract class ExpressionNode { }
public class BinaryOpNode : ExpressionNode { }
public class FunctionCallNode : ExpressionNode { }
public class NodeReferenceNode : ExpressionNode { }
public class LiteralNode : ExpressionNode { }

// Parser and compiler
public class ExpressionParser 
{
    public ExpressionNode Parse(string expression);
}

public class ExpressionCompiler
{
    public INode Compile(ExpressionNode ast, string nodeId);
}

// Stateful node support
public interface IStatefulNode : INode
{
    void InitializeState(TimeGrid grid);
    void UpdateState(int currentBin, double value);
}

public class ShiftNode : IStatefulNode
{
    private readonly Queue<double> history;
    private readonly int lag;
    // Implementation details...
}
```

### Integration Points

**FlowTime.Core Changes:**
```
src/FlowTime.Core/
  Expressions/
    ExpressionParser.cs       # Parse string â†’ AST
    ExpressionCompiler.cs     # Compile AST â†’ Node  
    ExpressionNodes.cs        # AST node types
  Nodes/
    ShiftNode.cs              # SHIFT operator implementation
    ExprNode.cs               # Compiled expression node
    IStatefulNode.cs          # Interface for stateful nodes
  Graph.cs                    # Updated to support stateful nodes
```

**API/CLI Changes:**
- Update YAML parsing to use expression parser instead of regex
- Enhanced error messages for expression syntax errors
- Maintain backward compatibility with simple expressions

---

## Implementation Strategy

### Phase 1: Parser Foundation
1. **Create expression AST classes** - represent parsed expressions as trees
2. **Implement recursive descent parser** - handle precedence and associativity
3. **Add comprehensive parse error handling** - helpful error messages
4. **Write parser unit tests** - cover edge cases and error conditions

### Phase 2: SHIFT Operator
1. **Design IStatefulNode interface** - contracts for nodes with state
2. **Implement ShiftNode** - circular buffer for history tracking
3. **Update Graph.Evaluate()** - support stateful node lifecycle
4. **Test SHIFT functionality** - verify causal behavior

### Phase 3: Expression Compilation
1. **Create ExpressionCompiler** - AST â†’ Node graph transformation
2. **Handle node reference resolution** - link to existing nodes
3. **Support function call compilation** - SHIFT, MIN, MAX, CLAMP
4. **Add expression validation** - type checking, reference validation

### Phase 4: Integration (1-2 hours)
1. **Update API/CLI parsers** - use new expression system
2. **Maintain backward compatibility** - existing simple expressions work
3. **Add integration tests** - end-to-end expression scenarios
4. **Update documentation** - expression syntax guide

---

## Testing Strategy

### Unit Tests
- **Parser tests**: syntax validation, error handling, precedence
- **ShiftNode tests**: history buffer behavior, boundary conditions
- **Compiler tests**: AST to Node graph transformation
- **Function tests**: MIN, MAX, CLAMP edge cases

### Integration Tests  
- **End-to-end expression evaluation** - YAML â†’ results
- **Stateful node behavior** - multi-bin evaluation scenarios
- **API/CLI compatibility** - existing models continue working
- **Error propagation** - parse errors surface correctly

### Golden Vector Tests
```yaml
# Test case: SHIFT behavior
grid: { bins: 4, binMinutes: 60 }
nodes:
  - id: base
    kind: const
    values: [10, 20, 30, 40]
  - id: shifted
    kind: expr
    expr: "SHIFT(base, 1)"
# Expected: shifted = [0, 10, 20, 30]

# Test case: Combined operations  
nodes:
  - id: combined  
    kind: expr
    expr: "base + SHIFT(base, 1)"
# Expected: combined = [10, 30, 50, 70]
```

---

## Acceptance Criteria

### **AC-M-01.05-1: Expression Parsing**
- âœ… Parse arithmetic expressions with correct precedence
- âœ… Handle function calls with multiple parameters
- âœ… Generate clear error messages for invalid syntax
- âœ… Support node references and literal values

### **AC-M-01.05-2: SHIFT Operator**
- âœ… `SHIFT(series, k)` produces correct lagged output
- âœ… Validates k â‰¥ 0 at compile time
- âœ… Handles edge cases (empty series, large lags)
- âœ… Maintains causal evaluation (no future references)

### **AC-M-01.05-3: Stateful Node Architecture**
- âœ… IStatefulNode interface supports future operators
- âœ… Graph evaluation handles stateful nodes correctly
- âœ… Memory usage bounded (circular buffers, not unlimited history)
- âœ… Deterministic behavior across runs

### **AC-M-01.05-4: Backward Compatibility**
- âœ… Existing simple expressions continue working
- âœ… All M-0/M-1 tests pass without modification
- âœ… API contracts unchanged for basic operations
- âœ… CLI behavior identical for existing models

### **AC-M-01.05-5: Performance**
- âœ… Expression compilation is one-time cost
- âœ… Evaluation performance comparable to hand-coded nodes
- âœ… Memory usage linear in grid size, not history depth
- âœ… No performance regression for non-expression nodes

---

## Examples and Usage

### Basic SHIFT Usage
```yaml
grid: { bins: 6, binMinutes: 60 }
nodes:
  - id: demand
    kind: const
    values: [100, 120, 80, 150, 90, 110]
  
  - id: previous_demand
    kind: expr
    expr: "SHIFT(demand, 1)"
    # Result: [0, 100, 120, 80, 150, 90]
    
  - id: growth_rate
    kind: expr  
    expr: "(demand - SHIFT(demand, 1)) / MAX(SHIFT(demand, 1), 1)"
    # Calculates period-over-period growth, avoiding division by zero
```

### Complex Expressions
```yaml
nodes:
  - id: capacity_planning
    kind: expr
    expr: "MAX(demand + SHIFT(demand, 1) * 0.3, minimum_capacity)"
    # Plan capacity based on current + 30% of previous demand
    
  - id: utilization
    kind: expr
    expr: "CLAMP(demand / capacity, 0.0, 1.0)"
    # Calculate utilization, clamped to [0, 1] range
```

### Preparing for Future Retry Modeling
```yaml
# This syntax will work in M-04.05 (not implemented in M-01.05)
nodes:
  - id: service_with_retries
    kind: expr
    expr: |
      arrivals_total := arrivals + CONV(errors, [0.0, 0.6, 0.3, 0.1])
      attempts := MIN(capacity, arrivals_total)
      errors := attempts * fail_rate
      served := attempts - errors
```

---

## Migration Path

### From M-0/M-1 Simple Expressions
**Before (M-0):**
```yaml
- id: served
  kind: expr  
  expr: "demand * 0.8"  # Simple regex parsing
```

**After (M-01.05):**
```yaml
- id: served
  kind: expr
  expr: "demand * 0.8"  # Same syntax, better parser
```

### New Capabilities
**SHIFT operations:**
```yaml
- id: smoothed_demand
  kind: expr
  expr: "(demand + SHIFT(demand, 1) + SHIFT(demand, 2)) / 3"
```

**Complex calculations:**
```yaml  
- id: adaptive_capacity
  kind: expr
  expr: "base_capacity + MAX(0, demand - SHIFT(demand, 7)) * scale_factor"
```

---

## Future Extensibility

### M-04.05 Retry Modeling Preparation
The stateful node architecture established in M-01.05 directly enables:
- `CONV(errors, kernel)` - convolution for retry patterns
- `EMA(signal, alpha)` - exponential moving averages  
- `DELAY(x, kernel)` - arbitrary temporal spreading

### Expression Language Evolution
- **Multi-line expressions** - complex logic blocks
- **Conditional expressions** - IF/THEN/ELSE logic
- **Custom functions** - user-defined operators
- **Class-aware expressions** - per-class calculations

### Performance Optimizations
- **Expression compilation** - JIT or ahead-of-time compilation
- **Vectorization** - SIMD operations for large series
- **Lazy evaluation** - compute only required outputs

---

## Risk Mitigation

### **Risk: Parser Complexity**
- **Mitigation**: Start with simple recursive descent parser
- **Fallback**: Use existing regex approach for simple expressions

### **Risk: Performance Regression**  
- **Mitigation**: Benchmark against M-0 baseline, optimize hot paths
- **Fallback**: Make expression parsing opt-in for M-01.05

### **Risk: Breaking Changes**
- **Mitigation**: Comprehensive backward compatibility tests
- **Fallback**: Feature flag to disable new parser

### **Risk: Memory Usage**
- **Mitigation**: Use circular buffers, limit history depth
- **Monitoring**: Track memory usage in integration tests

---

## Documentation Deliverables

### User Documentation
- **Expression Syntax Guide** - comprehensive function reference
- **Migration Guide** - upgrading from simple expressions
- **Examples Gallery** - common expression patterns
- **Performance Guide** - optimization best practices

### Developer Documentation  
- **Architecture Overview** - stateful node design
- **Extension Guide** - adding new built-in functions
- **Testing Patterns** - golden vector test methodology
- **Debugging Guide** - troubleshooting expression issues

---

## Definition of Done

M-01.05 is complete when:

1. âœ… **All acceptance criteria met** - comprehensive test coverage
2. âœ… **Performance benchmarks pass** - no significant regression
3. âœ… **Documentation updated** - user and developer guides
4. âœ… **Backward compatibility verified** - all existing tests green
5. âœ… **Code review completed** - architecture and implementation reviewed
6. âœ… **Integration tests pass** - end-to-end scenarios work
7. âœ… **Demo scenarios work** - can show SHIFT in action

**Success Metrics:**
- Parse 100+ expressions/second (performance)
- <5% memory overhead for stateful nodes
- Zero breaking changes to existing models
- 90%+ test coverage for new expression code

---

This milestone establishes FlowTime as a true expression-based modeling engine while maintaining the deterministic, single-pass evaluation philosophy that makes it unique. The stateful node foundation enables powerful future capabilities while keeping the current implementation focused and deliverable.

# M-03.02 ‚Äî TelemetryLoader + Templates

**Status:** üìã Planned  
**Dependencies:** M-03.00 (Engine Foundation + Fixtures), M-03.01 (Time-Travel State APIs)  
**Target:** Deliver a repeatable path to capture deterministic run outputs as telemetry-mode bundles and feed them through template-driven authoring, producing canonical artifacts consumable by `/state` without manual curation.

---

## Overview

M-03.02 equips FlowTime with tooling to replay deterministic run outputs as telemetry bundles and orchestration to keep FlowTime-Sim templates in the loop. Building on the canonical writer and schema validation introduced in M-03.01, this milestone automates CSV capture, manifest authoring, and template instantiation so telemetry-mode runs land in the same storage envelope as simulation fixtures‚Äîwithout depending on a live ADX cluster. When real telemetry ingestion (e.g., ADX adapters) arrives, the capture tooling can become a regression aid while the canonical bundle shape and template workflow remain unchanged.

### Strategic Context
- **Motivation:** Telemetry-backed runs are blocked until loader outputs match the canonical artifact shape documented in `docs/releases/M-03.01.md`.
- **Impact:** Unified templates remove bespoke YAML editing, unlocking repeatable ingestion for operations teams and UI demos.
- **Dependencies:** Relies on M-03.00 fixtures for topology conventions and M-03.01 metadata envelopes for provenance and warning semantics.

---

## Scope

### In Scope ‚úÖ
1. Run artifact capture tooling that converts deterministic Engine run outputs into telemetry-mode CSVs + `manifest.json` aligned with canonical storage layout.
2. Template orchestration that leverages FlowTime-Sim‚Äôs `/templates/{id}/generate` contract to produce validated `model.yaml` outputs, keeping ownership with Sim.
3. Workflow documentation and scripting that stitches captured telemetry bundles to template parameters via Sim APIs (e.g., `curl POST /templates/{id}/generate`) and canonical artifact writer steps.
4. Warning collection and provenance metadata propagated through captured bundles and instantiated models.
5. Example telemetry templates (order-system, microservices, http-service) validated end-to-end using captured telemetry bundles.
6. Guidance clarifying that once live telemetry ingestion (e.g., ADX) is available, Engine can ingest bundles directly while Sim remains responsible only for template generation and future what-if scenarios.

### Out of Scope ‚ùå
- Engine API changes beyond wiring canonical artifacts created by this milestone.
- Live ADX connectivity, managed identity setup, or production credential management.
- Advanced templating constructs (conditionals, loops, custom evaluators).
- UI integration or visualization updates (tracked under UI milestones).
- Validation polish and end-to-end observability instrumentation (deferred to M-03.03).

### Future Work
- Surface loader warnings and provenance indicators through `/v1/run` telemetry mode orchestration (M-03.03).
- Expand template ecosystem to cover hybrid simulation/telemetry scenarios.
- Investigate incremental refresh workflows for rolling telemetry windows.
- Transition capture tooling into a regression aid once live telemetry loaders (ADX adapters) ship, ensuring ingestion paths remain common.

---

## Requirements

### Functional Requirements

#### FR1: Telemetry Bundle Capture Pipeline
**Description:** Provide repeatable tooling that extracts canonical telemetry bundles (CSVs + manifest) from deterministic Engine runs so telemetry-mode scenarios can be exercised without real ADX access.

**Acceptance Criteria:**
- [ ] Captures per-node CSV files for arrivals, served, queue depth, errors, and optional external demand directly from `RunArtifactWriter` outputs.
- [ ] Produces `manifest.json` capturing `window`, `grid`, `files[]`, `warnings[]`, and `provenance` (run id, template id, hash, checksum) matching canonical layout.
- [ ] Supports optional gap/sparsity injection with machine-readable warning codes (`data_gap`, `nan_fill`, etc.) for telemetry-mode validation.
- [ ] Provides CLI entry point `flowtime telemetry capture --run-dir data/runs/order-system --output ./out/order-system-telemetry` with dry-run mode describing planned outputs.
- [ ] Documents how captured bundles align with future ADX manifests so the ingestion path can later swap to live telemetry without structural changes.

**CLI Usage (initial tooling):**

```bash
flowtime telemetry capture --run-dir data/runs/run_deterministic_72ca609c --dry-run
```

The command defaults to writing bundles under `$FLOWTIME_DATA_DIR/telemetry/<runId>` and emits `manifest.json` shaped by `docs/schemas/telemetry-manifest.schema.json`.

#### FR2: Template Authoring & Sim Integration
**Description:** Leverage FlowTime-Sim‚Äôs template runtime to instantiate canonical models while keeping ownership within Sim (current schema supports scalar primitives and arrays; future template enhancements remain Sim‚Äôs responsibility).

**Acceptance Criteria:**
- [ ] Template schema reference published under `docs/schemas/template.schema.json` (synced from FlowTime-Sim) with authoring guidance for Engine consumers.
- [ ] Orchestration scripts/CLI call FlowTime-Sim `/templates/{id}/generate` (or CLI equivalent) to obtain `model.yaml` and provenance metadata (e.g. `scripts/time-travel/run-sim-template.sh`).
- [ ] Parameter bundles support Sim‚Äôs declared parameter types (scalar primitives and arrays) with explicit defaults and required flags documented for UI orchestration.
- [ ] Instantiated output feeds directly into `RunArtifactWriter` to emit canonical `model.yaml`, `metadata.json`, and `provenance.json`.
- [ ] Manual steps are documented for environments where Sim service and Engine CLI run separately, keeping concerns isolated.

#### FR3: Capture ‚Üî Template Integration Workflow
**Description:** Ensure captured telemetry bundles flow through Sim templates into canonical bundles that `/state` can replay.

**Acceptance Criteria:**
- [ ] Documented workflow demonstrates captured telemetry directory wired into template parameters (e.g., `telemetry_dir`) without manual editing.
- [ ] Integration tests cover end-to-end path: capture telemetry bundle from Engine run ‚Üí call Sim `/templates/{id}/generate` with references to bundle ‚Üí run `RunArtifactWriter` ‚Üí call `StateQueryService`.
- [ ] Provenance metadata links captured manifest, template-generated model metadata, and canonical artifact bundle.
- [ ] Warning and provenance metadata propagate into API responses via existing canonical writer paths.
- [ ] Golden fixtures checked in for captured bundles and instantiated template bundles.

### Non-Functional Requirements

#### NFR1: Performance & Resource Guardrails
**Target:** Capture telemetry windows up to 288 bins √ó 50 nodes with median runtime ‚â§ run duration and peak memory ‚â§250‚ÄØMB.
**Validation:** Performance test harness using deterministic run outputs and file IO instrumentation.

#### NFR2: Determinism & Reproducibility
**Target:** Capture pipeline produces identical bundles given the same run artifacts + gap configuration, enabling golden coverage and parity across environments.
**Validation:** Regression tests comparing checksum outputs before/after code changes.

#### NFR3: Observability & Auditability
**Target:** Emit structured logs and manifest metadata capturing run id, template id, gap configuration, and capture timestamps for audit trails.
**Validation:** Log assertions within integration tests + manual inspection instructions in milestone tracker.

---

## Inputs, Outputs & Schemas

### Inputs
- **Deterministic Run Outputs:** Canonical artifacts produced by Engine (via `RunArtifactWriter`) for simulation-mode runs.
- **Gap Injection Configuration (optional):** YAML/JSON describing bins to zero-fill, NaN, or partially remove to exercise telemetry warnings.
- **Template Definitions:** YAML templates managed by FlowTime-Sim under `templates/time-travel/`.
- **Sim Configuration:** FlowTime-Sim service URL or CLI path plus authentication details if required.
- **Parameters:** JSON/YAML files providing template inputs (e.g., `telemetry_dir`, `startUtc`, `binCount`), aligned with Sim template definitions.

### Outputs

| Artifact | Description |
|----------|-------------|
| `CSV files` | Per-metric time series exported by capture pipeline (`arrivals.csv`, `served.csv`, etc.). |
| `manifest.json` | Captures window/grid metadata, metric file descriptors, warnings, checksum, captured run provenance. |
| `model.yaml` | Canonical FlowTime model generated via FlowTime-Sim template instantiation. |
| `metadata.json` | Mirrors canonical writer metadata fields, including template origin and captured run identifiers. |
| `provenance.json` | Records template id/version, parameter hash, captured run id/hash, and capture pipeline version. |
| `capture.log` (optional) | Structured execution log for troubleshooting capture sessions. |

### Schema References
- `docs/schemas/time-travel-state.schema.json` ‚Äî response schema for `/state` consumers, ensuring loader outputs remain compatible.
- `docs/schemas/template.schema.json` ‚Äî new schema defining template structure, parameter metadata, and include rules.
- `docs/schemas/telemetry-manifest.schema.json` ‚Äî new schema validating captured telemetry manifests.

---

## Technical Design

### Telemetry Capture Architecture
- **Run Artifact Reader:** Loads canonical artifacts (`series/index.json`, per-node CSV, metadata) produced by `RunArtifactWriter`.
- **Bundle Normaliser:** Renames and organises captured series into telemetry-mode directories (arrivals, served, queue, etc.) and ensures CSV headers align with ingestion expectations.
- **Gap & Warning Injector (optional):** Applies configurable gap strategies (zero-fill, NaN, partial data) to captured series and records warnings with structured codes.
- **Manifest Builder:** Generates telemetry `manifest.json` containing window/grid metadata, file descriptors, warnings, and provenance (run id, template id, hashes).
- **CLI Integration:** `flowtime telemetry capture` command orchestrates capture, optional gap injection, manifest writing, and dry-run reporting.

### Template Orchestration Architecture
- **Sim Integration Layer:** Invokes FlowTime-Sim `/templates/{id}/generate` (or CLI) with parameter bundles referencing captured telemetry directories.
- **Parameter Binder:** Validates and serialises parameter payloads (scalars, arrays) before dispatching to Sim.
- **Canonical Writer Bridge:** Pipes Sim-generated `model.yaml` + provenance metadata into `RunArtifactWriter` to emit canonical bundles.
- **Automation Scripts:** Provide reproducible shell/PowerShell examples to run Sim generation and Engine artifact writing in sequence.
- **Future ADX Integration:** Once live telemetry ingestion is available, these orchestration steps remain useful for scenarios and template instantiation, while captured bundles can be replaced with Loader-produced telemetry.

### Integration Touchpoints
- Capture manifest `provenance` feeds template instantiation metadata, ensuring consistent hashes surfaced through `/state`.
- Workflow documentation emphasises Sim ownership while guiding operators through multi-step orchestration.
- Configuration examples cross-link capture outputs, gap injection settings, Sim template parameters, and API expectations to keep teams aligned.

---

## Implementation Plan

### Phase 1: Telemetry Capture Foundations
**Goal:** Build the capture pipeline that converts deterministic run outputs into telemetry-mode bundles.

**Tasks:**
1. Implement run artifact reader and capture CLI (`flowtime telemetry capture`) with dry-run support.
2. Add optional gap/warning injector and manifest builder aligned with canonical layout.
3. Produce golden capture bundles for representative runs (order-system, microservices, http-service).

**Deliverables:**
- Capture CLI + supporting libraries.
- Golden capture bundles with manifest + CSV outputs.
- Documentation covering capture workflow and gap configuration.

**Success Criteria:**
- [ ] Capture CLI reproduces canonical bundles from deterministic runs.
- [ ] Manifests capture warnings and provenance metadata.
- [ ] Golden fixtures added for regression coverage.

### Phase 2: Sim Template Integration
**Goal:** Orchestrate FlowTime-Sim template generation using captured telemetry bundles.

**Tasks:**
1. Author scripts/CLI helpers that call Sim `/templates/{id}/generate` (or CLI) with parameter payloads referencing captured bundles.
2. Ensure generated models feed into `RunArtifactWriter` to emit canonical artifacts referencing captured telemetry.
3. Publish template parameter mapping tables and examples in `docs/templates/README.md`.

**Deliverables:**
- Automation scripts + CLI glue invoking Sim service.
- Updated documentation linking capture outputs to template parameters.
- Provenance alignment tests between Sim outputs and canonical bundles.

**Success Criteria:**
- [ ] Sim `/generate` invocation produces models referencing captured telemetry without manual edits.
- [ ] Canonical bundles include matching template + capture provenance metadata.
- [ ] Documentation reviewed with Sim and Engine owners.

### Phase 3: End-to-End Validation & Docs
**Goal:** Validate the capture ‚Üí template ‚Üí `/state` workflow and capture operator guidance.

**Tasks:**
1. Add integration tests covering capture ‚Üí Sim ‚Üí `RunArtifactWriter` ‚Üí `StateQueryService`.
2. Update documentation with workflow guides, troubleshooting, and UI orchestration notes.
3. Capture golden responses and observability checks for telemetry-mode `/state` calls using captured bundles.

**Deliverables:**
- Integration + golden tests.
- Updated docs (workflow guide, Sim integration notes, troubleshooting).
- Tracking of observability signals (logs, warning propagation).

**Success Criteria:**
- [ ] End-to-end test passes using captured bundles and Sim templates.
- [ ] `/state` reads captured bundles without manual edits.
- [ ] Documentation reviewed and linked from roadmap + milestone tracker.

---

## Test Plan

### Strategy
Adopt a layered approach: unit tests for capture and gap injection, integration tests for Sim orchestration, and golden fixtures for canonical outputs. Reuse deterministic runs to keep tests reproducible.

### Unit Tests
- Capture pipeline parsing/validation, CSV normalisation, gap injection, manifest writing, warning recording.
- Parameter binder serialisation to Sim `/templates/{id}/generate`.
- CLI argument parsing and configuration binding for capture command.

### Integration Tests
- Capture ‚Üí Sim `/generate` ‚Üí `RunArtifactWriter` path for each example template.
- `/state` replay using captured bundle to confirm compatibility with existing API contracts.
- Determinism checks ensuring identical checksum output across repeated captures.

### Golden / Contract Tests
- Approved capture output bundle (CSV + manifest) for fixture telemetry scenario.
- Approved instantiated template bundle ensuring deterministic canonical writer output.
- Schema validation tests for `template.schema.json` and `telemetry-manifest.schema.json`.

---

## Documentation & Deliverables

- Update `docs/templates/README.md` with template parameter mapping to captured telemetry directories and Sim integration guidance.
- Add telemetry capture guide (`docs/operations/telemetry-capture-guide.md`) covering capture workflow, gap injection, seeds, and troubleshooting.
- Expand `FlowTime.CLI` reference to document new capture command and Sim orchestration scripts (including `scripts/time-travel/run-sim-template.sh`).
- Refresh roadmap and milestone tracking entries to highlight new workstream readiness.

---

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Captured bundles diverge from eventual ADX exports | Document mapping assumptions, keep capture schema aligned with telemetry manifest, plan validation once ADX is available. |
| Sim `/generate` contract changes unexpectedly | Track schema version, add smoke tests against Sim service, and coordinate releases. |
| Capture outputs diverge from canonical artifacts | Reuse canonical writer helpers, validate against schemas, and add `/state` integration tests. |
| CLI/script ergonomics slow adoption | Provide defaults, dry-run mode, detailed help text, and troubleshooting docs. |
| Warning overload obscures actionable issues | Categorise warnings with severity, aggregate counts, and document interpretation guidance. |

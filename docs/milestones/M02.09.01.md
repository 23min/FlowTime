# M2.9 — Schema Evolution & Documentation

**Status:** ✅ Complete (All Phases)  
**Dependencies:** ✅ FlowTime-Sim coordination complete  
**Target:** Complete schema evolution with documentation alignment and engine migration  
**Completion Date:** October 3, 2025

---

## Goal

Complete the evolution of FlowTime schema architecture, migrating from `binMinutes` to `binSize`/`binUnit` format for enhanced flexibility and time unit support. This milestone encompasses both comprehensive schema documentation and the core engine migration to unified schema formats.

## Context & Strategic Benefits

The schema evolution provides:
- **Enhanced Flexibility**: Support for hours, days, weeks, etc. natively in time specifications
- **Schema Unification**: Single schema format across Template and Engine systems  
- **Future-Proofing**: Extensible time unit system for diverse modeling scenarios
- **Reduced Complexity**: Elimination of translation layers between schema formats
- **Clean Breaking Change**: TDD approach enables confident migration without backward compatibility constraints

## Schema Architecture

### Current State Reality

**FlowTime-Sim Behavior**: Sim currently outputs `binMinutes` format specifically because Engine currently requires it. This is NOT the preferred format - it's a compatibility shim.

**Translation Flow Today**:
```yaml
# 1. User writes Template (input to Sim)
grid:
  bins: 24
  binSize: 1
  binUnit: hours

# 2. Sim converts during generation
grid:
  bins: 24
  binMinutes: 60  # ← Conversion for Engine compatibility

# 3. Engine receives Model (current limitation)
```

**Key Insight**: The `binMinutes` conversion exists solely for backward compatibility with Engine's current limitations, not because it's a better format.

### Target Model Schema

The unified schema both systems will converge to:

**Grid Format**: `binSize` + `binUnit` (replaces `binMinutes`)  
**Node Expression Field**: `expr` (not `expression`)  
**Outputs**: `series` / `as` (not `filename`)  
**Version Field**: `schemaVersion: 1` (required)  
**Supported Time Units**: `minutes`, `hours`, `days`, `weeks`

**Target Flow (Post-M2.9)**:
```yaml
# 1. User writes Template
grid:
  bins: 24
  binSize: 1
  binUnit: hours

# 2. Sim passes through (NO conversion)
grid:
  bins: 24
  binSize: 1
  binUnit: hours

# 3. Engine accepts and converts internally
# binSize × binUnit → minutes (internal)
```

**Documentation**: See `docs/schemas/target-model-schema.md` for complete specification.

**Analysis**: See `docs/schemas/M2.9-ANALYSIS.md` for detailed comparison and rationale.

## Four-Phase Evolution Plan

### Phase 0: Test-Driven Development Setup 📋 PLANNED

**Goal**: Establish clean test architecture and comprehensive coverage before engine evolution to ensure safe refactoring.

**TDD Strategy**: Isolate legacy tests, write comprehensive new tests for target schema, then implement breaking changes with confidence.

#### 0.1 Legacy Test Isolation
**Approach**: Move existing tests to `.Legacy` namespaces to preserve them while building new test suite.

**Namespace Migration:**
- `FlowTime.Core.Tests` → `FlowTime.Core.Tests.Legacy`
- `FlowTime.API.Tests` → `FlowTime.API.Tests.Legacy`
- `FlowTime.Contracts.Tests` → `FlowTime.Contracts.Tests.Legacy`

**Benefits:**
- **Clear Separation**: Old vs new tests clearly distinguished
- **Preservation**: Legacy tests remain functional during transition
- **Clean Architecture**: New tests start with proper structure
- **Safe Migration**: Can compare old vs new test results

#### 0.2 Breaking Change Strategy
**Philosophy**: Clean schema evolution without backward compatibility constraints.

**Rationale**: 
- **Development Phase**: FlowTime is in active development (0.x versioning)
- **TDD Safety**: Comprehensive test coverage eliminates migration risk
- **Clean Architecture**: Avoiding compatibility layers simplifies codebase
- **Future Flexibility**: Breaking cleanly now prevents technical debt

**Migration Approach**:
- **Legacy Preservation**: Move old tests to `.Legacy` namespaces
- **Target Implementation**: Build new implementation for target schema exclusively
- **Example Updates**: Update all examples to new schema format
- **Documentation**: Clear migration guide for any external users

#### 0.3 New Test Architecture
**Focus**: Write tests for evolved engine in proper namespaces before implementing changes.

**New Test Structure:**
```
FlowTime.Core.Tests/
├── TimeGrid/                    # New binSize/binUnit tests
├── Nodes/
│   ├── ConstNodeTests.cs       # Enhanced const node tests
│   ├── PmfNodeTests.cs         # New PMF node tests
│   └── ExprNodeTests.cs        # Updated expression tests
├── Rng/
│   └── Pcg32Tests.cs           # New RNG tests
├── Schema/
│   └── ValidationTests.cs      # New schema validation tests
└── Legacy/                     # Moved legacy tests
    └── [existing test files]

FlowTime.Cli.Tests/             # New CLI tests
├── TimeGrid/
│   └── CliTimeGridTests.cs     # CLI binSize/binUnit handling
├── Schema/
│   └── CliSchemaTests.cs       # CLI new schema validation
├── Output/
│   └── CliOutputTests.cs       # CLI artifact generation tests
└── Legacy/                     # Moved legacy CLI tests
    └── [existing test files]
```

**Test Categories:**
- **TimeGrid Evolution**: `binSize`/`binUnit` conversion and validation
- **PMF Node Support**: Probability distribution sampling and validation
- **RNG Integration**: PCG32 deterministic generation
- **Schema Validation**: New format validation and error handling
- **API Evolution**: Enhanced endpoints and content negotiation
- **CLI Evolution**: New schema support, output generation, example processing

#### 0.3 Test-First Development
**Goal**: Write failing tests that define success criteria before implementation.

**TDD Cycle:**
1. **Red**: Write test for new engine capability (fails)
2. **Green**: Implement minimum code to make test pass
3. **Refactor**: Clean up implementation while keeping tests green
4. **Repeat**: Move to next capability

**Success Criteria:**
- [ ] Legacy tests isolated in `.Legacy` namespaces
- [x] New test structure established
- [x] Failing tests written for all Phase 2 capabilities
- [x] Test coverage plan documented (in milestone section 2.4)
- [x] PCG32 RNG implementation complete (Phase 1 of PMF pipeline)
- [x] PMF Validation implementation complete (Phase 2 validation part of pipeline)
- [x] PMF Grid Alignment validation complete (Phase 2 alignment validation)

### Phase 1: Schema Documentation & Alignment ✅ COMPLETE

**Goal**: Document current state, define target state, and provide migration roadmap.

**What Phase 1 IS**:
- ✅ **Documentation**: Comprehensive specs for current and target schemas
- ✅ **Analysis**: Understanding current behavior and target evolution
- ✅ **Planning**: Migration strategy and implementation guidance
- ✅ **Alignment**: Coordinating Engine and Sim evolution

**What Phase 1 is NOT**:
- ❌ **Implementation**: No code changes to Engine or Sim (that's Phase 2 & 3)
- ❌ **Schema Changes**: Current schemas remain unchanged
- ❌ **Breaking Changes**: No user-facing impacts yet

**Completed Work:**
- **Current State Documentation**: 
  - Template Schema (Sim authoring format with `binSize`/`binUnit`)
  - Engine Input Schema (current `binMinutes` format)
  - Schema relationship clarification
- **Target State Definition**:
  - Target Model Schema (unified `binSize`/`binUnit` format)
  - Field-by-field specification
  - Validation rules and error handling
- **Evolution Strategy**:
  - M2.9 Analysis with recommendations
  - Breaking change impact assessment
  - Versioning and release strategy
  - Implementation guidance for both systems

**Deliverables:**
- `docs/schemas/template-schema.md` - Current Sim template format
- `docs/schemas/engine-input-schema.md` - Current Engine input format
- `docs/schemas/engine-input.schema.json` - JSON Schema for current format
- `docs/schemas/README.md` - Schema architecture overview
- `docs/schemas/target-model-schema.md` - **NEW**: Target unified schema
- `docs/schemas/target-model-schema.yaml` - **NEW**: Target JSON Schema definition
- `docs/schemas/M2.9-ANALYSIS.md` - **NEW**: Evolution analysis and strategy
- Updated API endpoint references throughout documentation

### Phase 2: FlowTime Engine Evolution ✅ COMPLETE

**Goal**: Evolve Engine to accept Target Model Schema format.

**Completion Date**: October 2025  
**Test Results**: 221/224 tests passing (99%), 4 legacy tests pending cleanup

**Core Engine Updates:**

#### 2.1 TimeGrid Evolution (`binSize`/`binUnit`)
```csharp
public enum TimeUnit { Minutes, Hours, Days, Weeks }

public static int ToMinutes(this TimeUnit unit, int binSize)
{
    return unit switch
    {
        TimeUnit.Minutes => binSize,
        TimeUnit.Hours => binSize * 60,
        TimeUnit.Days => binSize * 1440,
        TimeUnit.Weeks => binSize * 10080,
        _ => throw new ArgumentException($"Unsupported: {unit}")
    };
}
```

#### 2.2 Model Parser Updates
- Update parser to read `binSize`/`binUnit` instead of `binMinutes`
- Add internal conversion: `binSize` × `binUnit` → minutes
- Remove support for legacy `binMinutes` format
- Require `schemaVersion: 1` field in all models

#### 2.3 Schema Validation
- Validate `binSize` range (1-1000)
- Validate `binUnit` enum values
- Validate schema version (reject unsupported versions)
- Enhanced error messages for schema violations

#### 2.4 PMF Node Implementation

**PMF Compilation Pipeline** - Engine compiles PMF nodes to deterministic const series during model ingest:

**1. Validation Phase**:
```csharp
// Non-negativity check
if (pmf.Probabilities.Any(p => p < 0))
    throw new ValidationException("Probabilities must be non-negative");

// Normalization check (within tolerance)
var sum = pmf.Probabilities.Sum();
if (Math.Abs(sum - 1.0) > 0.001)
{
    // Optional: renormalize with warning
    LogWarning($"PMF probabilities sum to {sum}, renormalizing to 1.0");
    pmf.Probabilities = pmf.Probabilities.Select(p => p / sum).ToArray();
}

// Length matching
if (pmf.Values.Length != pmf.Probabilities.Length)
    throw new ValidationException("Values and probabilities must have equal length");
```

**2. Grid Alignment Phase**:
```csharp
// Check PMF length vs grid.bins
if (pmf.Values.Length == grid.Bins)
{
    // Perfect match - use as-is
    return pmf.Values;
}
else if (pmf.Policy == "repeat" && grid.Bins % pmf.Values.Length == 0)
{
    // Tile PMF to grid size
    return TileArray(pmf.Values, grid.Bins);
}
else if (pmf.Policy == "error")
{
    throw new ValidationException($"PMF length {pmf.Values.Length} does not match grid.bins {grid.Bins}");
}
else
{
    throw new ValidationException($"Unsupported PMF policy: {pmf.Policy}");
}
```

**3. Compilation Phase**:
```csharp
// Compile PMF to deterministic const series
var rng = new Pcg32(seed);
var compiledSeries = new double[grid.Bins];

for (int i = 0; i < grid.Bins; i++)
{
    // Sample from PMF using deterministic RNG
    var sample = SampleFromPmf(pmf.Values, pmf.Probabilities, rng);
    compiledSeries[i] = sample;
}

// Replace PMF node with const node internally
node.Kind = NodeKind.Const;
node.Values = compiledSeries;
```

**~~4. Provenance Tracking~~**: **SKIPPED**

> **Decision**: PMF-level provenance deemed redundant given FlowTime's deterministic compilation.
> 
> **Rationale**: 
> - Engine is deterministic: `compile(PMF, seed) → same output always`
> - PMF definition already in `spec.yaml`
> - RNG seed already in `manifest.json` or model
> - Any PMF can be recompiled on-demand from source
> - Per-node provenance = 2.5× storage overhead for 1000-node models
> - No functional benefit over model-level provenance + deterministic recompilation
> 
> **What we DO track**:
> - Model-level provenance (template_id, model_id) - not redundant
> - RNG seed in manifest.json - for reproducibility
> - model_hash - detects any changes
> 
> **Future**: Can add PMF provenance later if actual need emerges (debug mode, auditing requirements, etc.)

**PMF Example**:
```yaml
# Input PMF (7-day pattern for 14-bin grid)
- id: weekly_pattern
  kind: pmf
  pmf:
    values: [0.8, 1.2, 1.0, 0.9, 1.1, 0.7, 0.6]
    probabilities: [0.14, 0.14, 0.14, 0.14, 0.14, 0.14, 0.16]
    policy: repeat

# After compilation (internal const series)
- id: weekly_pattern
  kind: const
  values: [0.8, 1.2, 1.0, 0.9, 1.1, 0.7, 0.6, 0.8, 1.2, 1.0, 0.9, 1.1, 0.7, 0.6]
```

**Key Implementation Points**:
- **No Resampling**: v1 supports only `repeat` and `error` policies (no stochastic resampling)
- **Deterministic**: Same seed produces identical compiled series
- **Grid Alignment**: PMF length must divide evenly into grid.bins when using `repeat`
- **~~Provenance~~**: Skipped (redundant with deterministic compilation + spec.yaml + manifest.json)

#### 2.5 RNG Integration

> **See**: [`docs/architecture/rng-algorithm.md`](../architecture/rng-algorithm.md) for detailed algorithm selection rationale, performance analysis, and comparison with alternatives.

**PCG32 Implementation**:
```csharp
public class Pcg32
{
    private ulong _state;
    private readonly ulong _increment;

    public Pcg32(int seed)
    {
        _state = (ulong)seed;
        _increment = 1442695040888963407ul; // Default stream
    }

    public uint Next()
    {
        ulong oldState = _state;
        _state = oldState * 6364136223846793005ul + _increment;
        uint xorShifted = (uint)(((oldState >> 18) ^ oldState) >> 27);
        int rot = (int)(oldState >> 59);
        return (xorShifted >> rot) | (xorShifted << ((-rot) & 31));
    }

    public double NextDouble()
    {
        return Next() / (double)uint.MaxValue;
    }
}
```

**RNG Configuration**:
```yaml
# Optional RNG section in model
rng:
  kind: pcg32
  seed: 12345

# Validation
- kind must be "pcg32" (only supported algorithm in v1)
- seed must be integer 0 to 2147483647
- If omitted, use default seed or environment-based seed
```

#### 2.6 Model Provenance Support

**Goal**: Enable complete traceability from template (FlowTime-Sim) → model → run → results.

**Problem**: Currently, when FlowTime-Sim generates a model and UI posts it to Engine, all Sim metadata (template_id, parameter values, generation timestamp) is lost. We can't answer: "Which template created this model?" or "What parameters were used?"

**Solution**: Engine accepts optional provenance metadata and stores it with run artifacts.

**Architecture Note**: This is **Engine-side work only**. Engine accepts and stores provenance permanently. Sim-side provenance generation is SIM-M2.7. UI orchestration is separate work. Engine and Sim do NOT communicate directly - UI coordinates the workflow. See `docs/architecture/run-provenance.md` and `flowtime-sim-vnext/docs/architecture/registry-integration.md` for complete architecture.

**API Enhancement** - Accept provenance via HTTP header:
```http
POST /v1/run
X-Model-Provenance: model_20250925T120000Z_abc123def
Content-Type: application/x-yaml

schemaVersion: 1
grid:
  bins: 12
  binSize: 1
  binUnit: hours
nodes:
  # ...
```

**Alternative** - Accept provenance embedded in model YAML:
```yaml
POST /v1/run
Content-Type: application/x-yaml

schemaVersion: 1

# Optional provenance section (FlowTime-Sim will populate this)
provenance:
  source: flowtime-sim
  model_id: model_20250925T120000Z_abc123def
  template_id: it-system-microservices
  generated_at: "2025-09-25T12:00:00Z"
  parameters:
    bins: 12
    binSize: 1
    binUnit: hours
    # ... all parameter values

grid:
  bins: 12
  binSize: 1
  binUnit: hours
nodes:
  # ...
```

**Precedence**: If both header and embedded provenance present, **header wins**. Log warning and use header value.

**Storage behavior**: Provenance stripped from `spec.yaml` (clean execution spec only), stored in `provenance.json`. This ensures consistent storage format regardless of input method.

**Hash calculation**: `model_hash` computed from execution spec only (grid + nodes). Provenance excluded - models with identical logic but different provenance have same hash and are deduplicated.

**Storage** - New `provenance.json` file in run artifacts:
```
/data/run_20250925T120500Z_xyz789/
├── spec.yaml              # Model content
├── manifest.json          # Execution metadata
├── run.json               # Run info
├── provenance.json        # NEW: Model provenance reference
└── series/                # Results
```

**provenance.json schema**:
```json
{
  "source": "flowtime-sim",
  "model_id": "model_20250925T120000Z_abc123def",
  "template_id": "it-system-microservices",
  "template_version": "1.0",
  "generated_at": "2025-09-25T12:00:00Z",
  "received_at": "2025-09-25T12:05:00Z",
  "sim_version": "0.4.0",
  "parameters": {
    "bins": 12,
    "binSize": 1,
    "binUnit": "hours",
    "loadBalancerCapacity": 300
  },
  "links": {
    "model_artifact": "/api/v1/models/model_20250925T120000Z_abc123def"
  }
}
```

**Updated manifest.json** - Include provenance reference:
```json
{
  "run_id": "run_20250925T120500Z_xyz789",
  "model_hash": "sha256:abc123...",
  "execution_time_ms": 1250,
  "provenance": {
    "has_provenance": true,
    "model_id": "model_20250925T120000Z_abc123def",
    "source": "flowtime-sim"
  },
  "created_at": "2025-09-25T12:05:00Z"
}
```

**Implementation Details**:
```csharp
// 1. Extract provenance from header or embedded YAML
private ProvenanceMetadata? ExtractProvenance(HttpRequest req, string modelYaml)
{
    // Priority 1: HTTP header (cleaner)
    if (req.Headers.TryGetValue("X-Model-Provenance", out var modelId))
    {
        return new ProvenanceMetadata { ModelId = modelId.ToString() };
    }
    
    // Priority 2: Embedded in YAML (self-contained)
    var yamlDoc = YamlParser.Parse(modelYaml);
    if (yamlDoc.ContainsKey("provenance"))
    {
        return DeserializeProvenance(yamlDoc["provenance"]);
    }
    
    return null; // No provenance (backward compatible)
}

// 2. Store provenance.json if provided
public async Task<RunResult> ExecuteAsync(string modelYaml, ProvenanceMetadata? provenance)
{
    var runId = GenerateRunId();
    var runDir = Path.Combine(_dataDir, runId);
    
    // ... existing file creation ...
    
    // NEW: Write provenance.json if provided
    if (provenance != null)
    {
        provenance.ReceivedAt = DateTime.UtcNow;
        await File.WriteAllTextAsync(
            Path.Combine(runDir, "provenance.json"),
            JsonSerializer.Serialize(provenance, _jsonOptions)
        );
    }
    
    // ... execute model ...
}
```

**Registry Enhancement** - Index runs by provenance:
```json
{
  "artifacts": [
    {
      "id": "run_20250925T120500Z_xyz789",
      "type": "run",
      "provenance": {
        "model_id": "model_20250925T120000Z_abc123def",
        "template_id": "it-system-microservices",
        "source": "flowtime-sim"
      }
    }
  ]
}
```

**New Query Capabilities**:
```bash
# Find all runs from a specific model
GET /v1/runs?model_id=model_20250925T120000Z_abc123def

# Find all runs from a specific template
GET /v1/runs?template_id=it-system-microservices

# Get provenance file
GET /v1/runs/{run_id}/provenance.json
```

**Backward Compatibility**:
- ✅ Provenance is **optional** - runs without provenance work as before
- ✅ Header or embedded format - Engine accepts both
- ✅ No breaking changes to existing `/v1/run` behavior
- ✅ Old runs without provenance.json continue to work

**Benefits**:
- ✅ Complete traceability: template → model → run → results
- ✅ Reproducible models: know exact parameters used
- ✅ Enhanced compare: compare runs from same template
- ✅ Audit trail: who generated what, when

**Coordination**: Requires FlowTime-Sim to implement model registry (SIM-M3.x) and return `model_id` in `/generate` endpoint response. See `flowtime-sim-vnext/docs/architecture/model-provenance.md` for Sim-side implementation.

**Reference**: See `docs/architecture/run-provenance.md` for complete implementation details.

#### 2.7 Additional Features
- **Expression Enhancements**: Ensure `expr` field support (not `expression`)
- **Output Format**: Ensure `series`/`as` format support (not `filename`)
- **Dependency Inference**: Parse expressions to determine node dependencies (no explicit `dependencies` field)

**Breaking Changes**:
- ❌ Engine no longer accepts `binMinutes` format
- ✅ Engine requires `schemaVersion: 1` field
- ✅ Engine requires `binSize` and `binUnit` fields
- ⚠️ Version bump: 0.4.x → 0.5.0

**Reference**: See `docs/schemas/target-model-schema.md` for complete specification.

### Phase 2.1: CLI Architecture Modernization 📋 PLANNED

**Goal**: Evolve FlowTime CLI to be a focused developer tool working directly against evolved core engine.

**CLI Design Philosophy:**
- **Primary Tool**: Command should be `flowtime` (not `flowtime-cli`)
- **Developer-Focused**: Optimized for model development, testing, and automation
- **Local Execution**: Works completely offline with filesystem I/O
- **Direct Core Access**: No API dependencies or network requirements

**Core CLI Capabilities:**

```bash
# Basic model execution
flowtime model.yaml                     # Execute model, output to ./data/
flowtime model.yaml --output results/   # Custom output directory

# Development workflow
flowtime model.yaml --validate          # Schema validation only
flowtime model.yaml --dry-run           # Parse without execution  
flowtime model.yaml --verbose           # Detailed logging and metrics

# Reproducible execution
flowtime model.yaml --seed 12345        # Override RNG seed
flowtime model.yaml --deterministic     # Deterministic run IDs
```

**Schema Support Requirements:**
- **Input Processing**: Accept YAML models with `binSize`/`binUnit` format
- **TimeGrid Evolution**: Support flexible time units (minutes, hours, days, weeks)
- **PMF Nodes**: Process probability mass function definitions
- **RNG Integration**: Handle PCG32 deterministic random number generation
- **Validation**: Clear error messages for schema violations

**Output Generation:**
- **CSV Results**: Primary output format for analysis tools
- **Artifact Manifests**: Include schema metadata and run provenance
- **Verbose Logging**: Display execution plan and performance metrics
- **Error Reporting**: Clear diagnostic messages for failures

**Architecture Benefits:**
- **Fast Iteration**: Sub-second execution for typical models
- **Automation-Ready**: Perfect for CI/CD and scripting workflows
- **Portable**: Runs anywhere .NET runtime is available
- **Deterministic**: Reproducible results for testing and validation

**Files Requiring Updates:**
```
src/FlowTime.Cli/
├── Program.cs              # Remove --via-api, add new schema support
├── Configuration/          # Update for binSize/binUnit parameters
├── Validation/             # New schema validation logic
└── Output/                 # Update artifact generation

examples/
├── hello/model.yaml        # Migrate to binSize/binUnit format
├── it-system/model.yaml    # Update schema format
├── transportation/model.yaml # Update schema format
└── [all examples]          # Complete schema migration

docs/guides/
└── CLI.md                  # Update with new schema examples
```

**CLI Evolution Priorities:**

**Phase 2.1a: Core Schema Support**
- Update TimeGrid handling for `binSize`/`binUnit`
- Implement new YAML schema parsing
- Add validation for PMF and RNG parameters
- Remove `--via-api` option completely

**Phase 2.1b: Enhanced Developer Experience**
- Add `--validate` for schema-only validation
- Implement `--dry-run` for parse-only mode
- Enhanced verbose output with execution metrics
- Improved error messages and diagnostics

**Phase 2.1c: Automation Support**
- Deterministic run ID generation
- Batch processing capabilities
- CI/CD-friendly exit codes and output
- JSON output format option

**CLI Usage Scenarios:**

**Model Development:**
```bash
# Typical development iteration
flowtime draft-model.yaml --validate    # Check schema
flowtime draft-model.yaml --dry-run     # Verify parsing
flowtime draft-model.yaml --verbose     # Full execution with metrics
```

**Testing & Validation:**
```bash
# Reproducible testing
flowtime model.yaml --seed 42 --deterministic
flowtime model.yaml --seed 123          # Different seed, different results

# Schema validation
flowtime *.yaml --validate --batch      # Validate multiple models
```

**CI/CD Integration:**
```bash
# Automated testing
flowtime examples/**/*.yaml --batch --quiet
flowtime model.yaml --validate --junit-output
```

**Runtime Characteristics:**
- **Execution Speed**: ~100ms for typical models, <1s for complex models
- **Memory Usage**: Streams results to files, minimal memory footprint
- **Dependencies**: Only requires .NET runtime, no external services
- **Offline Capable**: No network requirements, works in air-gapped environments

**Strategic Benefits:**
- **Schema Unification**: Single format eliminates translation complexity
- **Stochastic Modeling**: Native PMF and RNG support for advanced simulations
- **Enhanced Capabilities**: Full time unit flexibility (minutes, hours, days, weeks)
- **Future-Proof Architecture**: Extensible foundation for advanced modeling features

### Phase 3: FlowTime-Sim & Examples Migration ✅ COMPLETE

**Goal**: Update FlowTime-Sim to output Target Model Schema format and migrate all examples.

**Completion Date**: October 3, 2025  
**Git Commits**: 
- Sim: `e04923c` (schema evolution), `949149f` (integration tests)
- Engine: `8843f4d` (legacy schema validation)

#### 3.1 FlowTime-Sim Evolution

**Core Changes** (Simplified!):
```csharp
// REMOVE this conversion logic entirely:
private string ConvertGridToEngineFormat(string yaml)
{
    // Old: Convert binSize/binUnit → binMinutes
    // New: REMOVE - pass through as-is
}

// ENSURE schemaVersion in output:
if (!yaml.Contains("schemaVersion:"))
{
    yaml = "schemaVersion: 1\n" + yaml;
}
```

**Benefits**:
- ✅ Simplifies Sim codebase (removes translation layer)
- ✅ Templates already use correct format (no user-facing changes)
- ✅ Direct pass-through from template to model

**Breaking Changes**:
- ✅ Sim outputs `binSize`/`binUnit` instead of `binMinutes`
- ✅ Sim always includes `schemaVersion: 1` in output
- ⚠️ Version bump: 0.3.1 → 0.4.0

**Coordination**: Sim 0.4.0 requires Engine 0.5.0 (must release Engine first).

#### 3.2 FlowTime CLI Updates

**CLI Migration Details:**
- **Schema Processing**: CLI reads and validates new YAML schema format
- **TimeGrid Handling**: CLI processes `binSize`/`binUnit` parameters correctly
- **Output Format**: CLI artifacts use new schema format consistently
- **Verbose Logging**: CLI displays `binSize`/`binUnit` instead of `binMinutes`
- **Example Migration**: All models in `examples/` directory updated to new schema
- **Documentation**: CLI guide updated with new schema examples and usage patterns
- **Architecture Cleanup**: Remove `--via-api` option (CLI uses core directly)

#### 3.3 Example & Documentation Migration

**Migration Scope:**
- **Example Models**: Update all model examples to use `binSize`/`binUnit` format
- **Test Suite**: Migrate test cases to new schema format
- **Documentation**: Update all guides and references to reflect unified schema
- **Legacy Cleanup**: Remove references to old `binMinutes` format
- **Migration Guide**: Create `docs/migrations/m2.9-schema-evolution.md`

**Example Conversion Table**:
```
Old: binMinutes: 1     → New: binSize: 1,  binUnit: minutes
Old: binMinutes: 60    → New: binSize: 1,  binUnit: hours
Old: binMinutes: 1440  → New: binSize: 1,  binUnit: days
Old: binMinutes: 10080 → New: binSize: 1,  binUnit: weeks
```

## Current Status

**✅ Phase 0 Complete**: TDD test setup finished
- 158 comprehensive tests created (4,148 lines)
- Test architecture established with legacy isolation
- All tests compiled and verified in RED state

**✅ Phase 1 Complete**: Schema documentation and alignment work finished
- Comprehensive template and engine schema documentation created
- API endpoint standardization completed  
- FlowTime-Sim integration documentation aligned

**✅ Phase 2 Complete**: Engine implementation finished
- TimeGrid evolution (binSize/binUnit) implemented
- Schema validation with schemaVersion support added
- PMF compilation pipeline (4 phases) implemented
- PCG32 RNG with deterministic generation integrated
- Model provenance support (header + embedded) added
- 221/224 tests passing (99% success rate)
- **Git commits**: 911ff09, 6432057, 88c8c5a, 56f3486, bb48a56, 41114db, 7512ddc

**✅ Phase 3 Complete**: FlowTime-Sim alignment and integration testing finished (October 3, 2025)
- ✅ FlowTime-Sim conversion logic removed (Sim commit `e04923c`)
- ✅ Sim outputs `binSize`/`binUnit` format directly (no conversion)
- ✅ All Sim examples migrated to new schema format
- ✅ Comprehensive integration test suite added (Sim commit `949149f`)
  - 4/4 automated tests passing
  - Basic workflow validation
  - Provenance metadata flow
  - Legacy schema rejection (Engine commit `8843f4d`)
- ✅ End-to-end Sim ↔ Engine integration validated
- **Remaining cleanup**: 4 legacy Engine tests + adapter test assertions (non-blocking)

## Success Criteria

**Phase 1** (✅ Complete):
- [x] Comprehensive schema documentation published
- [x] Template and Engine schema relationships clarified
- [x] API endpoint standardization completed
- [x] FlowTime-Sim integration documentation aligned
- [x] **Target Model Schema created** (`target-model-schema.md` + `.yaml`)
- [x] **M2.9 Analysis completed** with recommendations and impact assessment

**Phase 2** (✅ Complete - October 2025):
- [x] `TimeUnit` enum added with conversion logic (commit 911ff09)
- [x] Model parser updated to read `binSize`/`binUnit` (commit 911ff09)
- [x] `schemaVersion` field required and validated (commit 6432057)
- [x] Legacy `binMinutes` support removed from core parser
- [x] **Model Provenance Support**:
  - [x] `/v1/run` endpoint accepts `X-Model-Provenance` header (commit 41114db)
  - [x] `/v1/run` endpoint accepts embedded `provenance` section in YAML (commit 7512ddc)
  - [x] `provenance.json` created in run artifacts when provenance provided
  - [x] `manifest.json` includes provenance reference
  - [x] Registry index includes provenance metadata
  - [x] Query filters by `model_id` and `template_id` implemented
- [x] PMF nodes implemented with distribution sampling (commits 88c8c5a, 56f3486, bb48a56)
- [x] RNG integration with PCG32 deterministic generation (commit 88c8c5a)
- [x] Enhanced validation with clear error messages
- [x] 221/224 tests passing (4 legacy tests pending cleanup)
- [x] Version bump to 0.6.0 (includes M2.6, M2.7, M2.8 features)

**Phase 3** (✅ Complete - October 3, 2025):  
- [x] FlowTime-Sim conversion logic removed (Sim commit `e04923c`)
- [x] FlowTime-Sim outputs `binSize`/`binUnit` format
- [x] FlowTime-Sim version ready for 0.5.0 bump (breaking change)
- [x] All Sim examples migrated to new schema format
- [x] Engine CLI updated to support new schema (commit `8843f4d`)
- [x] Engine validates and rejects legacy schema with clear errors
- [x] Comprehensive integration test suite validates new schema (Sim commit `949149f`)
- [x] Documentation reflects unified schema throughout
- [ ] Migration guide published (pending)
- [ ] Cleanup: 4 legacy Engine tests + adapter assertions (non-blocking)

## Versioning Strategy

### Version Bumps

**FlowTime Engine**:
```
Current: 0.4.x
After M2.9: 0.5.0
Reason: Minor bump for new capability (binSize/binUnit support)
Breaking: No longer accepts binMinutes format
```

**FlowTime-Sim**:
```
Current: 0.3.1
After M2.9: 0.4.0
Reason: Minor bump for output format change
Breaking: Outputs binSize/binUnit instead of binMinutes
```

### Coordinated Release

**Release Sequence**:
1. Merge M2.9 changes to both repos
2. Release **Engine 0.5.0 FIRST**
3. Release **Sim 0.4.0 SECOND** (requires Engine 0.5.0)
4. Update documentation simultaneously
5. Announce breaking change with migration guide

**Compatibility Matrix**:
```
Engine 0.4.x + Sim 0.3.x = ✅ Works (old format)
Engine 0.5.0 + Sim 0.3.x = ❌ Broken (format mismatch)
Engine 0.5.0 + Sim 0.4.0 = ✅ Works (new format)
```

**Justification**: Both systems are in development phase (0.x versions) where breaking changes are acceptable and expected. Single coordinated breaking change is better than two separate breaking changes later.

## Dependencies & Integration

**FlowTime-Sim Integration**: This milestone requires coordinated changes across both repos. Engine must be released first (0.5.0), then Sim can be updated (0.4.0) to output the new format.

**UI-M2.9 Parallel Work**: This milestone runs in parallel with UI-M2.9 (Template Schema Migration). The UI milestone focuses on template form updates and UI integration, while M2.9 handles the core engine evolution.

**Charter Independence**: This milestone is independent of charter workflow decisions and provides foundational schema improvements regardless of UI paradigm choices.

**Documentation References**:
- **Target Schema**: `docs/schemas/target-model-schema.md` - Complete unified schema specification
- **Analysis**: `docs/schemas/M2.9-ANALYSIS.md` - Detailed comparison and recommendations
- **Migration Guide**: `docs/migrations/m2.9-schema-evolution.md` - User migration instructions (to be created)

---

*This milestone was reorganized from Compare Workflow to focus on schema evolution priorities. Compare functionality has been deferred.*
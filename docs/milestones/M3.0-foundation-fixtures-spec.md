# M3.0: Foundation + Fixtures - Implementation Specification

**Milestone:** M3.0  
**Status:** Planning Complete, Ready to Implement

---

## Executive Summary

### Objective
Extend FlowTime engine with **absolute time (Window)**, **topology**, and **initial conditions** support. Implement **file-based telemetry sources** (CSV). Create **3 fixture systems** for testing time-travel APIs.

### Success Criteria
- âœ… Window with start timestamp (absolute time)
- âœ… Topology with nodes, edges, semantics
- âœ… File sources load CSVs correctly
- âœ… Initial condition enforcement
- âœ… 3 working fixture systems
- âœ… 40+ tests passing (20 unit + 12 integration + 8 golden)
- âœ… Backward compatibility maintained (existing M2.10 tests pass)

### Dependencies
- **Before M3.0:** M2.10 complete (current state)
- **After M3.0:** M3.1 can begin (/state APIs)
- **Parallel work:** None (blocking for all time-travel features)

---

## Architecture Overview

### New Concepts

#### 1. Window (Absolute Time)
**Purpose:** Convert relative bin indices to absolute timestamps.

**Schema Extension:**
```yaml
window:
  bins: 288              # Existing (required)
  binSize: 5             # Existing (required)
  binUnit: minutes       # Existing (required)
  startTime: "2025-10-07T00:00:00Z"  # NEW (optional)
```

**Behavior:**
- If `startTime` present â†’ absolute time model
- If `startTime` absent â†’ relative time model (backward compatible)
- `startTime` must be UTC ISO 8601 format
- Bin timestamps computed: `startTime + (binIndex * binSize * binUnit)`

#### 2. Topology (Nodes + Edges + Semantics)
**Purpose:** Define system structure and data sources for nodes.

**Schema Extension:**
```yaml
topology:
  nodes:
    - id: "OrderService"
      semantics:
        arrivals: "file:fixtures/order_arrivals.csv"
        served: "file:fixtures/order_served.csv"
        errors: "file:fixtures/order_errors.csv"
    
    - id: "PaymentService"
      semantics:
        arrivals: "file:fixtures/payment_arrivals.csv"
        served: "file:fixtures/payment_served.csv"
        errors: "file:fixtures/payment_errors.csv"
  
  edges:
    - source: "OrderService"
      target: "PaymentService"
      weight: 1.0
```

**Semantics:**
- **arrivals:** Work entering node (required)
- **served:** Work completed (required)
- **errors:** Failed attempts (required)
- **external_demand:** Upstream demand (optional)
- **queue_depth:** Backlog (optional)

**Node Definition:**
- `id`: Unique node identifier (string)
- `semantics`: Map of semantic â†’ source URI

**Edge Definition:**
- `source`: Source node ID
- `target`: Target node ID
- `weight`: Edge weight (float, default 1.0)

#### 3. File Sources (CSV Telemetry)
**Purpose:** Load time-series data from CSV files.

**CSV Format:**
```csv
bin_index,value
0,120
1,145
2,130
...
```

**Schema:**
- `bin_index`: Integer (0-based)
- `value`: Float or integer
- Header row required
- Sparse allowed (missing bins = 0)

**URI Format:**
```
file:<path>
```

**Resolution:**
- Relative paths â†’ relative to model YAML directory
- Absolute paths â†’ used as-is
- Example: `file:fixtures/arrivals.csv` â†’ `{model_dir}/fixtures/arrivals.csv`

#### 4. Initial Conditions
**Purpose:** Enforce conservation law at bin 0.

**Model Extension:**
```yaml
nodes:
  - id: "queue_depth"
    kind: expr
    expr: "MAX(0, SHIFT(queue_depth, 1) + inflow - outflow)"
    initial: "{{initial_queue_depth}}"  # Orders in queue at bin 0
```

**Validation:**
- `initial` lives on the series definition; topology remains structural wiring only
- Self-referencing `SHIFT` without `initial` still raises a parser error (see KISS P4)
- Templates should expose parameters (e.g., `initial_queue_depth`) so fixtures can configure starting state

---

## Implementation Plan

### Phase 1: Schema Extensions
**Scope:** Window with StartTime, Topology models, Model integration

#### Task 1.1: Window with StartTime
**Files:**
- `src/FlowTime.Core/Models/Window.cs` (modify)
- `src/FlowTime.Core/Parsing/ModelParser.cs` (modify)
- `tests/FlowTime.Core.Tests/Models/WindowTests.cs` (new)

**Implementation:**
```csharp
// Window.cs
public sealed record Window
{
    public required int Bins { get; init; }
    public required int BinSize { get; init; }
    public required TimeUnit BinUnit { get; init; }
    public DateTime? StartTime { get; init; }  // NEW
    
    public TimeSpan BinDuration => BinUnit switch
    {
        TimeUnit.Minutes => TimeSpan.FromMinutes(BinSize),
        TimeUnit.Hours => TimeSpan.FromHours(BinSize),
        TimeUnit.Days => TimeSpan.FromDays(BinSize),
        _ => throw new InvalidOperationException($"Unsupported bin unit: {BinUnit}")
    };
    
    public DateTime? GetBinStartTime(int binIndex)  // NEW
    {
        if (StartTime == null) return null;
        if (binIndex < 0 || binIndex >= Bins)
            throw new ArgumentOutOfRangeException(nameof(binIndex));
        
        return StartTime.Value.Add(BinDuration * binIndex);
    }
}
```

**Tests:**
```csharp
// WindowTests.cs
[Fact]
public void GetBinStartTime_WithStartTime_ReturnsCorrectTimestamp()
{
    var window = new Window
    {
        Bins = 288,
        BinSize = 5,
        BinUnit = TimeUnit.Minutes,
        StartTime = new DateTime(2025, 10, 7, 0, 0, 0, DateTimeKind.Utc)
    };
    
    var bin0 = window.GetBinStartTime(0);
    var bin1 = window.GetBinStartTime(1);
    var bin287 = window.GetBinStartTime(287);
    
    Assert.Equal(new DateTime(2025, 10, 7, 0, 0, 0, DateTimeKind.Utc), bin0);
    Assert.Equal(new DateTime(2025, 10, 7, 0, 5, 0, DateTimeKind.Utc), bin1);
    Assert.Equal(new DateTime(2025, 10, 7, 23, 55, 0, DateTimeKind.Utc), bin287);
}

[Fact]
public void GetBinStartTime_WithoutStartTime_ReturnsNull()
{
    var window = new Window
    {
        Bins = 288,
        BinSize = 5,
        BinUnit = TimeUnit.Minutes,
        StartTime = null
    };
    
    var result = window.GetBinStartTime(0);
    
    Assert.Null(result);
}
```

**Acceptance Criteria:**
- âœ… Window.StartTime property exists
- âœ… GetBinStartTime() returns correct timestamps
- âœ… GetBinStartTime() returns null if StartTime not set
- âœ… GetBinStartTime() throws for invalid binIndex
- âœ… Backward compatible (existing tests pass)

---

#### Task 1.2: Topology Models
**Files:**
- `src/FlowTime.Core/Models/Topology.cs` (new)
- `src/FlowTime.Core/Models/Node.cs` (new)
- `src/FlowTime.Core/Models/Edge.cs` (new)
- `src/FlowTime.Core/Models/Semantics.cs` (new)
- `tests/FlowTime.Core.Tests/Models/TopologyTests.cs` (new)

**Implementation:**
```csharp
// Topology.cs
public sealed record Topology
{
    public required IReadOnlyList<Node> Nodes { get; init; }
    public required IReadOnlyList<Edge> Edges { get; init; }
    
    public Node GetNode(string nodeId)
    {
        var node = Nodes.FirstOrDefault(n => n.Id == nodeId);
        if (node == null)
            throw new InvalidOperationException($"Node not found: {nodeId}");
        return node;
    }
    
    public IEnumerable<Edge> GetOutgoingEdges(string nodeId)
    {
        return Edges.Where(e => e.Source == nodeId);
    }
    
    public IEnumerable<Edge> GetIncomingEdges(string nodeId)
    {
        return Edges.Where(e => e.Target == nodeId);
    }
}

// Node.cs
public sealed record Node
{
    public required string Id { get; init; }
    public required NodeSemantics Semantics { get; init; }
    public InitialCondition? InitialCondition { get; init; }
}

// NodeSemantics.cs
public sealed record NodeSemantics
{
    public required string Arrivals { get; init; }      // URI
    public required string Served { get; init; }        // URI
    public required string Errors { get; init; }        // URI
    public string? ExternalDemand { get; init; }        // URI (optional)
    public string? QueueDepth { get; init; }            // URI (optional)
}

// InitialCondition.cs
public sealed record InitialCondition
{
    public double QueueDepth { get; init; }
}

// Edge.cs
public sealed record Edge
{
    public required string Source { get; init; }
    public required string Target { get; init; }
    public double Weight { get; init; } = 1.0;
}
```

**Tests:**
```csharp
// TopologyTests.cs
[Fact]
public void GetNode_ExistingNode_ReturnsNode()
{
    var topology = new Topology
    {
        Nodes = new[]
        {
            new Node { Id = "A", Semantics = CreateSemantics() },
            new Node { Id = "B", Semantics = CreateSemantics() }
        },
        Edges = Array.Empty<Edge>()
    };
    
    var node = topology.GetNode("A");
    
    Assert.Equal("A", node.Id);
}

[Fact]
public void GetOutgoingEdges_ReturnsCorrectEdges()
{
    var topology = new Topology
    {
        Nodes = new[]
        {
            new Node { Id = "A", Semantics = CreateSemantics() },
            new Node { Id = "B", Semantics = CreateSemantics() }
        },
        Edges = new[]
        {
            new Edge { Source = "A", Target = "B", Weight = 1.0 },
            new Edge { Source = "B", Target = "A", Weight = 0.5 }
        }
    };
    
    var outgoing = topology.GetOutgoingEdges("A").ToList();
    
    Assert.Single(outgoing);
    Assert.Equal("B", outgoing[0].Target);
}
```

**Acceptance Criteria:**
- âœ… Topology, Node, Edge, NodeSemantics records exist
- âœ… GetNode() returns correct node
- âœ… GetOutgoingEdges() returns correct edges
- âœ… GetIncomingEdges() returns correct edges
- âœ… InitialCondition optional

---

#### Task 1.3: Model Schema Integration
**Files:**
- `src/FlowTime.Core/Models/Model.cs` (modify)
- `src/FlowTime.Core/Parsing/ModelParser.cs` (modify)

**Implementation:**
```csharp
// Model.cs
public sealed record Model
{
    public required Window Window { get; init; }
    public required IReadOnlyList<Variable> Variables { get; init; }
    public required IReadOnlyList<Constraint> Constraints { get; init; }
    public Topology? Topology { get; init; }  // NEW (optional)
}
```

**Parser Update:**
```csharp
// ModelParser.cs
public static Model Parse(string yaml, string? modelDirectory = null)
{
    var deserializer = new DeserializerBuilder()
        .WithNamingConvention(CamelCaseNamingConvention.Instance)
        .Build();
    
    var root = deserializer.Deserialize<ModelRoot>(yaml);
    
    return new Model
    {
        Window = ParseWindow(root.Window),
        Variables = ParseVariables(root.Variables),
        Constraints = ParseConstraints(root.Constraints),
        Topology = root.Topology != null ? ParseTopology(root.Topology, modelDirectory) : null
    };
}

private static Topology ParseTopology(TopologyRoot root, string? modelDirectory)
{
    return new Topology
    {
        Nodes = root.Nodes.Select(n => ParseNode(n, modelDirectory)).ToList(),
        Edges = root.Edges?.Select(ParseEdge).ToList() ?? new List<Edge>()
    };
}
```

**Acceptance Criteria:**
- âœ… Model.Topology property exists (optional)
- âœ… Parser handles topology section
- âœ… Parser handles missing topology (backward compatible)

---

### Phase 2: File Sources
**Scope:** CSV reader, URI resolution, Semantic loader

#### Task 2.1: CSV File Reader
**Files:**
- `src/FlowTime.Core/DataSources/FileSource.cs` (new)
- `src/FlowTime.Core/DataSources/CsvReader.cs` (new)
- `tests/FlowTime.Core.Tests/DataSources/CsvReaderTests.cs` (new)

**Implementation:**
```csharp
// CsvReader.cs
public sealed class CsvReader
{
    public static double[] ReadTimeSeries(string filePath, int expectedBins)
    {
        if (!File.Exists(filePath))
            throw new FileNotFoundException($"CSV file not found: {filePath}");
        
        var data = new double[expectedBins];
        
        using var reader = new StreamReader(filePath);
        
        // Skip header
        var header = reader.ReadLine();
        if (header == null || !header.Contains("bin_index"))
            throw new InvalidDataException($"Invalid CSV header: {filePath}");
        
        while (!reader.EndOfStream)
        {
            var line = reader.ReadLine();
            if (string.IsNullOrWhiteSpace(line)) continue;
            
            var parts = line.Split(',');
            if (parts.Length != 2)
                throw new InvalidDataException($"Invalid CSV row: {line}");
            
            var binIndex = int.Parse(parts[0], CultureInfo.InvariantCulture);
            var value = double.Parse(parts[1], CultureInfo.InvariantCulture);
            
            if (binIndex < 0 || binIndex >= expectedBins)
                throw new InvalidDataException($"Bin index out of range: {binIndex}");
            
            data[binIndex] = value;
        }
        
        return data;
    }
}
```

**Tests:**
```csharp
// CsvReaderTests.cs
[Fact]
public void ReadTimeSeries_ValidCsv_ReturnsCorrectData()
{
    var csv = """
        bin_index,value
        0,100
        1,150
        2,200
        """;
    
    var tempFile = Path.GetTempFileName();
    File.WriteAllText(tempFile, csv);
    
    try
    {
        var data = CsvReader.ReadTimeSeries(tempFile, 288);
        
        Assert.Equal(100, data[0]);
        Assert.Equal(150, data[1]);
        Assert.Equal(200, data[2]);
        Assert.Equal(0, data[3]); // Sparse (missing bins = 0)
    }
    finally
    {
        File.Delete(tempFile);
    }
}

[Fact]
public void ReadTimeSeries_MissingFile_ThrowsFileNotFoundException()
{
    Assert.Throws<FileNotFoundException>(() =>
        CsvReader.ReadTimeSeries("nonexistent.csv", 288));
}
```

**Acceptance Criteria:**
- âœ… Reads CSV with bin_index,value format
- âœ… Handles sparse data (missing bins = 0)
- âœ… Throws on invalid format
- âœ… Throws on missing file
- âœ… Uses InvariantCulture for parsing

---

#### Task 2.2: URI Resolution
**Files:**
- `src/FlowTime.Core/DataSources/UriResolver.cs` (new)
- `tests/FlowTime.Core.Tests/DataSources/UriResolverTests.cs` (new)

**Implementation:**
```csharp
// UriResolver.cs
public static class UriResolver
{
    public static string ResolveFilePath(string uri, string? modelDirectory)
    {
        if (!uri.StartsWith("file:", StringComparison.OrdinalIgnoreCase))
            throw new NotSupportedException($"Unsupported URI scheme: {uri}");
        
        var path = uri.Substring(5); // Remove "file:" prefix
        
        if (Path.IsPathRooted(path))
            return path;
        
        if (string.IsNullOrEmpty(modelDirectory))
            throw new InvalidOperationException("Relative path requires model directory");
        
        return Path.Combine(modelDirectory, path);
    }
}
```

**Tests:**
```csharp
// UriResolverTests.cs
[Fact]
public void ResolveFilePath_RelativePath_ReturnsAbsolutePath()
{
    var uri = "file:fixtures/arrivals.csv";
    var modelDir = "/path/to/model";
    
    var resolved = UriResolver.ResolveFilePath(uri, modelDir);
    
    Assert.Equal("/path/to/model/fixtures/arrivals.csv", resolved);
}

[Fact]
public void ResolveFilePath_AbsolutePath_ReturnsAsIs()
{
    var uri = "file:/absolute/path/arrivals.csv";
    
    var resolved = UriResolver.ResolveFilePath(uri, null);
    
    Assert.Equal("/absolute/path/arrivals.csv", resolved);
}
```

**Acceptance Criteria:**
- âœ… Resolves relative paths
- âœ… Handles absolute paths
- âœ… Throws on unsupported schemes
- âœ… Throws on relative path without model directory

---

#### Task 2.3: Semantic Data Loader
**Files:**
- `src/FlowTime.Core/DataSources/SemanticLoader.cs` (new)
- `tests/FlowTime.Core.Tests/DataSources/SemanticLoaderTests.cs` (new)

**Implementation:**
```csharp
// SemanticLoader.cs
public sealed class SemanticLoader
{
    private readonly string? modelDirectory;
    
    public SemanticLoader(string? modelDirectory)
    {
        this.modelDirectory = modelDirectory;
    }
    
    public NodeData LoadNodeData(Node node, int bins)
    {
        var arrivals = LoadTimeSeries(node.Semantics.Arrivals, bins);
        var served = LoadTimeSeries(node.Semantics.Served, bins);
        var errors = LoadTimeSeries(node.Semantics.Errors, bins);
        
        double[]? externalDemand = node.Semantics.ExternalDemand != null
            ? LoadTimeSeries(node.Semantics.ExternalDemand, bins)
            : null;
        
        double[]? queueDepth = node.Semantics.QueueDepth != null
            ? LoadTimeSeries(node.Semantics.QueueDepth, bins)
            : null;
        
        return new NodeData
        {
            NodeId = node.Id,
            Arrivals = arrivals,
            Served = served,
            Errors = errors,
            ExternalDemand = externalDemand,
            QueueDepth = queueDepth
        };
    }
    
    private double[] LoadTimeSeries(string uri, int bins)
    {
        var filePath = UriResolver.ResolveFilePath(uri, modelDirectory);
        return CsvReader.ReadTimeSeries(filePath, bins);
    }
}

// NodeData.cs
public sealed class NodeData
{
    public required string NodeId { get; init; }
    public required double[] Arrivals { get; init; }
    public required double[] Served { get; init; }
    public required double[] Errors { get; init; }
    public double[]? ExternalDemand { get; init; }
    public double[]? QueueDepth { get; init; }
}
```

**Acceptance Criteria:**
- âœ… Loads all required semantics (arrivals, served, errors)
- âœ… Loads optional semantics (external_demand, queue_depth)
- âœ… Returns NodeData structure
- âœ… Handles missing optional semantics

---

### Phase 3: Initial Conditions
**Scope:** Conservation law validator at bin 0

#### Task 3.1: Initial Condition Validator
**Files:**
- `src/FlowTime.Core/Validation/InitialConditionValidator.cs` (new)
- `tests/FlowTime.Core.Tests/Validation/InitialConditionValidatorTests.cs` (new)

**Implementation:**
```csharp
// InitialConditionValidator.cs
public sealed class InitialConditionValidator
{
    public void Validate(NodeData nodeData, InitialCondition? initialCondition)
    {
        var expectedQueueDepth = initialCondition?.QueueDepth ?? 0.0;
        
        // Conservation at bin 0:
        // queueDepth[0] = initialQueueDepth + arrivals[0] - served[0] - errors[0]
        var arrivals = nodeData.Arrivals[0];
        var served = nodeData.Served[0];
        var errors = nodeData.Errors[0];
        
        var computedQueueDepth = expectedQueueDepth + arrivals - served - errors;
        
        // If queue_depth provided, validate
        if (nodeData.QueueDepth != null)
        {
            var actualQueueDepth = nodeData.QueueDepth[0];
            
            if (Math.Abs(actualQueueDepth - computedQueueDepth) > 0.01)
            {
                throw new InvalidOperationException(
                    $"Initial condition violation for node {nodeData.NodeId}: " +
                    $"expected queue_depth[0] = {computedQueueDepth:F2}, " +
                    $"but got {actualQueueDepth:F2}");
            }
        }
    }
}
```

**Tests:**
```csharp
// InitialConditionValidatorTests.cs
[Fact]
public void Validate_ValidInitialCondition_DoesNotThrow()
{
    var nodeData = new NodeData
    {
        NodeId = "OrderService",
        Arrivals = new[] { 100.0 },
        Served = new[] { 80.0 },
        Errors = new[] { 5.0 },
        QueueDepth = new[] { 65.0 }
    };
    
    var initialCondition = new InitialCondition { QueueDepth = 50.0 };
    
    var validator = new InitialConditionValidator();
    validator.Validate(nodeData, initialCondition);
    
    // No exception = success
}

[Fact]
public void Validate_InvalidInitialCondition_Throws()
{
    var nodeData = new NodeData
    {
        NodeId = "OrderService",
        Arrivals = new[] { 100.0 },
        Served = new[] { 80.0 },
        Errors = new[] { 5.0 },
        QueueDepth = new[] { 100.0 } // Wrong!
    };
    
    var initialCondition = new InitialCondition { QueueDepth = 50.0 };
    
    var validator = new InitialConditionValidator();
    
    Assert.Throws<InvalidOperationException>(() =>
        validator.Validate(nodeData, initialCondition));
}
```

**Acceptance Criteria:**
- âœ… Validates conservation at bin 0
- âœ… Throws on violation
- âœ… Handles missing initial condition (assumes 0)
- âœ… Handles missing queue_depth (no validation)

---

### Phase 4: Fixtures
**Scope:** Order system, microservices, HTTP service fixtures with tests

#### Task 4.1: Order System Fixture
**Files:**
- `fixtures/order-system/model.yaml` (new)
- `fixtures/order-system/OrderService_arrivals.csv` (new)
- `fixtures/order-system/OrderService_served.csv` (new)
- `fixtures/order-system/OrderService_errors.csv` (new)
- `fixtures/order-system/PaymentService_arrivals.csv` (new)
- `fixtures/order-system/PaymentService_served.csv` (new)
- `fixtures/order-system/PaymentService_errors.csv` (new)
- `tests/FlowTime.Core.Tests/Fixtures/OrderSystemFixtureTests.cs` (new)

**Model:**
```yaml
# fixtures/order-system/model.yaml
window:
  bins: 288
  binSize: 5
  binUnit: minutes
  startTime: "2025-10-07T00:00:00Z"

topology:
  nodes:
    - id: "OrderService"
      semantics:
        arrivals: "file:OrderService_arrivals.csv"
        served: "file:OrderService_served.csv"
        errors: "file:OrderService_errors.csv"
      initialCondition:
        queueDepth: 20
    
    - id: "PaymentService"
      semantics:
        arrivals: "file:PaymentService_arrivals.csv"
        served: "file:PaymentService_served.csv"
        errors: "file:PaymentService_errors.csv"
      initialCondition:
        queueDepth: 10
  
  edges:
    - source: "OrderService"
      target: "PaymentService"
      weight: 0.8

variables:
  - name: "order_capacity"
    expression: "100"
  
  - name: "payment_capacity"
    expression: "80"

constraints:
  - expression: "order_capacity >= 50"
    message: "Order capacity too low"
```

**CSV Data (Example):**
```csv
# OrderService_arrivals.csv
bin_index,value
0,120
1,145
2,130
3,150
4,135
...
```

**Tests:**
```csharp
// OrderSystemFixtureTests.cs
[Fact]
public void OrderSystemFixture_LoadsSuccessfully()
{
    var modelPath = "fixtures/order-system/model.yaml";
    var modelDir = Path.GetDirectoryName(modelPath);
    var yaml = File.ReadAllText(modelPath);
    
    var model = ModelParser.Parse(yaml, modelDir);
    
    Assert.NotNull(model.Topology);
    Assert.Equal(2, model.Topology.Nodes.Count);
    Assert.Single(model.Topology.Edges);
}

[Fact]
public void OrderSystemFixture_LoadsNodeData()
{
    var modelPath = "fixtures/order-system/model.yaml";
    var modelDir = Path.GetDirectoryName(modelPath);
    var yaml = File.ReadAllText(modelPath);
    
    var model = ModelParser.Parse(yaml, modelDir);
    var loader = new SemanticLoader(modelDir);
    
    var orderNode = model.Topology!.GetNode("OrderService");
    var orderData = loader.LoadNodeData(orderNode, model.Window.Bins);
    
    Assert.Equal("OrderService", orderData.NodeId);
    Assert.Equal(288, orderData.Arrivals.Length);
    Assert.True(orderData.Arrivals[0] > 0); // Has data
}
```

**Acceptance Criteria:**
- âœ… Model YAML parses correctly
- âœ… CSV files load correctly
- âœ… Topology has 2 nodes, 1 edge
- âœ… Initial conditions present
- âœ… Tests pass

---

#### Task 4.2: Microservices Fixture
**Files:**
- `fixtures/microservices/model.yaml` (new)
- `fixtures/microservices/*.csv` (6 files: API_Gateway, Auth, Order, Payment, Inventory, Shipping)
- `tests/FlowTime.Core.Tests/Fixtures/MicroservicesFixtureTests.cs` (new)

**Model:**
```yaml
# fixtures/microservices/model.yaml
window:
  bins: 144
  binSize: 10
  binUnit: minutes
  startTime: "2025-10-07T00:00:00Z"

topology:
  nodes:
    - id: "API_Gateway"
      semantics:
        arrivals: "file:API_Gateway_arrivals.csv"
        served: "file:API_Gateway_served.csv"
        errors: "file:API_Gateway_errors.csv"
    
    - id: "AuthService"
      semantics:
        arrivals: "file:AuthService_arrivals.csv"
        served: "file:AuthService_served.csv"
        errors: "file:AuthService_errors.csv"
    
    - id: "OrderService"
      semantics:
        arrivals: "file:OrderService_arrivals.csv"
        served: "file:OrderService_served.csv"
        errors: "file:OrderService_errors.csv"
    
    - id: "PaymentService"
      semantics:
        arrivals: "file:PaymentService_arrivals.csv"
        served: "file:PaymentService_served.csv"
        errors: "file:PaymentService_errors.csv"
    
    - id: "InventoryService"
      semantics:
        arrivals: "file:InventoryService_arrivals.csv"
        served: "file:InventoryService_served.csv"
        errors: "file:InventoryService_errors.csv"
    
    - id: "ShippingService"
      semantics:
        arrivals: "file:ShippingService_arrivals.csv"
        served: "file:ShippingService_served.csv"
        errors: "file:ShippingService_errors.csv"
  
  edges:
    - source: "API_Gateway"
      target: "AuthService"
      weight: 1.0
    
    - source: "API_Gateway"
      target: "OrderService"
      weight: 0.7
    
    - source: "OrderService"
      target: "PaymentService"
      weight: 0.9
    
    - source: "OrderService"
      target: "InventoryService"
      weight: 1.0
    
    - source: "OrderService"
      target: "ShippingService"
      weight: 0.6

variables:
  - name: "gateway_capacity"
    expression: "500"

constraints:
  - expression: "gateway_capacity >= 200"
    message: "Gateway capacity too low"
```

**Acceptance Criteria:**
- âœ… Model YAML parses correctly
- âœ… 6 nodes, 5 edges
- âœ… CSV files load correctly
- âœ… Tests pass

---

#### Task 4.3: HTTP Service Fixture
**Files:**
- `fixtures/http-service/model.yaml` (new)
- `fixtures/http-service/*.csv` (3 files: arrivals, served, errors)
- `tests/FlowTime.Core.Tests/Fixtures/HttpServiceFixtureTests.cs` (new)

**Model:**
```yaml
# fixtures/http-service/model.yaml
window:
  bins: 96
  binSize: 15
  binUnit: minutes
  startTime: "2025-10-07T00:00:00Z"

topology:
  nodes:
    - id: "HttpService"
      semantics:
        arrivals: "file:HttpService_arrivals.csv"
        served: "file:HttpService_served.csv"
        errors: "file:HttpService_errors.csv"
      initialCondition:
        queueDepth: 0
  
  edges: []

variables:
  - name: "http_capacity"
    expression: "200"

constraints:
  - expression: "http_capacity >= 100"
    message: "HTTP capacity too low"
```

**Acceptance Criteria:**
- âœ… Model YAML parses correctly
- âœ… Single node, no edges
- âœ… CSV files load correctly
- âœ… Tests pass

---

### Phase 5: Integration Tests
**Scope:** End-to-end tests with fixtures, backward compatibility validation

#### Task 5.1: End-to-End Tests
**Files:**
- `tests/FlowTime.Core.Tests/Integration/TimeGridWithFileSourcesTests.cs` (new)

**Tests:**
```csharp
// TimeGridWithFileSourcesTests.cs
[Fact]
public void TimeGrid_WithFileSources_EvaluatesCorrectly()
{
    var modelPath = "fixtures/order-system/model.yaml";
    var modelDir = Path.GetDirectoryName(modelPath);
    var yaml = File.ReadAllText(modelPath);
    
    var model = ModelParser.Parse(yaml, modelDir);
    var loader = new SemanticLoader(modelDir);
    
    // Load node data
    var orderNode = model.Topology!.GetNode("OrderService");
    var orderData = loader.LoadNodeData(orderNode, model.Window.Bins);
    
    // Validate initial condition
    var validator = new InitialConditionValidator();
    validator.Validate(orderData, orderNode.InitialCondition);
    
    // Create time grid
    var grid = new TimeGrid(model.Window.Bins);
    
    // Populate with telemetry (M3.1 will use this data)
    // For now, just verify structure
    Assert.Equal(288, grid.BinCount);
}

[Fact]
public void TimeGrid_WithAbsoluteTime_ComputesCorrectTimestamps()
{
    var modelPath = "fixtures/order-system/model.yaml";
    var yaml = File.ReadAllText(modelPath);
    
    var model = ModelParser.Parse(yaml, Path.GetDirectoryName(modelPath));
    
    Assert.NotNull(model.Window.StartTime);
    
    var bin0 = model.Window.GetBinStartTime(0);
    var bin1 = model.Window.GetBinStartTime(1);
    
    Assert.Equal(new DateTime(2025, 10, 7, 0, 0, 0, DateTimeKind.Utc), bin0);
    Assert.Equal(new DateTime(2025, 10, 7, 0, 5, 0, DateTimeKind.Utc), bin1);
}
```

**Acceptance Criteria:**
- âœ… End-to-end loading works
- âœ… Initial condition validation works
- âœ… Absolute time computation works
- âœ… All fixtures load successfully

---

## Test Coverage Summary

### Unit Tests (20 tests)
- WindowTests: 5 tests
- TopologyTests: 5 tests
- CsvReaderTests: 4 tests
- UriResolverTests: 3 tests
- InitialConditionValidatorTests: 3 tests

### Integration Tests (12 tests)
- OrderSystemFixtureTests: 4 tests
- MicroservicesFixtureTests: 4 tests
- HttpServiceFixtureTests: 4 tests

### Golden Tests (8 tests)
- TimeGridWithFileSourcesTests: 4 tests
- BackwardCompatibilityTests: 4 tests (existing M2.10 models still work)

**Total:** 40 tests

---

## Backward Compatibility

### Requirement
All existing M2.10 tests (390/393) must continue to pass.

### Strategy
1. **Window.StartTime is optional** â†’ Existing models without startTime work
2. **Model.Topology is optional** â†’ Existing models without topology work
3. **No changes to existing APIs** â†’ Engine evaluation unchanged
4. **Additive only** â†’ No breaking changes

### Validation
```bash
dotnet test --filter "Category!=M3.0"
# Expected: 390/393 pass (same as M2.10)
```

---

## Files Created/Modified

### New Files (34 files)
**Core Models (7):**
- `src/FlowTime.Core/Models/Topology.cs`
- `src/FlowTime.Core/Models/Node.cs`
- `src/FlowTime.Core/Models/Edge.cs`
- `src/FlowTime.Core/Models/NodeSemantics.cs`
- `src/FlowTime.Core/Models/InitialCondition.cs`
- `src/FlowTime.Core/Models/NodeData.cs`

**Data Sources (4):**
- `src/FlowTime.Core/DataSources/FileSource.cs`
- `src/FlowTime.Core/DataSources/CsvReader.cs`
- `src/FlowTime.Core/DataSources/UriResolver.cs`
- `src/FlowTime.Core/DataSources/SemanticLoader.cs`

**Validation (1):**
- `src/FlowTime.Core/Validation/InitialConditionValidator.cs`

**Fixtures (19):**
- `fixtures/order-system/model.yaml`
- `fixtures/order-system/*.csv` (6 files)
- `fixtures/microservices/model.yaml`
- `fixtures/microservices/*.csv` (6 files)
- `fixtures/http-service/model.yaml`
- `fixtures/http-service/*.csv` (3 files)

**Tests (12):**
- `tests/FlowTime.Core.Tests/Models/WindowTests.cs`
- `tests/FlowTime.Core.Tests/Models/TopologyTests.cs`
- `tests/FlowTime.Core.Tests/DataSources/CsvReaderTests.cs`
- `tests/FlowTime.Core.Tests/DataSources/UriResolverTests.cs`
- `tests/FlowTime.Core.Tests/DataSources/SemanticLoaderTests.cs`
- `tests/FlowTime.Core.Tests/Validation/InitialConditionValidatorTests.cs`
- `tests/FlowTime.Core.Tests/Fixtures/OrderSystemFixtureTests.cs`
- `tests/FlowTime.Core.Tests/Fixtures/MicroservicesFixtureTests.cs`
- `tests/FlowTime.Core.Tests/Fixtures/HttpServiceFixtureTests.cs`
- `tests/FlowTime.Core.Tests/Integration/TimeGridWithFileSourcesTests.cs`

### Modified Files (3)
- `src/FlowTime.Core/Models/Window.cs` (add StartTime, GetBinStartTime)
- `src/FlowTime.Core/Models/Model.cs` (add Topology property)
- `src/FlowTime.Core/Parsing/ModelParser.cs` (parse topology)

---

## Acceptance Criteria

### Functional Requirements
- âœ… Window supports absolute time (StartTime property)
- âœ… GetBinStartTime() computes correct timestamps
- âœ… Topology with nodes, edges, semantics
- âœ… File sources load CSV correctly
- âœ… URI resolution works (relative + absolute paths)
- âœ… Initial condition validation enforces conservation
- âœ… 3 fixture systems load successfully

### Non-Functional Requirements
- âœ… Backward compatible (existing tests pass)
- âœ… 40+ tests passing (20 unit + 12 integration + 8 golden)
- âœ… 80%+ code coverage
- âœ… CSV loading performance: <100ms for 288 bins
- âœ… Memory efficient (no full file buffering)

### Documentation Requirements
- âœ… Schema extension documented
- âœ… File source format documented
- âœ… Fixture examples provided
- âœ… Tests serve as usage examples

---

## Risk Assessment

### High Risks
**None** (Foundation work, low complexity)

### Medium Risks
1. **CSV format variations**
   - Mitigation: Strict validation, clear error messages
   
2. **File path resolution edge cases**
   - Mitigation: Extensive tests for relative/absolute paths

3. **Backward compatibility break**
   - Mitigation: Run full test suite, all new fields optional

### Low Risks
1. **Performance issues**
   - Mitigation: Benchmark early, optimize if needed
   
2. **Test fixture data quality**
   - Mitigation: Generate fixtures from known-good simulations

---

## Dependencies

### Before M3.0
- âœ… M2.10 complete (390/393 tests passing)
- âœ… No breaking changes planned

### After M3.0
- â­ï¸ M3.1: /state APIs (depends on fixtures from M3.0)
- â­ï¸ M3.2: TelemetryLoader (depends on file sources from M3.0)
- â­ï¸ UI integration (depends on /state APIs from M3.1)

### Parallel Work
- âŒ None (blocking for all time-travel features)

---

## Implementation Sequence

### Phase 1: Schema Extensions
- Task 1.1: Window with StartTime
- Task 1.2: Topology Models
- Task 1.3: Model Schema Integration

### Phase 2: File Sources
- Task 2.1: CSV File Reader
- Task 2.2: URI Resolution
- Task 2.3: Semantic Data Loader

### Phase 3: Initial Conditions
- Task 3.1: Initial Condition Validator

### Phase 4: Fixtures
- Task 4.1: Order System Fixture
- Task 4.2: Microservices Fixture
- Task 4.3: HTTP Service Fixture

### Phase 5: Integration Tests
- Task 5.1: End-to-End Tests

---

## Success Metrics

### Code Metrics
- âœ… 34 new files
- âœ… 3 modified files
- âœ… ~1,500 new LOC (excluding fixtures)
- âœ… ~800 LOC tests

### Test Metrics
- âœ… 40+ tests passing
- âœ… 80%+ code coverage
- âœ… 390/393 backward compatibility tests pass

### Performance Metrics
- âœ… CSV load: <100ms for 288 bins
- âœ… Topology parse: <50ms
- âœ… Initial condition validation: <10ms

### Quality Metrics
- âœ… No compiler warnings
- âœ… No nullable reference warnings
- âœ… All tests green

---

## Next Steps After M3.0

### Immediate (M3.1)
1. Implement /state endpoints
2. Implement /state_window endpoints
3. Implement derived metrics (utilization, latency)
4. Implement node coloring

### Future (M3.2-M3.3)
1. TelemetryLoader with dense bin filling
2. Template parser with parameter substitution
3. Synthetic gold generator tool
4. Mode-based validation
5. Structured logging

---

## Notes

### Design Decisions
1. **Sparse CSV allowed** â†’ Missing bins default to 0 (simpler)
2. **URI scheme required** â†’ Future-proof for ADX, Service Bus
3. **Initial condition optional** â†’ Assumes queue starts empty
4. **Topology optional** â†’ Backward compatible
5. **StartTime optional** â†’ Backward compatible

### Implementation Notes
1. Use `InvariantCulture` for all parsing
2. Use `DateTimeKind.Utc` for all timestamps
3. Validate early (fail fast)
4. Stream CSV files (no full buffering)
5. Test with realistic fixture data

---

**End of M3.0 Specification**

Ready to implement! ðŸš€

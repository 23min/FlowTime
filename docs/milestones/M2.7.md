# M2.7

**Status:** âœ… Complete (v0.6.0)  
**Dependencies:** M2.6 (Export System)  
**Target:** Complete persistent artifacts system per FlowTime-Engine Charter  
**Completed:** 2025-09-23

---

## Goal

Implement the persistent artifacts registry as the **backbone of the charter UI workflow**. This milestone establishes the "never forget" principle where all models, runs, and telemetry become discoverable, searchable, and reusable artifacts with metadata. The registry serves as the foundation for the charter's Runs wizard and Compare functionality.

## Context & Charter Alignment

The **FlowTime-Engine Charter** defines artifacts registry as core infrastructure:
- **Run artifacts**: Every engine execution produces persistent telemetry + catalog
- **Model artifacts**: FlowTime-Sim generates reusable model definitions  
- **Telemetry artifacts**: External data import creates searchable catalog entries
- **UI flows**: Artifacts registry enables "Select Input" step in Runs wizard

This milestone transforms FlowTime from ephemeral execution to **persistent modeling platform**.

## Functional Requirements

### **FR-M2.7-1: File-Based Artifact Registry (KISS Implementation)**
Build registry on top of existing file-based artifact system with minimal changes and pluggable design.

**KISS Approach - Use Existing Structure:**
- **Build on `/data/` directory**: Already contains run artifacts with proper structure
- **Add registry index file**: Single JSON file `/data/registry-index.json` for fast lookup
- **File system scanning**: Discover artifacts by scanning existing directories  
- **No database dependency**: Pure file-based implementation for simplicity

**Current Structure (Already Working):**
```
/data/
â””â”€â”€ run_20250920T080707Z_5eccafbb/    # Existing run artifacts
    â”œâ”€â”€ manifest.json                  # âœ… Already has metadata
    â”œâ”€â”€ run.json                      # âœ… Already has run info  
    â”œâ”€â”€ spec.yaml                     # âœ… Already has model spec
    â”œâ”€â”€ series/index.json + *.csv     # âœ… Already has telemetry
    â””â”€â”€ gold/export.{csv,ndjson,parquet} # âœ… M2.6 export formats
```

**Registry Extension (Minimal Addition):**
```
/data/
â”œâ”€â”€ registry-index.json               # ðŸ†• Single index file for all artifacts
â”œâ”€â”€ run_*/                           # âœ… Existing run directories (no change)
â”œâ”€â”€ models/                          # ðŸ†• Future model artifacts (M3.0)
â”‚   â””â”€â”€ {model_id}/
â”‚       â”œâ”€â”€ model-artifact.yaml      # Model artifact (kind: Model)
â”‚       â””â”€â”€ metadata.json
â””â”€â”€ telemetry/                       # ðŸ†• Future imported telemetry
    â””â”€â”€ {telemetry_id}/
        â”œâ”€â”€ data.csv
        â””â”€â”€ metadata.json
        â”œâ”€â”€ data.{csv,parquet}
        â”œâ”€â”€ catalog.json
        â””â”€â”€ metadata.json
```

**Metadata Schema:**
```json
{
  "id": "artifact_id",
  "type": "run|model|telemetry", 
  "created": "2025-09-20T10:00:00Z",
  "title": "Human readable name",
  "description": "Optional description",
  "tags": ["baseline", "prod", "experiment"],
  "source": "engine|sim|import",
  "schema_version": "v1",
  "capabilities": ["replay", "compare", "export"],
  "relationships": {
    "derived_from": ["parent_artifact_id"],
    "generates": ["child_artifact_id"]
  }
}
```
### **FR-M2.7-2: Simple Registry API (Building on Existing)**
REST endpoints for artifact discovery using file-based registry with existing artifact structure.

**KISS Registry Endpoints:**
```bash
# List and search artifacts (reads registry-index.json)
GET /v1/artifacts                    # List all artifacts
GET /v1/artifacts?type=run           # Filter by type  
GET /v1/artifacts?tags=manufacturing # Filter by tags
GET /v1/artifacts?search=capacity    # Search title/description

# Artifact metadata (reads from existing run.json, manifest.json)  
GET /v1/artifacts/{id}              # Get artifact metadata + file list
GET /v1/artifacts/{id}/files        # List available files in artifact

# Artifact file access (serves from existing /data structure)
GET /v1/artifacts/{id}/files/{name} # Download file (CSV, YAML, etc.)

# Simple metadata updates (updates registry-index.json)
PUT /v1/artifacts/{id}              # Update title, description, tags
DELETE /v1/artifacts/{id}           # Mark as deleted (keeps files)

# Registry maintenance
POST /v1/artifacts/rescan           # Scan /data for new artifacts
GET /v1/artifacts/stats             # Registry statistics
POST /v1/artifacts/{id}/compare # Compare with another artifact
GET /v1/artifacts/{id}/files    # List artifact files
GET /v1/artifacts/{id}/files/{filename}  # Download artifact file
```

**Advanced Query Capabilities:**
- **Full-text search** across title, description, tags
- **Filter by type, date range, source, capabilities**
- **Sort by created, modified, title, size**
- **Pagination** with limit/offset
- **Related artifacts** traversal

### **FR-M2.7-3: Automatic Artifact Creation**
Engine runs, Sim model generation, and telemetry import automatically create registry entries.

**Engine Integration:**
- Every `POST /v1/run` creates a Run artifact automatically
- RunId becomes artifact ID for consistency
- Export operations (M2.6) are linked to Run artifacts
- Catalog.json generated with grid info, series metadata, capabilities

**FlowTime-Sim Integration:**
- Template instantiation creates Model artifacts
- Model artifacts reference template source and parameter values
- Catalog.json includes DAG structure, component metadata

**Import Integration:**
- CSV/Parquet upload creates Telemetry artifacts
- Schema validation ensures catalog compatibility
- Metadata extraction from file headers and structure

### **FR-M2.7-4: KISS File-Based Registry (M2.7 Implementation)**
Simple file-based registry that builds on existing artifact structure with pluggable design for future database migration.

**KISS Implementation Strategy:**
- **Single Registry Index**: `/data/registry-index.json` contains all artifact metadata
- **File System Scanning**: Auto-discover artifacts by scanning existing `/data/run_*` directories  
- **Existing Artifact Structure**: No changes to existing run artifacts, builds on top
- **Pluggable Interface**: Design allows easy database migration in future milestone

**Registry Index Structure:**
```json
// /data/registry-index.json
{
  "version": "1.0.0", 
  "updated": "2024-09-20T10:30:00Z",
  "artifacts": [
    {
      "id": "run_20250920T080707Z_5eccafbb",
      "type": "run", 
      "title": "Manufacturing Analysis Run",
      "description": "Production capacity analysis with seasonal demand",
      "created": "2024-09-20T08:07:07Z",
      "tags": ["manufacturing", "capacity"],
      "source": "flowtime-engine",
      "path": "run_20250920T080707Z_5eccafbb",
      "size_mb": 2.3,
      "series_count": 4,
      "metadata": {
        "model_hash": "abc123",
        "execution_time_ms": 1250,
        "grid_bins": 24
      }
    }
  ]
}
```

**Future Enhancement Path:**
- M2.7: File-based registry with pluggable `IArtifactStorage` interface
- M3.x: Database implementation of same interface (zero API changes)
- M4.x: Advanced database features for production scale

## Technical Architecture

### **KISS Registry Service (Pluggable Design)**

**Core Registry Interface** (designed for future database migration):
- **List Artifacts**: Query with filtering by type, tags, search terms, date ranges
- **Get Artifact**: Retrieve single artifact by ID with full metadata
- **Create/Update**: Artifact metadata management (title, description, tags)
- **Auto-Creation**: Automatic artifact creation from engine runs
- **File Access**: Stream artifact files (CSV, YAML, etc.) directly

**File-Based Implementation** (M2.7 KISS approach):
- **Registry Index Loading**: Read `/data/registry-index.json` into memory on startup  
- **Directory Scanning**: Discover new artifacts by scanning `/data/run_*` folders
- **Index Updates**: Append new artifacts to registry index, periodic cleanup/rebuild
- **Search/Filter**: In-memory filtering of registry index (fast for reasonable artifact counts)
- **File Serving**: Direct file system access to artifact directories

**Auto-Creation Workflow:**
1. Engine completes run â†’ artifacts written to `/data/run_*/`
2. Registry scans for new directories on next API call
3. Extract metadata from existing `manifest.json`, `run.json` files  
4. Add new artifact entry to registry index
5. Persist updated registry index
{
    Task<Artifact> CreateRunArtifactAsync(string runId, RunResult result);
    Task<Artifact> CreateModelArtifactAsync(string modelId, ModelDefinition model);
    Task<Artifact> CreateTelemetryArtifactAsync(string telemetryId, ImportedData data);
}
```

### **Storage Abstraction**
```csharp
public interface IArtifactStorage
{
    Task SaveArtifactAsync(string id, ArtifactFiles files);
    Task<Stream> ReadFileAsync(string id, string filename);
    Task<string[]> ListFilesAsync(string id);
    Task DeleteArtifactAsync(string id);
}

public class FileSystemArtifactStorage : IArtifactStorage
{
    // Implements file-based storage in /artifacts directory
}

public class BlobArtifactStorage : IArtifactStorage
{
    // Future: Azure Blob, S3, etc.
}
```

## Integration Points

### **M2.6 Export System Integration**
- Export operations automatically update Run artifact metadata
- Exported files become part of Run artifact file collection
- Export formats (CSV/NDJSON/Parquet) discoverable via artifacts API

### **Engine API Integration**
```csharp
// Modified engine endpoints to create artifacts
v1.MapPost("/run", async (HttpRequest req, IArtifactAutoCreator artifactCreator) =>
{
    // Existing run logic...
    var runResult = await ExecuteRun(model);
    
    // NEW: Automatically create Run artifact
    var artifact = await artifactCreator.CreateRunArtifactAsync(runResult.RunId, runResult);
    
    return Results.Ok(new { runId = runResult.RunId, artifactId = artifact.Id });
});
```

### **Future Charter UI Integration**
Artifacts registry enables the charter UI workflows:

**Runs Wizard - Step 1 (Select Input):**
```typescript
// Browse Model artifacts
const models = await artifactService.list({ type: 'model', tags: ['validated'] });

// Browse Telemetry artifacts  
const telemetry = await artifactService.list({ type: 'telemetry', capabilities: ['replay'] });
```

**Compare Workflow:**
```typescript
// Get baseline from current run
const baselineArtifact = await artifactService.get(currentRunId);

// Select comparison input from registry
const comparisonArtifacts = await artifactService.list({ type: 'run|telemetry' });
```

## Acceptance Criteria

### **Storage & Persistence**
- âœ… All engine runs create Run artifacts with metadata and catalog.json
- âœ… Artifacts persist across application restarts and redeployments  
- âœ… File storage handles concurrent access and cleanup correctly
- âœ… File-based registry enables sub-second artifact queries (< 500ms for 1000+ artifacts)

### **API Completeness**
- âœ… REST endpoints support all CRUD operations on artifacts
- âœ… Search and filtering return correct results with pagination
- âœ… File download endpoints serve artifact files with proper content types
- âœ… API responses include all metadata needed for UI rendering

### **Integration Validation**
- âœ… M2.6 export system creates discoverable artifact files
- âœ… Engine runs automatically appear in artifacts registry
- âœ… Artifact metadata enables charter UI workflows (input selection, compare)
- âœ… Registry survives service restarts without data loss

### **Performance & Scale**
- âœ… Registry handles 1000+ artifacts with responsive UI performance
- âœ… File operations support artifacts up to 100MB (typical telemetry size)
- âœ… Concurrent artifact creation doesn't cause data corruption
- âœ… File-based registry performance remains stable as registry grows

## KISS Implementation Plan

### **Phase 1: File-Based Registry**  
1. **Registry index structure** - Design `/data/registry-index.json` schema
2. **Directory scanner** - Discover existing artifacts in `/data/run_*` folders
3. **Registry service interface** - Pluggable design for future database migration
4. **Initial index creation** - Scan existing runs and create registry index

### **Phase 2: Simple API**
1. **Basic REST endpoints** - GET /v1/artifacts with filtering
2. **File serving** - Serve artifact files directly from filesystem  
3. **Metadata updates** - PUT endpoint to update artifact titles/tags
4. **Auto-discovery** - Detect new artifacts on API calls

### **Phase 3: Engine Integration**
1. **Run completion hook** - Add artifact to registry when engine finishes
2. **Metadata extraction** - Parse existing manifest.json, run.json for artifact info
3. **M2.6 export tracking** - Include export files in artifact file lists
4. **Registry index updates** - Append new artifacts efficiently  

### **Phase 4: Charter UI Preparation**
1. **Mock artifact data** - Generate sample registry for UI development
2. **API contracts** - Define response schemas for charter UI
3. **File download endpoints** - Enable artifact file access from UI
4. **Registry statistics** - Provide counts and summaries for dashboard

## Risk Mitigation

### **Data Migration Risk**
**Risk:** Existing runs in M2.6 format need registry integration  
**Mitigation:** 
- Build import tool to migrate existing `/data` directory runs
- Registry creation is additive - doesn't break existing functionality
- Gradual migration with backward compatibility

### **Performance Risk**  
**Risk:** Registry queries become slow with large artifact collections  
**Mitigation:**
- Database indexing strategy from day one
- Pagination limits prevent unbounded queries
- Caching layer for frequently accessed metadata

### **Storage Risk**
**Risk:** Artifact files consume significant disk space  
**Mitigation:**
- Configurable retention policies (delete old artifacts)
- File cleanup on artifact deletion
- Optional compression for large telemetry files

## Success Metrics

### **Functional Success**
- **100% artifact creation**: Every engine run produces discoverable artifact
- **Sub-second queries**: Registry search responds in < 500ms for typical queries
- **Zero data loss**: Registry survives restarts and failures without corruption
- **API completeness**: All charter UI workflows supported by registry endpoints

### **Charter Alignment Success**  
- **Input selection enabled**: Runs wizard can browse Model and Telemetry artifacts
- **Compare ready**: Artifact registry supports comparison workflow selection
- **Never forget**: No artifacts disappear - all runs, models, telemetry persistent
- **Future-proof**: Registry design supports M2.8 UI restructure requirements

---

## Next Steps

1. **M2.8 Registry Integration + UI-M2.8 Charter Navigation**: Backend integration and UI updates to support artifacts registry
2. **M2.9**: Implement charter Compare workflow using registry
3. **SIM-M3.0-CHARTER**: FlowTime-Sim charter alignment and Model artifact generation

This milestone establishes the **persistent backbone** that transforms FlowTime from ephemeral tool to professional modeling platform, directly enabling the charter's vision of persistent, discoverable, reusable artifacts.

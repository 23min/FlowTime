# M2.8

**Status:** ðŸ“‹ Planned (Charter-Aligned)  
**Dependencies:** M2.7 (Artifacts Registry)  
**Target:** Enhanced API integration with artifacts registry and service-level charter support  
**Date:** 2025-09-20

---

## Goal

Enhance the **artifacts registry system** with advanced querying capabilities, performance optimizations, and simple FlowTime-Sim integration. This milestone focuses on making the registry efficient and user-friendly for managing large numbers of artifacts while enabling basic cross-project workflows through shared artifact access.

**Note:** UI implementation for charter workflows is handled in dedicated UI-M* milestones (UI-M2.7, UI-M2.8, UI-M2.9, UI-M3.0).

## Context & Charter Alignment

The **FlowTime-Engine Charter** defines an artifacts-centric workflow that requires enhanced registry capabilities:
- **Registry Integration**: All models, runs, and results stored as discoverable artifacts
- **API Enhancement**: REST APIs support efficient artifact discovery and management
- **Performance**: Registry must handle growing artifact collections efficiently
- **Cross-Project Integration**: Simple artifact sharing with FlowTime-Sim

**Service-Level Focus:** This milestone enhances the registry foundation to support large-scale artifact management and basic cross-project workflows.

## Functional Requirements

### **FR-M2.8-1: Enhanced Artifacts Registry API**
Extend M2.7 artifacts registry with advanced querying, filtering, and performance optimizations.

**Enhanced Minimal API Endpoints:**
```csharp
// Enhanced artifacts endpoints in Program.cs (continuing FlowTime Minimal API pattern)
v1.MapGet("/artifacts", async (IArtifactRegistry registry, HttpContext context, ILogger<Program> logger) =>
{
    var query = context.Request.Query;
    var options = new EnhancedArtifactQueryOptions
    {
        // Existing options
        Type = query["type"].FirstOrDefault(),
        Search = query["search"].FirstOrDefault(),
        Tags = query["tags"].FirstOrDefault()?.Split(','),
        Skip = int.TryParse(query["skip"].FirstOrDefault(), out var skip) ? skip : 0,
        Limit = int.TryParse(query["limit"].FirstOrDefault(), out var limit) ? Math.Min(limit, 1000) : 50,
        SortBy = query["sortBy"].FirstOrDefault() ?? "created",
        SortOrder = query["sortOrder"].FirstOrDefault() ?? "desc",
        
        // New enhanced filtering options
        CreatedAfter = DateTime.TryParse(query["createdAfter"].FirstOrDefault(), out var after) ? after : null,
        CreatedBefore = DateTime.TryParse(query["createdBefore"].FirstOrDefault(), out var before) ? before : null,
        MinFileSize = long.TryParse(query["minSize"].FirstOrDefault(), out var minSize) ? minSize : null,
        MaxFileSize = long.TryParse(query["maxSize"].FirstOrDefault(), out var maxSize) ? maxSize : null,
        FullTextSearch = query["fullText"].FirstOrDefault(),
        RelatedToArtifact = query["relatedTo"].FirstOrDefault()
    };
    
    var response = await registry.GetArtifactsAsync(options);
    return Results.Ok(response);
});

v1.MapGet("/artifacts/{id}/relationships", async (string id, IArtifactRegistry registry) =>
{
    var relationships = await registry.GetArtifactRelationshipsAsync(id);
    return Results.Ok(relationships);
    }

    [HttpPost("{id}/actions")]
    public async Task<ActionResult<WorkflowActionResult>> ExecuteAction(
        string id, [FromBody] WorkflowActionRequest action)
    {
        var result = await _workflowService.ExecuteActionAsync(id, action);
        return Ok(result);
    }
}

// Enhanced Query Capabilities
public class ArtifactQueryRequest
{
    public string? SearchTerm { get; set; }
    public string[]? Types { get; set; }
    public string[]? Tags { get; set; }
    public DateTime? CreatedAfter { get; set; }
    public DateTime? CreatedBefore { get; set; }
    public ArtifactSortOrder SortBy { get; set; } = ArtifactSortOrder.Created;
    public SortDirection Direction { get; set; } = SortDirection.Descending;
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 20;
}
```

**Workflow Action Support:**
```csharp
public interface IWorkflowActionService
{
    Task<WorkflowActionResult> RunModelArtifactAsync(string artifactId, RunConfiguration config);
    Task<WorkflowActionResult> OpenRunResultsAsync(string artifactId);
    Task<WorkflowActionResult> StartComparisonAsync(string baselineId, string comparisonId);
    Task<WorkflowActionResult> ExportArtifactAsync(string artifactId, ExportFormat format);
}
```



### **FR-M2.8-3: FlowTime-Sim Integration**
Enable FlowTime-Sim to share artifacts with FlowTime-Engine through the shared registry.

**Integration Pattern:**
FlowTime-Sim writes model artifacts to the shared `/data/` directory, and FlowTime-Engine discovers them through the existing registry API.

```yaml
# FlowTime-Sim configuration example
integration:
  shared-data-dir: "/shared/data"
  artifact-types:
    - "simulation-model"
    - "simulation-result"
  registry-discovery: true
```

**Simple Cross-Project Workflow:**
1. **FlowTime-Sim** creates simulation model artifacts in shared data directory
2. **FlowTime-Engine** discovers models via `GET /v1/artifacts?type=simulation-model`
3. **FlowTime-Engine** can run discovered models and create run artifacts
4. **FlowTime-Sim** can query run results via `GET /v1/artifacts?type=run&source=simulation-model`

**No Complex APIs Needed:**
- Use existing registry endpoints for discovery
- File-based artifact sharing through shared data directory
- No workflow coordination or state synchronization required
- Each platform remains independent while sharing artifacts


## Integration Points

## Technical Architecture

### **Enhanced Registry Architecture (Minimal API Pattern)**
```
FlowTime.API/
â”œâ”€â”€ Program.cs                            # Enhanced minimal API endpoints
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ IArtifactRegistry.cs             # Extended registry interface  
â”‚   â””â”€â”€ FileSystemArtifactRegistry.cs     # Enhanced with advanced queries
â””â”€â”€ Models/
    â””â”€â”€ ArtifactModels.cs                # Enhanced query options and DTOs
```

**Continues FlowTime's Minimal API Pattern:**
- No controllers or MVC complexity
- Direct endpoint mapping in `Program.cs`
- Simple, functional approach consistent with existing `/run` and `/graph` endpoints
- Enhanced query parameters handled through `HttpContext.Request.Query`

## Integration Points

### **M2.7 Artifacts Registry Foundation**
- Enhanced registry builds on M2.7's file-based JSON registry system
- Advanced querying capabilities extend existing `GET /v1/artifacts` endpoint
- Performance optimizations improve existing registry operations

### **FlowTime-Sim Cross-Project Integration**
- FlowTime-Sim discovers models through enhanced registry endpoints
- Shared data directory enables artifact exchange between projects
- No changes required to existing FlowTime-Engine workflows

### **M2.6 Export System**
- Enhanced registry provides better discovery of exportable artifacts
- Improved performance for finding and filtering export candidates

## Acceptance Criteria

### **AC-M2.8-1: Enhanced Registry Query API**
âœ… **Advanced Filtering**: Support complex queries with multiple filters, date ranges, and metadata searches  
âœ… **Performance**: Sub-second response times for 1000+ artifacts with efficient pagination  
âœ… **Sorting & Search**: Full-text search across artifact metadata with configurable sorting  
âœ… **Bulk Operations**: Batch queries and operations for improved efficiency  

### **AC-M2.8-2: FlowTime-Sim Integration**
âœ… **Artifact Sharing**: FlowTime-Sim can write artifacts to shared data directory and FlowTime-Engine discovers them  
âœ… **Registry Discovery**: FlowTime-Sim can query FlowTime-Engine registry for existing artifacts  
âœ… **Cross-Project Workflow**: Demonstrate complete workflow where Sim creates model, Engine runs it, Sim queries results  
âœ… **Documentation**: Clear integration guide for FlowTime-Sim artifact sharing patterns  

### **AC-M2.8-3: Performance & Reliability**
âœ… **Scale Testing**: Validated performance with 1000+ artifacts across all registry operations  
âœ… **Error Handling**: Robust error handling for file system problems and registry operations  
âœ… **Monitoring**: Comprehensive logging and metrics for registry performance  
âœ… **API Documentation**: Complete documentation for all enhanced registry endpoints

## Implementation Plan

### **Phase 1: Enhanced Registry APIs** 
1. **Extend artifact query capabilities** with advanced filtering, sorting, and full-text search
2. **Add artifact relationship tracking** and cross-reference capabilities
3. **Implement bulk operations** for improved efficiency with large collections
4. **Performance optimization** for 1000+ artifacts with caching and indexing

### **Phase 2: FlowTime-Sim Integration**
1. **Document artifact sharing pattern** using shared data directory
2. **Test cross-project workflow** with FlowTime-Sim writing models and Engine discovering them
3. **Validate registry discovery** from external projects via existing API endpoints
4. **Create integration guide** for FlowTime-Sim developers

### **Phase 3: Performance & Testing**
1. **Comprehensive API testing** with various artifact types and sizes up to 1000+ artifacts
2. **Performance benchmarking** and optimization with sub-second response time validation
3. **Error handling improvements** for file system and registry operation failures
4. **Complete documentation** for all enhanced registry endpoints and integration patterns

## Risk Mitigation

### **User Experience Risk**
**Risk:** Two parallel UI structures confuse users during transition  
**Mitigation:**
- Clear labeling of "Charter UI (New)" vs "Current UI"  
- Transition guide documentation
- Gradual migration path with user choice

### **Complexity Risk**
**Risk:** Maintaining two UI paradigms increases development complexity  
**Mitigation:**
- Shared service layer reduces duplication
- Time-boxed transition period (target: 2-3 milestones)
- Focus on charter UI as primary development path

### **Integration Risk**  
**Risk:** Charter UI and M2.7 registry integration has gaps or performance issues  
**Mitigation:**
- Incremental rollout with fallbacks to legacy UI
- Comprehensive testing with mock and real data
- Performance benchmarks established early

## Success Metrics

### **Adoption Metrics**
- **Charter UI usage**: Track page visits to new tabs vs legacy TemplateRunner
- **Workflow completion**: Users successfully complete Runs wizard end-to-end
- **Zero regressions**: All existing functionality maintains current performance

### **Technical Metrics**  
- **Performance**: Artifacts browser loads in < 2 seconds for 100+ artifacts
- **Integration**: 100% of M2.7 API endpoints consumed correctly
- **Reliability**: Zero navigation errors or broken states

### **Charter Readiness Metrics**
- **Input selection**: Runs wizard can browse and select all artifact types
- **Compare foundation**: Registry actions enable future Compare workflow
- **Artifact lifecycle**: Users can discover, use, and manage artifacts end-to-end

---

## Next Steps

1. **M2.9 (Compare Infrastructure)**: Backend comparison APIs and analysis services that UI-M2.9 will consume
2. **SIM-M3.0 (Charter Integration)**: Cross-platform API integration with FlowTime-Sim services  
3. **UI-M2.8 (Charter Navigation)**: User interface implementation that consumes M2.8 enhanced APIs

This milestone provides the **service-level foundation** for charter workflows, enabling UI-M* milestones to create compelling user experiences on top of robust, charter-aligned APIs and services.

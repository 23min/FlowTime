# M2.8

**Status:** ðŸ“‹ Planned (Charter-Aligned)  
**Dependencies:** M2.7 (Artifacts Registry)  
**Target:** Enhanced API integration with artifacts registry and service-level charter support  
**Date:** 2025-09-20

---

## Goal

Enhance the FlowTime Engine with **comprehensive registry integration** and API capabilities that enable charter-aligned workflows. This milestone focuses on service-level improvements, API enhancements, and backend capabilities that support the charter's [Models]â†’[Runs]â†’[Artifacts]â†’[Learn] paradigm.

**Note:** UI implementation for charter workflows is handled in dedicated UI-M* milestones (UI-M2.7, UI-M2.8, UI-M2.9, UI-M3.0).

## Context & Charter Alignment

The **FlowTime-Engine Charter** defines an artifacts-centric workflow that requires robust API and service capabilities:
- **Registry Integration**: All models, runs, and results stored as discoverable artifacts
- **API Enhancement**: REST APIs support charter workflow patterns
- **Service Architecture**: Backend services enable charter navigation and state management
- **Cross-Platform Readiness**: API design supports future simulation integration

**Service-Level Focus:** This milestone provides the backend foundation that UI-M* milestones consume to create charter-aligned user experiences.

## Functional Requirements

### **FR-M2.8-1: Enhanced Artifacts Registry API**
Extend M2.7 artifacts registry with advanced querying, filtering, and workflow support capabilities.

**Registry Query Enhancement:**
```csharp
// Enhanced Artifacts API Controller
[ApiController]
[Route("v1/artifacts")]
public class ArtifactsController : ControllerBase
{
    [HttpGet]
    public async Task<ActionResult<PagedResult<ArtifactSummary>>> ListArtifacts(
        [FromQuery] ArtifactQueryRequest request)
    {
        var result = await _artifactService.QueryArtifactsAsync(request);
        return Ok(result);
    }

    [HttpGet("{id}/relationships")]
    public async Task<ActionResult<ArtifactRelationships>> GetRelationships(string id)
    {
        var relationships = await _artifactService.GetRelationshipsAsync(id);
        return Ok(relationships);
    }

    [HttpPost("{id}/actions")]
    public async Task<ActionResult<WorkflowActionResult>> ExecuteAction(
        string id, [FromBody] WorkflowActionRequest action)
    {
        var result = await _workflowService.ExecuteActionAsync(id, action);
        return Ok(result);
    }
}

// Enhanced Query Capabilities
public class ArtifactQueryRequest
{
    public string? SearchTerm { get; set; }
    public string[]? Types { get; set; }
    public string[]? Tags { get; set; }
    public DateTime? CreatedAfter { get; set; }
    public DateTime? CreatedBefore { get; set; }
    public ArtifactSortOrder SortBy { get; set; } = ArtifactSortOrder.Created;
    public SortDirection Direction { get; set; } = SortDirection.Descending;
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 20;
}
```

**Workflow Action Support:**
```csharp
public interface IWorkflowActionService
{
    Task<WorkflowActionResult> RunModelArtifactAsync(string artifactId, RunConfiguration config);
    Task<WorkflowActionResult> OpenRunResultsAsync(string artifactId);
    Task<WorkflowActionResult> StartComparisonAsync(string baselineId, string comparisonId);
    Task<WorkflowActionResult> ExportArtifactAsync(string artifactId, ExportFormat format);
}
```

### **FR-M2.8-2: Charter Workflow Services**
Implement service layer support for charter workflow patterns and state management.

**Workflow State Management:**
```csharp
// Services/ICharterWorkflowService.cs
public interface ICharterWorkflowService
{
    Task<WorkflowContext> CreateWorkflowAsync(string name);
    Task<WorkflowContext> GetWorkflowAsync(string workflowId);
    Task UpdateWorkflowAsync(WorkflowContext context);
    Task<IEnumerable<WorkflowContext>> GetRecentWorkflowsAsync(int limit = 10);
    Task<WorkflowTransition> ValidateTransitionAsync(WorkflowStage from, WorkflowStage to, WorkflowContext context);
}

public class WorkflowContext
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = "";
    public WorkflowStage CurrentStage { get; set; } = WorkflowStage.Models;
    public DateTime Created { get; set; } = DateTime.UtcNow;
    public DateTime LastModified { get; set; } = DateTime.UtcNow;
    
    // Stage-specific context
    public string? SelectedModelId { get; set; }
    public string? ActiveRunId { get; set; }
    public List<string> SelectedArtifactIds { get; set; } = new();
    public Dictionary<string, object> StageData { get; set; } = new();
}

public enum WorkflowStage
{
    Models,
    Runs,
    Artifacts,
    Learn
}
```

**Run Orchestration Service:**
```csharp
// Services/IRunOrchestrationService.cs
public interface IRunOrchestrationService
{
    Task<RunConfiguration> CreateRunConfigurationAsync(RunConfigurationRequest request);
    Task<string> StartRunAsync(RunConfiguration config);
    Task<RunStatus> GetRunStatusAsync(string runId);
    Task<RunResults> GetRunResultsAsync(string runId);
    Task CancelRunAsync(string runId);
    Task<IEnumerable<RunSummary>> GetRecentRunsAsync(int limit = 10);
}

public class RunConfigurationRequest
{
    public string WorkflowId { get; set; } = "";
    public string InputArtifactId { get; set; } = "";
    public Dictionary<string, object> Parameters { get; set; } = new();
    public RunType Type { get; set; } = RunType.Analysis;
}

public class RunConfiguration
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string WorkflowId { get; set; } = "";
    public ArtifactReference Input { get; set; } = new();
    public Dictionary<string, object> Parameters { get; set; } = new();
    public RunType Type { get; set; }
    public DateTime Created { get; set; } = DateTime.UtcNow;
}
```

### **FR-M2.8-3: Cross-Platform API Preparation**
Prepare API architecture for future FlowTime-Sim integration and cross-platform workflows.

**Model Integration API Design:**
```csharp
// Controllers/IntegrationController.cs
[ApiController]
[Route("v1/integration")]
public class IntegrationController : ControllerBase
{
    [HttpGet("capabilities")]
    public async Task<ActionResult<IntegrationCapabilities>> GetCapabilities()
    {
        var capabilities = await _integrationService.GetCapabilitiesAsync();
        return Ok(capabilities);
    }

    [HttpPost("sim-models")]
    public async Task<ActionResult<string>> RegisterSimulationModel(
        [FromBody] SimModelRegistrationRequest request)
    {
        var artifactId = await _integrationService.RegisterSimModelAsync(request);
        return Ok(new { ArtifactId = artifactId });
    }

    [HttpGet("cross-platform/{engineRunId}/sim-equivalent")]
    public async Task<ActionResult<SimulationEquivalent>> FindSimulationEquivalent(
        string engineRunId)
    {
        var equivalent = await _integrationService.FindSimEquivalentAsync(engineRunId);
        return Ok(equivalent);
    }
}

public class IntegrationCapabilities
{
    public bool SimulationServiceAvailable { get; set; }
    public string[] SupportedModelTypes { get; set; } = Array.Empty<string>();
    public string[] CrossPlatformWorkflows { get; set; } = Array.Empty<string>();
    public Dictionary<string, object> ServiceVersions { get; set; } = new();
}
```

**Workflow State Persistence:**
```csharp
// Services/IWorkflowStateService.cs  
public interface IWorkflowStateService
{
    Task<string> SaveWorkflowStateAsync(WorkflowContext context);
    Task<WorkflowContext?> RestoreWorkflowStateAsync(string contextId);
    Task<bool> ValidateWorkflowTransitionAsync(string contextId, WorkflowStage targetStage);
    Task CleanupExpiredContextsAsync(TimeSpan maxAge);
}

// Workflow state persistence for charter navigation
public class WorkflowStateService : IWorkflowStateService
{
    private readonly ICharterRepository _repository;
    
    public async Task<string> SaveWorkflowStateAsync(WorkflowContext context)
    {
        context.LastModified = DateTime.UtcNow;
        await _repository.UpsertWorkflowContextAsync(context);
        return context.Id;
    }

    public async Task<bool> ValidateWorkflowTransitionAsync(string contextId, WorkflowStage targetStage)
    {
        var context = await _repository.GetWorkflowContextAsync(contextId);
        if (context == null) return false;

        return targetStage switch
        {
            WorkflowStage.Models => true, // Always allow returning to Models
            WorkflowStage.Runs => !string.IsNullOrEmpty(context.SelectedModelId),
            WorkflowStage.Artifacts => !string.IsNullOrEmpty(context.ActiveRunId),
            WorkflowStage.Learn => context.SelectedArtifactIds.Any(),
            _ => false
        };
    }
}
```

### **FR-M2.8-4: Legacy Integration & Backward Compatibility**
Maintain full backward compatibility while introducing charter-aligned service patterns.

**Legacy Service Bridge:**
```csharp
// Services/ILegacyBridgeService.cs
public interface ILegacyBridgeService
{
    Task<string> ConvertTemplateRunToWorkflowAsync(string templateRunId);
    Task<TemplateRunResult> ConvertWorkflowToTemplateRunAsync(string workflowId);
    Task<bool> IsLegacyRouteAsync(string route);
    Task MigrateUserPreferencesAsync(string userId, UserPreferences preferences);
}

// Bridge between existing TemplateRunner and new charter workflows
public class LegacyBridgeService : ILegacyBridgeService
{
    private readonly ITemplateService _templateService;
    private readonly ICharterWorkflowService _workflowService;
    
    public async Task<string> ConvertTemplateRunToWorkflowAsync(string templateRunId)
    {
        var templateRun = await _templateService.GetTemplateRunAsync(templateRunId);
        
        var workflow = new WorkflowContext
        {
            Name = $"Migrated: {templateRun.Name}",
            CurrentStage = WorkflowStage.Runs,
            SelectedModelId = templateRun.ModelArtifactId,
            StageData = new Dictionary<string, object>
            {
                ["templateRunId"] = templateRunId,
                ["migrated"] = true
            }
        };
        
        await _workflowService.UpdateWorkflowAsync(workflow);
        return workflow.Id;
    }
}

## API Architecture

### **Enhanced Artifact Management APIs**
```csharp
// Controllers/V1/ArtifactsController.cs - Extended capabilities
[ApiController]
[Route("v1/artifacts")]
public class ArtifactsController : ControllerBase
{
    [HttpGet("workflow/{workflowId}")]
    public async Task<ActionResult<IEnumerable<ArtifactSummary>>> GetWorkflowArtifacts(
        string workflowId, [FromQuery] string[] types = null)
    {
        var artifacts = await _artifactService.GetWorkflowArtifactsAsync(workflowId, types);
        return Ok(artifacts);
    }

    [HttpPost("{id}/workflow-actions")]
    public async Task<ActionResult<WorkflowActionResponse>> ExecuteWorkflowAction(
        string id, [FromBody] WorkflowActionRequest request)
    {
        var response = await _workflowService.ExecuteActionAsync(id, request);
        return Ok(response);
    }
}

// Enhanced workflow action support
public class WorkflowActionRequest
{
    public string Action { get; set; } = ""; // "run", "compare", "export", "edit"
    public string WorkflowId { get; set; } = "";
    public Dictionary<string, object> Parameters { get; set; } = new();
}
```

### **Charter State Management API**
```csharp
// Controllers/V1/CharterController.cs
[ApiController] 
[Route("v1/charter")]
public class CharterController : ControllerBase
{
    [HttpPost("workflows")]
    public async Task<ActionResult<WorkflowContext>> CreateWorkflow([FromBody] CreateWorkflowRequest request)
    {
        var workflow = await _workflowService.CreateWorkflowAsync(request.Name);
        return Ok(workflow);
    }

    [HttpGet("workflows/{id}")]
    public async Task<ActionResult<WorkflowContext>> GetWorkflow(string id)
    {
        var workflow = await _workflowService.GetWorkflowAsync(id);
        return Ok(workflow);
    }

    [HttpPut("workflows/{id}/stage")]
    public async Task<ActionResult<WorkflowTransitionResult>> TransitionStage(
        string id, [FromBody] StageTransitionRequest request)
    {
        var result = await _workflowService.TransitionStageAsync(id, request.TargetStage);
        return Ok(result);
    }
}
```

### **Cross-Platform Integration Foundation**
```csharp
// Prepare API structure for future SIM-M3.0 integration
// Services/IPlatformIntegrationService.cs
public interface IPlatformIntegrationService
{
    Task<PlatformCapabilities> GetCapabilitiesAsync(string platform);
    Task<string> RegisterCrossPlatformArtifactAsync(CrossPlatformArtifact artifact);
    Task<CrossPlatformWorkflow> CreateIntegratedWorkflowAsync(string engineWorkflowId, string simWorkflowId);
    Task<bool> ValidateIntegrationAsync(IntegrationValidationRequest request);
}
```

## Integration Points

### **M2.7 Artifacts Registry**
- Artifacts tab consumes M2.7 REST API for artifact listing and actions
- Registry service provides data for Runs wizard input selection  
- Artifact browser enables charter "Browse Registry..." workflows

### **Existing TemplateRunner**
- Legacy Template Studio remains fully functional during transition
- Users can choose between charter Runs wizard or existing TemplateRunner
- No breaking changes to current workflows or API integrations

### **M2.6 Export System**
- Export functionality available in both charter Results view and legacy TemplateRunner
- Run artifacts (M2.7) integrate with M2.6 export files for discoverability

## Acceptance Criteria

### **Enhanced Artifacts Registry API**
- âœ… Advanced artifact querying with filtering, sorting, and pagination
- âœ… Workflow action APIs support Run, Compare, Export actions on artifacts
- âœ… Artifact relationship tracking and cross-references work correctly
- âœ… Performance meets requirements for 1000+ artifacts (< 2 sec response times)

### **Charter Workflow Services**
- âœ… Workflow context creation, persistence, and state management functional
- âœ… Workflow stage transitions validate dependencies and maintain integrity
- âœ… Cross-platform integration foundation prepared for SIM-M3.0
- âœ… Legacy bridge service maintains backward compatibility with existing workflows

### **API Enhancement & Integration**
- âœ… All M2.7 registry APIs extended with charter workflow support
- âœ… Run orchestration service handles charter workflow run configurations
- âœ… Integration APIs prepared for future FlowTime-Sim connectivity
- âœ… Service layer supports both legacy and charter interaction patterns

### **Backward Compatibility & Stability**
- âœ… All existing API endpoints remain functional and stable
- âœ… Legacy TemplateRunner integration preserved through bridge services
- âœ… No breaking changes to current API contracts or data models
- âœ… Performance characteristics maintained or improved across all services

## Implementation Plan

### **Phase 1: Enhanced Registry APIs (Week 1)**
1. **Extend artifact query capabilities** with advanced filtering and sorting
2. **Implement workflow action APIs** for Run, Compare, Export operations
3. **Add artifact relationship tracking** and cross-reference capabilities
4. **Performance optimization** for large artifact collections

### **Phase 2: Charter Workflow Services (Week 2)**
1. **Implement workflow context management** with state persistence
2. **Add workflow stage transition validation** and integrity checks
3. **Create run orchestration service** for charter workflow patterns
4. **Integration testing** with M2.7 registry foundation

### **Phase 3: Cross-Platform Preparation (Week 3)**
1. **Design integration APIs** for future FlowTime-Sim connectivity
2. **Implement platform capability discovery** and validation
3. **Create cross-platform artifact registration** framework
4. **Legacy bridge service** for backward compatibility

### **Phase 4: API Integration & Testing (Week 4)**
1. **Comprehensive API testing** with various artifact types and sizes
2. **Performance benchmarking** and optimization
3. **Integration validation** with existing TemplateRunner workflows
4. **Documentation** for enhanced API capabilities and charter service patterns

## Risk Mitigation

### **User Experience Risk**
**Risk:** Two parallel UI structures confuse users during transition  
**Mitigation:**
- Clear labeling of "Charter UI (New)" vs "Current UI"  
- Transition guide documentation
- Gradual migration path with user choice

### **Complexity Risk**
**Risk:** Maintaining two UI paradigms increases development complexity  
**Mitigation:**
- Shared service layer reduces duplication
- Time-boxed transition period (target: 2-3 milestones)
- Focus on charter UI as primary development path

### **Integration Risk**  
**Risk:** Charter UI and M2.7 registry integration has gaps or performance issues  
**Mitigation:**
- Incremental rollout with fallbacks to legacy UI
- Comprehensive testing with mock and real data
- Performance benchmarks established early

## Success Metrics

### **Adoption Metrics**
- **Charter UI usage**: Track page visits to new tabs vs legacy TemplateRunner
- **Workflow completion**: Users successfully complete Runs wizard end-to-end
- **Zero regressions**: All existing functionality maintains current performance

### **Technical Metrics**  
- **Performance**: Artifacts browser loads in < 2 seconds for 100+ artifacts
- **Integration**: 100% of M2.7 API endpoints consumed correctly
- **Reliability**: Zero navigation errors or broken states

### **Charter Readiness Metrics**
- **Input selection**: Runs wizard can browse and select all artifact types
- **Compare foundation**: Registry actions enable future Compare workflow
- **Artifact lifecycle**: Users can discover, use, and manage artifacts end-to-end

---

## Next Steps

1. **M2.9 (Compare Infrastructure)**: Backend comparison APIs and analysis services that UI-M2.9 will consume
2. **SIM-M3.0 (Charter Integration)**: Cross-platform API integration with FlowTime-Sim services  
3. **UI-M2.8 (Charter Navigation)**: User interface implementation that consumes M2.8 enhanced APIs

This milestone provides the **service-level foundation** for charter workflows, enabling UI-M* milestones to create compelling user experiences on top of robust, charter-aligned APIs and services.

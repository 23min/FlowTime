# M2.10 Test Strategy ‚Äî Provenance Query Support

**Branch:** `feature/api-m2.10/provenance-queries`  
**TDD Approach:** RED ‚Üí GREEN ‚Üí REFACTOR  
**Estimated Test Writing Time:** 30 minutes  
**Estimated Implementation Time:** 30-60 minutes

---

## Overview

This test strategy follows **strict TDD principles** for implementing provenance query support in both API and CLI layers. Tests will be written **first** (RED state), then implementation will make them pass (GREEN state), followed by refactoring (REFACTOR).

---

## ‚ö†Ô∏è Important: Test Configuration & Data Isolation

**Before writing tests, review existing test patterns:**

### Required Reading
1. **`tests/FlowTime.Api.Tests/TestWebApplicationFactory.cs`** - Shows how test data isolation works
2. **`tests/FlowTime.Api.Tests/Provenance/ProvenanceHeaderTests.cs`** - Example of API test patterns
3. **`tests/FlowTime.Api.Tests/ArtifactEndpointTests.cs`** - Example of artifacts endpoint testing

### Key Patterns

#### API Tests - Data Isolation
```csharp
public class ProvenanceQueryTests : IClassFixture<TestWebApplicationFactory>
{
    private readonly HttpClient _client;
    private readonly TestWebApplicationFactory _factory;

    public ProvenanceQueryTests(TestWebApplicationFactory factory)
    {
        _factory = factory;
        _client = factory.CreateClient();
    }
    
    // Use _factory.TestDataDirectory to access test data
    // Example: Path.Combine(_factory.TestDataDirectory, runId, "provenance.json")
}
```

**How it works:**
- `TestWebApplicationFactory` automatically creates a unique temp directory for each test run
- Format: `/tmp/flowtime_test_{12-char-guid}/`
- Environment variables set: `ArtifactsDirectory` and `DataDirectory` point to temp directory
- Test data is **automatically cleaned up** after tests complete
- **Production `/data/` directory is NEVER touched by tests**

#### API Calling Patterns
```csharp
// GET request with query parameters
var response = await _client.GetAsync("/v1/artifacts?templateId=transportation-basic");

// POST request with YAML content
var request = new HttpRequestMessage(HttpMethod.Post, "/v1/run")
{
    Content = new StringContent(modelYaml, new MediaTypeHeaderValue("application/x-yaml"))
};
request.Headers.Add("X-Model-Provenance", "model_xyz");
var response = await _client.SendAsync(request);

// Parse JSON response
var responseJson = await response.Content.ReadAsStringAsync();
var result = JsonSerializer.Deserialize<JsonElement>(responseJson);
```

#### Helper Methods Pattern
```csharp
private async Task<string> CreateTestRunWithProvenance(
    string templateId = null, 
    string modelId = null)
{
    var model = $$"""
        schemaVersion: 1
        grid:
          bins: 4
          binSize: 1
          binUnit: hours
        nodes:
          - id: demand
            kind: const
            values: [100, 120, 150, 130]
        """;

    var request = new HttpRequestMessage(HttpMethod.Post, "/v1/run")
    {
        Content = new StringContent(model, new MediaTypeHeaderValue("application/x-yaml"))
    };
    
    if (modelId != null || templateId != null)
    {
        // Create provenance metadata
        var provenance = new { source = "flowtime-sim", templateId, modelId };
        request.Headers.Add("X-Model-Provenance", JsonSerializer.Serialize(provenance));
    }

    var response = await _client.SendAsync(request);
    var responseJson = await response.Content.ReadAsStringAsync();
    var result = JsonSerializer.Deserialize<JsonElement>(responseJson);
    return result.GetProperty("runId").GetString()!;
}

private string GetProvenanceFilePath(string runId)
{
    return Path.Combine(_factory.TestDataDirectory, runId, "provenance.json");
}
```

### CLI Tests - Data Isolation
CLI tests will need similar isolation. Check existing CLI tests for patterns:
- May use temp directories or mock registries
- Should NOT write to production `/data/` directory
- Consider using `IClassFixture` for shared test setup

### Testing Philosophy: No Mocking

**FlowTime follows a "no mocking" testing approach:**
- ‚úÖ **Use real components**: `WebApplicationFactory<Program>` runs the actual API
- ‚úÖ **Use real file system**: Tests write to real temp directories
- ‚úÖ **Use real registry**: `FileSystemArtifactRegistry` operates on real files
- ‚ùå **NO mocking** of Core services (IArtifactRegistry, etc.)
- ‚ùå **NO mocking** of file system operations

**Why?**
- Tests validate actual behavior, not mock behavior
- Integration tests catch real issues (file permissions, serialization, etc.)
- Simpler test code (no mock setup/verification)
- Higher confidence in production code

**Exception:** CLI tests may use in-memory configurations for performance, but should still avoid mocking Core logic.

### Critical Reminders
- ‚úÖ **ALWAYS** use `TestWebApplicationFactory` for API tests
- ‚úÖ **ALWAYS** use `_factory.TestDataDirectory` to access test artifacts
- ‚úÖ **NEVER** hardcode `/data/` or production paths in tests
- ‚úÖ **NEVER** mock Core services or file system operations
- ‚úÖ **VERIFY** test cleanup (check temp directories are deleted)
- ‚úÖ **REVIEW** existing test patterns before writing new tests

---

## Part 1: API Tests

### Test File Location
```
tests/FlowTime.Api.Tests/Provenance/ProvenanceQueryTests.cs
```

### Test Class Structure
```csharp
namespace FlowTime.Api.Tests.Provenance;

public class ProvenanceQueryTests : IClassFixture<TestWebApplicationFactory>
{
    private readonly HttpClient _client;
    private readonly TestWebApplicationFactory _factory;

    public ProvenanceQueryTests(TestWebApplicationFactory factory)
    {
        _factory = factory;
        _client = factory.CreateClient();
    }

    // Test methods below...
}
```

### API Test Scenarios (8 tests)

#### 1. Query by TemplateId Returns Matching Artifacts
```csharp
[Fact]
public async Task GetArtifacts_WithTemplateId_ReturnsMatchingArtifacts()
{
    // Arrange: Create test artifacts with provenance
    // - Run A: templateId = "transportation-basic"
    // - Run B: templateId = "manufacturing-line"
    // - Run C: no provenance
    
    // Act: GET /v1/artifacts?templateId=transportation-basic
    
    // Assert: 
    // - Response 200 OK
    // - Returns only Run A
    // - Run C excluded (no provenance)
}
```

#### 2. Query by ModelId Returns Exact Match
```csharp
[Fact]
public async Task GetArtifacts_WithModelId_ReturnsExactMatch()
{
    // Arrange: Create test artifacts
    // - Run A: modelId = "model_123"
    // - Run B: modelId = "model_456"
    
    // Act: GET /v1/artifacts?modelId=model_123
    
    // Assert: Returns only Run A
}
```

#### 3. Combined Filters Work Correctly
```csharp
[Fact]
public async Task GetArtifacts_WithTemplateIdAndModelId_ReturnsBothMatches()
{
    // Arrange: Create test artifacts
    // - Run A: templateId = "template-1", modelId = "model_123"
    // - Run B: templateId = "template-2", modelId = "model_123" 
    // - Run C: templateId = "template-1", modelId = "model_456"
    
    // Act: GET /v1/artifacts?templateId=template-1&modelId=model_123
    
    // Assert: Returns only Run A (both filters match)
}
```

#### 4. Empty Results When No Matches Found
```csharp
[Fact]
public async Task GetArtifacts_WithNonExistentTemplateId_ReturnsEmptyResult()
{
    // Arrange: Create test artifacts with different templateIds
    
    // Act: GET /v1/artifacts?templateId=non-existent
    
    // Assert:
    // - Response 200 OK
    // - { "artifacts": [], "total": 0, "count": 0 }
}
```

#### 5. Case-Sensitive Matching Behavior
```csharp
[Fact]
public async Task GetArtifacts_TemplateIdCaseSensitive_NoMatch()
{
    // Arrange: Run with templateId = "Transportation-Basic"
    
    // Act: GET /v1/artifacts?templateId=transportation-basic
    
    // Assert: Empty results (case mismatch)
}
```

#### 6. Pagination Works With Provenance Filters
```csharp
[Fact]
public async Task GetArtifacts_WithTemplateIdAndPagination_ReturnsPagedResults()
{
    // Arrange: Create 5 runs with same templateId
    
    // Act: GET /v1/artifacts?templateId=template-1&limit=2&skip=0
    
    // Assert:
    // - Returns 2 artifacts
    // - total = 5, count = 2
}
```

#### 7. Sorting Works With Provenance Filters
```csharp
[Fact]
public async Task GetArtifacts_WithTemplateIdAndSorting_ReturnsSortedResults()
{
    // Arrange: Create 3 runs with same templateId at different times
    
    // Act: GET /v1/artifacts?templateId=template-1&sortBy=created&sortOrder=desc
    
    // Assert: Results ordered by created timestamp descending
}
```

#### 8. Artifacts Without Provenance Excluded From Results
```csharp
[Fact]
public async Task GetArtifacts_WithTemplateId_ExcludesArtifactsWithoutProvenance()
{
    // Arrange: 
    // - Run A: has provenance with templateId = "template-1"
    // - Run B: no provenance.json file
    // - Run C: provenance.json exists but no templateId field
    
    // Act: GET /v1/artifacts?templateId=template-1
    
    // Assert: Returns only Run A
}
```

### Test Helpers

```csharp
private async Task<string> CreateTestRunWithProvenance(
    string templateId = null, 
    string modelId = null)
{
    // Helper to create test artifact with provenance
}

private async Task<string> CreateTestRunWithoutProvenance()
{
    // Helper to create test artifact without provenance
}
```

---

## Part 2: CLI Tests

### Test File Location
```
tests/FlowTime.Cli.Tests/Commands/ProvenanceQueryTests.cs
```

### Test Class Structure
```csharp
namespace FlowTime.Cli.Tests.Commands;

public class ProvenanceQueryTests
{
    // Note: CLI tests may require test fixture for temp directories
    // and mock artifact registry setup
}
```

### CLI Test Scenarios (4 tests)

#### 1. artifacts list --template-id Filters Correctly
```csharp
[Fact]
public async Task ArtifactsList_WithTemplateIdFlag_FiltersCorrectly()
{
    // Arrange: Setup test registry with artifacts
    // - Run A: templateId = "transportation-basic"
    // - Run B: templateId = "manufacturing-line"
    
    // Act: flowtime artifacts list --template-id transportation-basic
    
    // Assert:
    // - Exit code 0
    // - Output contains Run A ID
    // - Output does NOT contain Run B ID
}
```

#### 2. artifacts list --model-id Filters Correctly
```csharp
[Fact]
public async Task ArtifactsList_WithModelIdFlag_FiltersCorrectly()
{
    // Arrange: Setup test registry
    // - Run A: modelId = "model_123"
    // - Run B: modelId = "model_456"
    
    // Act: flowtime artifacts list --model-id model_123
    
    // Assert: Output contains only Run A
}
```

#### 3. Combined Filters Work in CLI
```csharp
[Fact]
public async Task ArtifactsList_WithBothFlags_FiltersByBoth()
{
    // Arrange: Setup test registry
    // - Run A: templateId = "template-1", modelId = "model_123"
    // - Run B: templateId = "template-1", modelId = "model_456"
    
    // Act: flowtime artifacts list --template-id template-1 --model-id model_123
    
    // Assert: Output contains only Run A
}
```

#### 4. Output Formatting is Correct
```csharp
[Fact]
public async Task ArtifactsList_WithTemplateIdFlag_OutputFormatCorrect()
{
    // Arrange: Setup test registry with known artifact
    
    // Act: flowtime artifacts list --template-id template-1
    
    // Assert:
    // - Output contains table header
    // - Output contains artifact ID, Type, Created, Title
    // - Output contains "Total: N artifacts" footer
}
```

---

## Part 3: Core/Registry Tests

### Test File Location
```
tests/FlowTime.Tests/Registry/ProvenanceFilterTests.cs
```

### Core Test Scenarios (4 tests)

#### 1. Registry Correctly Extracts Provenance from manifest.json
```csharp
[Fact]
public async Task Registry_ExtractsProvenanceFromManifest()
{
    // Arrange: Create test run directory with manifest.json containing provenance
    
    // Act: Call registry scan/rebuild
    
    // Assert: Registry index contains provenance metadata
}
```

#### 2. Provenance Fields Indexed Properly in registry-index.json
```csharp
[Fact]
public async Task Registry_IndexesProvenanceFields()
{
    // Arrange: Create run with provenance
    
    // Act: Rebuild registry index
    
    // Assert: 
    // - registry-index.json contains artifact
    // - metadata.provenance.hasProvenance = true
    // - metadata.provenance.templateId = expected value
    // - metadata.provenance.modelId = expected value
}
```

#### 3. Filter Logic Correctly Matches Provenance Fields
```csharp
[Fact]
public async Task GetArtifacts_FiltersByTemplateId()
{
    // Arrange: Mock registry with artifacts
    
    // Act: GetArtifactsAsync(new ArtifactQueryOptions { TemplateId = "template-1" })
    
    // Assert: Returns only matching artifacts
}
```

#### 4. Null/Missing Provenance Handled Gracefully
```csharp
[Fact]
public async Task GetArtifacts_WithTemplateIdFilter_ExcludesNullProvenance()
{
    // Arrange: Registry with mix of artifacts (with/without provenance)
    
    // Act: GetArtifactsAsync(new ArtifactQueryOptions { TemplateId = "template-1" })
    
    // Assert: 
    // - No exceptions thrown
    // - Only artifacts with matching provenance returned
    // - Artifacts with null/missing provenance excluded
}
```

---

## Test Execution Strategy

### Phase 0: Write Tests (30 minutes)

```bash
# Create test files
# Write all 16 test methods (8 API + 4 CLI + 4 Core)
# Run tests - all should FAIL (RED state)
dotnet test --filter "FullyQualifiedName~ProvenanceQuery"
```

**Expected Result:** All tests compile but fail with clear error messages.

### Phase 1: Implement Features (30-60 minutes)

Implementation order:
1. **Core Layer:** Update `ArtifactQueryOptions` model
2. **Core Layer:** Implement filter logic in `FileSystemArtifactRegistry`
3. **API Layer:** Update endpoint to accept new query parameters
4. **CLI Layer:** Add new command flags

Run tests after each implementation:
```bash
# After core implementation
dotnet test tests/FlowTime.Tests/Registry/ProvenanceFilterTests.cs

# After API implementation
dotnet test tests/FlowTime.Api.Tests/Provenance/ProvenanceQueryTests.cs

# After CLI implementation
dotnet test tests/FlowTime.Cli.Tests/Commands/ProvenanceQueryTests.cs
```

**Expected Result:** Tests turn GREEN one by one.

### Phase 2: Refactor (15 minutes)

- Remove duplicate code
- Add XML documentation comments
- Improve error handling
- Run full test suite to ensure refactoring didn't break anything

```bash
dotnet test --filter "FullyQualifiedName~ProvenanceQuery"
```

**Expected Result:** All tests still GREEN after refactoring.

---

## Test Data Setup

### Sample Provenance Structure

```json
{
  "source": "flowtime-sim",
  "modelId": "model_20251003T175743Z_3218a4e6",
  "templateId": "transportation-basic",
  "templateVersion": "1.0",
  "templateTitle": "Transportation Network",
  "generatedAt": "2025-10-03T17:57:43.457Z",
  "receivedAt": "2025-10-03T17:57:43.5263364Z",
  "generator": "flowtime-sim/0.5.0",
  "parameters": {
    "bins": 6
  }
}
```

### Registry Index Structure

```json
{
  "artifacts": [
    {
      "id": "run_20251003T175743Z_64ec2d02",
      "type": "run",
      "created": "2025-10-03T17:57:43Z",
      "metadata": {
        "provenance": {
          "hasProvenance": true,
          "modelId": "model_20251003T175743Z_3218a4e6",
          "templateId": "transportation-basic"
        }
      }
    }
  ]
}
```

---

## Success Criteria

- [ ] All 16 tests written and initially failing (RED state)
- [ ] Core filtering logic implemented (4 core tests GREEN)
- [ ] API query parameters implemented (8 API tests GREEN)
- [ ] CLI flags implemented (4 CLI tests GREEN)
- [ ] All tests passing after refactoring (GREEN state maintained)
- [ ] Code coverage >95% for new filter logic
- [ ] No regression in existing tests

---

## Test Commands Reference

```bash
# Run all provenance query tests
dotnet test --filter "FullyQualifiedName~ProvenanceQuery"

# Run only API tests
dotnet test tests/FlowTime.Api.Tests/Provenance/ProvenanceQueryTests.cs

# Run only CLI tests
dotnet test tests/FlowTime.Cli.Tests/Commands/ProvenanceQueryTests.cs

# Run only Core tests
dotnet test tests/FlowTime.Tests/Registry/ProvenanceFilterTests.cs

# Run with verbose output
dotnet test --filter "FullyQualifiedName~ProvenanceQuery" --logger "console;verbosity=detailed"

# Generate coverage report (if configured)
dotnet test --collect:"XPlat Code Coverage"
```

---

**Test Strategy Status:** üìã Ready to implement  
**Branch:** `feature/api-m2.10/provenance-queries`  
**Next Action:** Create test files and write failing tests (Phase 0)

# Milestone M0

## Scenarios

- Capacity haircut “what‑if”: If demand is X per time bin and we run at Y% capacity (e.g., 80%), what is the served/throughput curve over the next N bins?
- Variants:
    - Apply a global factor to any baseline series (volume, cost, effort): served = demand × factor, cost = volume × unitCost, total = a + b.
    - Compare scenarios by changing the scalar or swapping a baseline series.

Outputs: a CSV time series you can chart or join with other data.

## How the code works

- Timeline as bins: It slices time into equal bins (e.g., 8 bins × 60 minutes). Every number aligns to this grid.
- Named series (nodes): Each node is a labeled time series. Two types exist today:
    - Constant series (baseline you provide).
    - Formula series (simple math combining other series or a series with a scalar).
- Dependency graph: Nodes reference each other like a spreadsheet. The graph enforces “no cycles” and calculates in the right order.
- Simple math now, richer later: Current formulas support Add and Multiply, including a scalar on the right (e.g., “demand × 0.8”). Future milestones add shift/delay/clamp, parser, queues, routing.
- Deterministic evaluation: Given the same inputs, you always get the same outputs. Results are exported as clean, culture‑invariant CSV.

## Why it’s useful now

- Fast scenario math: Answer “what if we drop to 80% for 8 hours?” immediately with explainable lineage.
- Auditable and reproducible: Inputs and formulas are explicit; runs are repeatable.
- Foundation for next steps: The same graph model will power backlog, latency, shifts/delays, and routing as they’re added.

## Devcontainer (M0)

M0 includes a minimal devcontainer for consistent local/Codespaces setup (just .NET 9 + PowerShell + VS Code extensions). See `docs/devcontainer.md` for details. Keep it lean now; add optional tooling (Node, Azure CLI, Azurite) in later milestones.